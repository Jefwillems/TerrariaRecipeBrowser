(window.webpackJsonp = window.webpackJsonp || []).push([['recipe'], {
  '0e55': function (t, e, i) {
    (function (e, o) { t.exports = o(i('4f27')); }(0, t => (function (t) { const e = {}; function i(o) { if (e[o]) return e[o].exports; const n = e[o] = { i: o, l: !1, exports: {} }; return t[o].call(n.exports, n, n.exports, i), n.l = !0, n.exports; } return i.m = t, i.c = e, i.d = function (t, e, o) { i.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: o }); }, i.r = function (t) { typeof Symbol !== 'undefined' && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: 'Module' }), Object.defineProperty(t, '__esModule', { value: !0 }); }, i.t = function (t, e) { if (1 & e && (t = i(t)), 8 & e) return t; if (4 & e && typeof t === 'object' && t && t.__esModule) return t; const o = Object.create(null); if (i.r(o), Object.defineProperty(o, 'default', { enumerable: !0, value: t }), 2 & e && typeof t !== 'string') for (const n in t)i.d(o, n, (e => t[e]).bind(null, n)); return o; }, i.n = function (t) { const e = t && t.__esModule ? function () { return t.default; } : function () { return t; }; return i.d(e, 'a', e), e; }, i.o = function (t, e) { return Object.prototype.hasOwnProperty.call(t, e); }, i.p = '', i(i.s = 12); }([function (t, e, i) {
      function o(t, e, i, o, n, s, r, a) { let h; const d = typeof t === 'function' ? t.options : t; if (e && (d.render = e, d.staticRenderFns = i, d._compiled = !0), o && (d.functional = !0), s && (d._scopeId = `data-v-${s}`), r ? (h = function (t) { t = t || this.$vnode && this.$vnode.ssrContext || this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext, t || typeof __VUE_SSR_CONTEXT__ === 'undefined' || (t = __VUE_SSR_CONTEXT__), n && n.call(this, t), t && t._registeredComponents && t._registeredComponents.add(r); }, d._ssrRegister = h) : n && (h = a ? function () { n.call(this, this.$root.$options.shadowRoot); } : n), h) if (d.functional) { d._injectStyles = h; const l = d.render; d.render = function (t, e) { return h.call(e), l(t, e); }; } else { const u = d.beforeCreate; d.beforeCreate = u ? [].concat(u, h) : [h]; } return { exports: t, options: d }; }i.d(e, 'a', () => o);
    }, function (e, i) { e.exports = t; }, function (t, e, i) {
      i.r(e); const o = i(3); const n = i.n(o); for (const s in o)s !== 'default' && (function (t) { i.d(e, t, () => o[t]); }(s)); e.default = n.a;
    }, function (t, e, i) {
      Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(1); const n = i(8); e.default = {
        name: 'timeline',
        props: {
          groups: { type: [Array, o.DataSet, o.DataView], default() { return []; } }, items: { type: [Array, o.DataSet, o.DataView], default() { return []; } }, events: { type: Array, default() { return ['click', 'contextmenu', 'currentTimeTick', 'doubleClick', 'drop', 'mouseOver', 'mouseDown', 'mouseUp', 'mouseMove', 'groupDragged', 'changed', 'rangechange', 'rangechanged', 'select', 'itemover', 'itemout', 'timechange', 'timechanged']; } }, selection: { type: [Array, String], default() { return []; } }, options: { type: Object },
        },
        data() { return { visData: { items: null, groups: null } }; },
        watch: { options: { deep: !0, handler(t) { this.timeline.setOptions(t); } }, selection: { deep: !1, handler(t) { this.timeline.setSelection(t); } } },
        methods: {
          addCustomTime(t, e) { return this.timeline.addCustomTime(t, e); }, destroy() { this.timeline.destroy(); }, fit() { this.timeline.fit(); }, focus(t, e) { this.timeline.focus(t, e); }, getCurrentTime() { return this.timeline.getCurrentTime(); }, getCustomTime(t) { return this.timeline.getCustomTime(t); }, getEventProperties(t) { return this.timeline.getEventProperties(t); }, getItemRange() { return this.timeline.getItemRange(); }, getSelection() { return this.timeline.getSelection(); }, getVisibleItems() { return this.timeline.getVisibleItems(); }, getWindow() { return this.timeline.getWindow(); }, moveTo(t, e) { this.timeline.moveTo(t, e); }, on(t, e) { this.timeline.on(t, e); }, off(t, e) { this.timeline.off(t, e); }, redraw() { this.timeline.redraw(); }, removeCustomTime(t) { this.timeline.removeCustomTime(t); }, setCurrentTime(t) { this.timeline.setCurrentTime(t); }, setCustomTime(t, e) { this.timeline.setCustomTime(t, e); }, setCustomTimeTitle(t, e) { this.timeline.setCustomTimeTitle(t, e); }, setData(t) { this.timeline.setData(t); }, setGroups(t) { this.timeline.setGroups(t); }, setItems(t) { this.timeline.setItems(t); }, setOptions(t) { this.timeline.setOptions(t); }, setSelection(t, e) { this.timeline.setSelection(t, e); }, setWindow(t, e, i, o) { this.timeline.setWindow(t, e, i, o); }, toggleRollingMode() { this.timeline.toggleRollingMode(); }, zoomIn(t, e, i) { this.timeline.zoomIn(t, e, i); }, zoomOut(t, e, i) { this.timeline.zoomOut(t, e, i); },
        },
        mounted() { const t = this; const e = this.$refs.visualization; this.visData.items = (0, n.mountVisData)(this, 'items'), this.groups && this.groups.length > 0 ? (this.visData.groups = (0, n.mountVisData)(this, 'groups'), this.timeline = new o.Timeline(e, this.visData.items, this.visData.groups, this.options)) : this.timeline = new o.Timeline(e, this.visData.items, this.options), this.events.forEach(e => t.timeline.on(e, (i) => t.$emit((0, n.translateEvent)(e), i))); },
        created() { this.timeline = null; },
        beforeDestroy() { this.timeline.destroy(); },
      };
    }, function (t, e, i) {
      i.r(e); const o = i(5); const n = i.n(o); for (const s in o)s !== 'default' && (function (t) { i.d(e, t, () => o[t]); }(s)); e.default = n.a;
    }, function (t, e, i) {
      Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(1); const n = i(8); e.default = {
        name: 'graph2d',
        props: {
          groups: { type: [Array, o.DataSet, o.DataView], default() { return []; } }, items: { type: [Array, o.DataSet, o.DataView], default() { return []; } }, events: { type: Array, default() { return ['click', 'contextmenu', 'currentTimeTick', 'doubleClick', 'changed', 'rangechange', 'rangechanged', 'timechange', 'timechanged']; } }, options: { type: Object },
        },
        data() { return { visData: { items: null, groups: null } }; },
        watch: { options: { deep: !0, handler(t) { this.graph2d.setOptions(t); } } },
        methods: {
          destroy() { this.graph2d.destroy(); }, fit() { this.graph2d.fit(); }, getCurrentTime() { return this.graph2d.getCurrentTime(); }, getCustomTime() { return this.graph2d.getCustomTime(id); }, getDataRange() { return this.graph2d.getDataRange(); }, getEventProperties(t) { return this.graph2d.getEventProperties(t); }, getLegend(t, e, i) { return this.graph2d.getLegend(t, e, i); }, getWindow() { return this.graph2d.getWindow(); }, isGroupVisible(t) { return this.graph2d.isGroupVisible(t); }, moveTo(t, e) { this.graph2d.moveTo(t, e); }, on(t, e) { this.graph2d.on(t, e); }, off(t, e) { this.graph2d.off(t, e); }, redraw() { this.graph2d.redraw(); }, setCurrentTime(t) { this.graph2d.setCurrentTime(t); }, setCustomTime(t) { this.graph2d.setCustomTime(t); }, setGroups(t) { this.graph2d.setGroups(t); }, setItems(t) { this.graph2d.setItems(t); }, setOptions(t) { this.graph2d.setOptions(t); }, setWindow(t, e) { this.graph2d.setWindow(t, e); },
        },
        mounted() { const t = this; const e = this.$refs.visualization; this.visData.items = (0, n.mountVisData)(this, 'items'), this.visData.groups = (0, n.mountVisData)(this, 'groups'), this.graph2d = new o.Graph2d(e, this.visData.items, this.visData.groups, this.options), this.events.forEach(e => t.graph2d.on(e, (i) => t.$emit((0, n.translateEvent)(e), i))); },
        created() { this.graph2d = null; },
        beforeDestroy() { this.graph2d.destroy(); },
      };
    }, function (t, e, i) {
      i.r(e); const o = i(7); const n = i.n(o); for (const s in o)s !== 'default' && (function (t) { i.d(e, t, () => o[t]); }(s)); e.default = n.a;
    }, function (t, e, i) {
      Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(1); const n = i(8); e.default = {
        name: 'network',
        props: {
          edges: { type: [Array, o.DataSet, o.DataView], default() { return []; } }, nodes: { type: [Array, o.DataSet, o.DataView], default() { return []; } }, events: { type: Array, default() { return ['click', 'doubleClick', 'oncontext', 'hold', 'release', 'select', 'selectNode', 'selectEdge', 'deselectNode', 'deselectEdge', 'dragStart', 'dragging', 'dragEnd', 'hoverNode', 'blurNode', 'hoverEdge', 'blurEdge', 'zoom', 'showPopup', 'hidePopup', 'startStabilizing', 'stabilizationProgress', 'stabilizationIterationsDone', 'stabilized', 'resize', 'initRedraw', 'beforeDrawing', 'afterDrawing', 'animationFinished', 'configChange']; } }, options: { type: Object, default() { return {}; } },
        },
        data() { return { visData: { nodes: null, edges: null } }; },
        watch: { options: { deep: !0, handler(t) { this.network.setOptions(t); } } },
        methods: {
          setData(t, e) { this.visData.nodes = Array.isArray(t) ? new o.DataSet(t) : t, this.visData.edges = Array.isArray(e) ? new o.DataSet(e) : e, this.network.setData(this.visData); }, destroy() { this.network.destroy(); }, getNode(t) { return this.visData.nodes.get(t); }, getEdge(t) { return this.visData.edges.get(t); }, setOptions(t) { this.network.setOptions(t); }, on(t, e) { this.network.moveTo(t, e); }, off(t, e) { this.network.moveTo(t, e); }, once(t, e) { this.network.moveTo(t, e); }, canvasToDom(t) { return this.network.canvasToDOM(t); }, domToCanvas(t) { return this.network.DOMtoCanvas(t); }, redraw() { this.network.redraw(); }, setSize(t, e) { this.network.setSize(t, e); }, cluster(t) { this.network.cluster(t); }, clusterByConnection(t, e) { this.network.clusterByConnection(t, e); }, clusterByHubsize(t, e) { this.network.clusterByHubsize(t, e); }, clusterOutliers(t) { this.network.clusterOutliers(t); }, findNode(t) { return this.network.findNode(t); }, getClusteredEdges(t) { return this.network.clustering.getClusteredEdges(t); }, getBaseEdge(t) { return this.network.clustering.getBaseEdge(t); }, getBaseEdges(t) { return this.network.clustering.getBaseEdges(t); }, updateEdge(t, e) { this.network.clustering.updateEdge(t, e); }, updateClusteredNode(t, e) { this.network.clustering.updateClusteredNode(t, e); }, isCluster(t) { return this.network.isCluster(t); }, getNodesInCluster(t) { return this.network.getNodesInCluster(t); }, openCluster(t, e) { this.network.openCluster(t, e); }, getSeed() { return this.network.getSeed(); }, enableEditMode() { this.network.enableEditMode(); }, disableEditMode() { this.network.disableEditMode(); }, addNodeMode() { this.network.addNodeMode(); }, editNode() { this.network.editNode(); }, addEdgeMode() { this.network.addEdgeMode(); }, editEdgeMode() { this.network.editEdgeMode(); }, deleteSelected() { this.network.deleteSelected(); }, getPositions(t) { return this.network.getPositions(t); }, storePositions() { this.network.storePositions(); }, moveNode(t, e, i) { this.network.moveNode(t, e, i); }, getBoundingBox(t) { return this.network.getBoundingBox(t); }, getConnectedNodes(t, e) { return this.network.getConnectedNodes(t, e); }, getConnectedEdges(t) { return this.network.getConnectedEdges(t); }, startSimulation() { this.network.startSimulation(); }, stopSimulation() { this.network.stopSimulation(); }, stabilize(t) { this.network.stabilize(t); }, getSelection() { return this.network.getSelection(); }, getSelectedNodes() { return this.network.getSelectedNodes(); }, getSelectedEdges() { return this.network.getSelectedEdges(); }, getNodeAt(t) { return this.network.getNodeAt(t); }, getEdgeAt(t) { return this.network.getEdgeAt(t); }, selectNodes(t, e) { this.network.selectNodes(t, e); }, selectEdges(t) { this.network.selectEdges(t); }, setSelection(t, e) { this.network.setSelection(t, e); }, unselectAll() { this.network.unselectAll(); }, getScale() { return this.network.getScale(); }, getViewPosition() { return this.network.getViewPosition(); }, fit(t) { this.network.fit(t); }, focus(t, e) { this.network.focus(t, e); }, moveTo(t) { this.network.moveTo(t); }, releaseNode() { this.network.releaseNode(); }, getOptionsFromConfigurator() { return this.network.getOptionsFromConfigurator(); },
        },
        created() { this.network = null; },
        mounted() { const t = this; const e = this.$refs.visualization; this.visData.nodes = (0, n.mountVisData)(this, 'nodes'), this.visData.edges = (0, n.mountVisData)(this, 'edges'), this.network = new o.Network(e, this.visData, this.options), this.events.forEach(e => t.network.on(e, (i) => t.$emit((0, n.translateEvent)(e), i))); },
        beforeDestroy() { this.network.destroy(); },
      };
    }, function (t, e, i) {
      Object.defineProperty(e, '__esModule', { value: !0 }), e.translateEvent = e.mountVisData = e.arrayDiff = void 0; const o = i(1); const n = function (t, e) { return t.filter(t => e.indexOf(t) === -1); }; const s = function (t, e) { let i = t[e]; if (!(t[e] instanceof o.DataSet || t[e] instanceof o.DataView)) { i = new o.DataSet(t[e]), i.on('*', (i, o, n) => t.$emit(`${e}-${i}`, { event: i, properties: o, senderId: n })); const s = function (i) { if (Array.isArray(i)) { const s = new o.DataSet(i).getIds(); const r = n(t.visData[e].getIds(), s); t.visData[e].update(i), t.visData[e].remove(r); } }; t.$watch(e, s, { deep: !0 }); } return t.$emit(`${e}-mounted`, i), i; }; const r = function (t) { return t.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase(); }; e.arrayDiff = n, e.mountVisData = s, e.translateEvent = r;
    }, function (t, e, i) {
      const o = function () { const t = this; const e = t.$createElement; const i = t._self._c || e; return i('div', { ref: 'visualization' }); }; const n = []; i.d(e, 'a', () => o), i.d(e, 'b', () => n);
    }, function (t, e, i) {
      const o = function () { const t = this; const e = t.$createElement; const i = t._self._c || e; return i('div', { ref: 'visualization' }); }; const n = []; i.d(e, 'a', () => o), i.d(e, 'b', () => n);
    }, function (t, e, i) {
      const o = function () { const t = this; const e = t.$createElement; const i = t._self._c || e; return i('div', { ref: 'visualization' }); }; const n = []; i.d(e, 'a', () => o), i.d(e, 'b', () => n);
    }, function (t, e, i) {
      Object.defineProperty(e, '__esModule', { value: !0 }), e.DataView = e.DataSet = e.Network = e.Graph2d = e.Timeline = void 0; const o = i(1); const n = i(13); const s = l(n); const r = i(14); const a = l(r); const h = i(15); const d = l(h); function l(t) { return t && t.__esModule ? t : { default: t }; }i(16), e.Timeline = s.default, e.Graph2d = a.default, e.Network = d.default, e.DataSet = o.DataSet, e.DataView = o.DataView;
    }, function (t, e, i) {
      i.r(e); const o = i(9); const n = i(2); for (const s in n)s !== 'default' && (function (t) { i.d(e, t, () => n[t]); }(s)); const r = i(0); const a = Object(r.a)(n.default, o.a, o.b, !1, null, null, null); a.options.__file = 'Timeline.vue', e.default = a.exports;
    }, function (t, e, i) {
      i.r(e); const o = i(10); const n = i(4); for (const s in n)s !== 'default' && (function (t) { i.d(e, t, () => n[t]); }(s)); const r = i(0); const a = Object(r.a)(n.default, o.a, o.b, !1, null, null, null); a.options.__file = 'Graph2d.vue', e.default = a.exports;
    }, function (t, e, i) {
      i.r(e); const o = i(11); const n = i(6); for (const s in n)s !== 'default' && (function (t) { i.d(e, t, () => n[t]); }(s)); const r = i(0); const a = Object(r.a)(n.default, o.a, o.b, !1, null, null, null); a.options.__file = 'Network.vue', e.default = a.exports;
    }, function (t, e, i) {}]))));
  },
  '2d11': function (t, e, i) {
    i.r(e); const o = function () { const t = this; const e = t.$createElement; const i = t._self._c || e; return i('network'); }; const n = []; const s = (i('7f7f'), i('cebc')); const r = i('2f62'); const a = function () { const t = this; const e = t.$createElement; const i = t._self._c || e; return i('div', { staticClass: 'container vis-container' }, [i('vis-network', { staticClass: 'recipenet', attrs: { options: t.options, nodes: t.nodes, edges: t.edges } })], 1); }; const h = []; const d = i('0e55'); const l = {
      components: { VisNetwork: d.Network },
      data() {
        return {
          options: {
            autoResize: !0, height: '100%', width: '100vw', physics: !1, layout: { hierarchical: { enabled: !0, levelSeparation: 100, nodeSpacing: 200 } },
          },
        };
      },
      computed: Object(s.a)({}, Object(r.b)(['nodes', 'edges'])),
      watch: {},
    }; const u = l; const c = (i('dfa9'), i('2877')); const p = Object(c.a)(u, a, h, !1, null, null, null); const f = p.exports; const m = i('6e87'); const v = { components: { Network: f }, computed: Object(s.a)({}, Object(r.b)(['selected_recipe'])), mounted() { this.selected_recipe.name ? this.$store.commit(m.a.BUILD_SELECTED_RECIPE) : this.$router.push({ name: 'home' }); } }; const g = v; const y = Object(c.a)(g, o, n, !1, null, null, null); e.default = y.exports;
  },
  '4f27': function (t, e, i) {
    /**
 * vis.js
 * https://github.com/almende/vis
 *
 * A dynamic, browser-based visualization library.
 *
 * @version 4.21.0
 * @date    2017-10-12
 *
 * @license
 * Copyright (C) 2011-2017 Almende B.V, http://almende.com
 *
 * Vis.js is dual licensed under both
 *
 * * The Apache 2.0 License
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * and
 *
 * * The MIT License
 *   http://opensource.org/licenses/MIT
 *
 * Vis.js may be distributed under either license.
 */
    /**
 * vis.js
 * https://github.com/almende/vis
 *
 * A dynamic, browser-based visualization library.
 *
 * @version 4.21.0
 * @date    2017-10-12
 *
 * @license
 * Copyright (C) 2011-2017 Almende B.V, http://almende.com
 *
 * Vis.js is dual licensed under both
 *
 * * The Apache 2.0 License
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * and
 *
 * * The MIT License
 *   http://opensource.org/licenses/MIT
 *
 * Vis.js may be distributed under either license.
 */
    (function (e, i) { t.exports = i(); }(0, () => (function (t) { const e = {}; function i(o) { if (e[o]) return e[o].exports; const n = e[o] = { i: o, l: !1, exports: {} }; return t[o].call(n.exports, n, n.exports, i), n.l = !0, n.exports; } return i.m = t, i.c = e, i.d = function (t, e, o) { i.o(t, e) || Object.defineProperty(t, e, { configurable: !1, enumerable: !0, get: o }); }, i.n = function (t) { const e = t && t.__esModule ? function () { return t.default; } : function () { return t; }; return i.d(e, 'a', e), e; }, i.o = function (t, e) { return Object.prototype.hasOwnProperty.call(t, e); }, i.p = '', i(i.s = 123); }([function (t, e, i) { e.__esModule = !0, e.default = function (t, e) { if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function'); }; }, function (t, e, i) { e.__esModule = !0; const o = i(169); const n = s(o); function s(t) { return t && t.__esModule ? t : { default: t }; }e.default = (function () { function t(t, e) { for (let i = 0; i < e.length; i++) { const o = e[i]; o.enumerable = o.enumerable || !1, o.configurable = !0, 'value' in o && (o.writable = !0), (0, n.default)(t, o.key, o); } } return function (e, i, o) { return i && t(e.prototype, i), o && t(e, o), e; }; }()); }, function (t, e, i) {
      const o = i(77); const n = u(o); const s = i(29); const r = u(s); const a = i(8); const h = u(a); const d = i(6); const l = u(d); function u(t) { return t && t.__esModule ? t : { default: t }; } const c = i(9); const p = i(157); function f(t, e, i, o) { let n = !1; !0 === o && (n = e[i] === null && void 0 !== t[i]), n ? delete t[i] : t[i] = e[i]; }e.isNumber = function (t) { return t instanceof Number || typeof t === 'number'; }, e.recursiveDOMDelete = function (t) { if (t) while (!0 === t.hasChildNodes())e.recursiveDOMDelete(t.firstChild), t.removeChild(t.firstChild); }, e.giveRange = function (t, e, i, o) { if (e == t) return 0.5; const n = 1 / (e - t); return Math.max(0, (o - t) * n); }, e.isString = function (t) { return t instanceof String || typeof t === 'string'; }, e.isDate = function (t) { if (t instanceof Date) return !0; if (e.isString(t)) { const i = m.exec(t); if (i) return !0; if (!isNaN(Date.parse(t))) return !0; } return !1; }, e.randomUUID = function () { return p.v4(); }, e.assignAllKeys = function (t, e) { for (const i in t)t.hasOwnProperty(i) && (0, l.default)(t[i]) !== 'object' && (t[i] = e); }, e.fillIfDefined = function (t, i) { const o = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; for (const n in t) void 0 !== i[n] && (i[n] === null || (0, l.default)(i[n]) !== 'object' ? f(t, i, n, o) : (0, l.default)(t[n]) === 'object' && e.fillIfDefined(t[n], i[n], o)); }, e.extend = function (t, e) { for (let i = 1; i < arguments.length; i++) { const o = arguments[i]; for (const n in o)o.hasOwnProperty(n) && (t[n] = o[n]); } return t; }, e.selectiveExtend = function (t, e, i) { if (!Array.isArray(t)) throw new Error('Array with property names expected as first argument'); for (let o = 2; o < arguments.length; o++) for (let n = arguments[o], s = 0; s < t.length; s++) { const r = t[s]; n && n.hasOwnProperty(r) && (e[r] = n[r]); } return e; }, e.selectiveDeepExtend = function (t, i, o) { const n = arguments.length > 3 && void 0 !== arguments[3] && arguments[3]; if (Array.isArray(o)) throw new TypeError('Arrays are not supported by deepExtend'); for (let s = 0; s < t.length; s++) { const r = t[s]; if (o.hasOwnProperty(r)) if (o[r] && o[r].constructor === Object) void 0 === i[r] && (i[r] = {}), i[r].constructor === Object ? e.deepExtend(i[r], o[r], !1, n) : f(i, o, r, n); else { if (Array.isArray(o[r])) throw new TypeError('Arrays are not supported by deepExtend'); f(i, o, r, n); } } return i; }, e.selectiveNotDeepExtend = function (t, i, o) { const n = arguments.length > 3 && void 0 !== arguments[3] && arguments[3]; if (Array.isArray(o)) throw new TypeError('Arrays are not supported by deepExtend'); for (const s in o) if (o.hasOwnProperty(s) && t.indexOf(s) === -1) if (o[s] && o[s].constructor === Object) void 0 === i[s] && (i[s] = {}), i[s].constructor === Object ? e.deepExtend(i[s], o[s]) : f(i, o, s, n); else if (Array.isArray(o[s])) { i[s] = []; for (let r = 0; r < o[s].length; r++)i[s].push(o[s][r]); } else f(i, o, s, n); return i; }, e.deepExtend = function (t, i) { const o = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; const n = arguments.length > 3 && void 0 !== arguments[3] && arguments[3]; for (const s in i) if (i.hasOwnProperty(s) || !0 === o) if (i[s] && i[s].constructor === Object) void 0 === t[s] && (t[s] = {}), t[s].constructor === Object ? e.deepExtend(t[s], i[s], o) : f(t, i, s, n); else if (Array.isArray(i[s])) { t[s] = []; for (let r = 0; r < i[s].length; r++)t[s].push(i[s][r]); } else f(t, i, s, n); return t; }, e.equalArray = function (t, e) { if (t.length != e.length) return !1; for (let i = 0, o = t.length; i < o; i++) if (t[i] != e[i]) return !1; return !0; }, e.convert = function (t, i) { let o; if (void 0 !== t) { if (t === null) return null; if (!i) return t; if (typeof i !== 'string' && !(i instanceof String)) throw new Error('Type must be a string'); switch (i) { case 'boolean': case 'Boolean': return Boolean(t); case 'number': case 'Number': return e.isString(t) && !isNaN(Date.parse(t)) ? c(t).valueOf() : Number(t.valueOf()); case 'string': case 'String': return String(t); case 'Date': if (e.isNumber(t)) return new Date(t); if (t instanceof Date) return new Date(t.valueOf()); if (c.isMoment(t)) return new Date(t.valueOf()); if (e.isString(t)) return o = m.exec(t), o ? new Date(Number(o[1])) : c(new Date(t)).toDate(); throw new Error(`Cannot convert object of type ${e.getType(t)} to type Date`); case 'Moment': if (e.isNumber(t)) return c(t); if (t instanceof Date) return c(t.valueOf()); if (c.isMoment(t)) return c(t); if (e.isString(t)) return o = m.exec(t), c(o ? Number(o[1]) : t); throw new Error(`Cannot convert object of type ${e.getType(t)} to type Date`); case 'ISODate': if (e.isNumber(t)) return new Date(t); if (t instanceof Date) return t.toISOString(); if (c.isMoment(t)) return t.toDate().toISOString(); if (e.isString(t)) return o = m.exec(t), o ? new Date(Number(o[1])).toISOString() : c(t).format(); throw new Error(`Cannot convert object of type ${e.getType(t)} to type ISODate`); case 'ASPDate': if (e.isNumber(t)) return `/Date(${t})/`; if (t instanceof Date) return `/Date(${t.valueOf()})/`; var n; if (e.isString(t)) return o = m.exec(t), n = o ? new Date(Number(o[1])).valueOf() : new Date(t).valueOf(), `/Date(${n})/`; throw new Error(`Cannot convert object of type ${e.getType(t)} to type ASPDate`); default: throw new Error(`Unknown type "${i}"`); } } }; var m = /^\/?Date\((\-?\d+)/i; e.getType = function (t) { const e = typeof t === 'undefined' ? 'undefined' : (0, l.default)(t); return e == 'object' ? t === null ? 'null' : t instanceof Boolean ? 'Boolean' : t instanceof Number ? 'Number' : t instanceof String ? 'String' : Array.isArray(t) ? 'Array' : t instanceof Date ? 'Date' : 'Object' : e == 'number' ? 'Number' : e == 'boolean' ? 'Boolean' : e == 'string' ? 'String' : void 0 === e ? 'undefined' : e; }, e.copyAndExtendArray = function (t, e) { for (var i = [], o = 0; o < t.length; o++)i.push(t[o]); return i.push(e), i; }, e.copyArray = function (t) { for (var e = [], i = 0; i < t.length; i++)e.push(t[i]); return e; }, e.getAbsoluteLeft = function (t) { return t.getBoundingClientRect().left; }, e.getAbsoluteRight = function (t) { return t.getBoundingClientRect().right; }, e.getAbsoluteTop = function (t) { return t.getBoundingClientRect().top; }, e.addClassName = function (t, e) { let i = t.className.split(' '); const o = e.split(' '); i = i.concat(o.filter(t => i.indexOf(t) < 0)), t.className = i.join(' '); }, e.removeClassName = function (t, e) { let i = t.className.split(' '); const o = e.split(' '); i = i.filter(t => o.indexOf(t) < 0), t.className = i.join(' '); }, e.forEach = function (t, e) { let i; let o; if (Array.isArray(t)) for (i = 0, o = t.length; i < o; i++)e(t[i], i, t); else for (i in t)t.hasOwnProperty(i) && e(t[i], i, t); }, e.toArray = function (t) { const e = []; for (const i in t)t.hasOwnProperty(i) && e.push(t[i]); return e; }, e.updateProperty = function (t, e, i) { return t[e] !== i && (t[e] = i, !0); }, e.throttle = function (t) { let e = !1; return function () { e || (e = !0, requestAnimationFrame(() => { e = !1, t(); })); }; }, e.addEventListener = function (t, e, i, o) { t.addEventListener ? (void 0 === o && (o = !1), e === 'mousewheel' && navigator.userAgent.indexOf('Firefox') >= 0 && (e = 'DOMMouseScroll'), t.addEventListener(e, i, o)) : t.attachEvent(`on${e}`, i); }, e.removeEventListener = function (t, e, i, o) { t.removeEventListener ? (void 0 === o && (o = !1), e === 'mousewheel' && navigator.userAgent.indexOf('Firefox') >= 0 && (e = 'DOMMouseScroll'), t.removeEventListener(e, i, o)) : t.detachEvent(`on${e}`, i); }, e.preventDefault = function (t) { t || (t = window.event), t.preventDefault ? t.preventDefault() : t.returnValue = !1; }, e.getTarget = function (t) { let e; return t || (t = window.event), t.target ? e = t.target : t.srcElement && (e = t.srcElement), void 0 != e.nodeType && e.nodeType == 3 && (e = e.parentNode), e; }, e.hasParent = function (t, e) { let i = t; while (i) { if (i === e) return !0; i = i.parentNode; } return !1; }, e.option = {}, e.option.asBoolean = function (t, e) { return typeof t === 'function' && (t = t()), t != null ? t != 0 : e || null; }, e.option.asNumber = function (t, e) { return typeof t === 'function' && (t = t()), t != null ? Number(t) || e || null : e || null; }, e.option.asString = function (t, e) { return typeof t === 'function' && (t = t()), t != null ? String(t) : e || null; }, e.option.asSize = function (t, i) { return typeof t === 'function' && (t = t()), e.isString(t) ? t : e.isNumber(t) ? `${t}px` : i || null; }, e.option.asElement = function (t, e) { return typeof t === 'function' && (t = t()), t || e || null; }, e.hexToRGB = function (t) { const e = /^#?([a-f\d])([a-f\d])([a-f\d])$/i; t = t.replace(e, (t, e, i, o) => e + e + i + i + o + o); const i = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t); return i ? { r: parseInt(i[1], 16), g: parseInt(i[2], 16), b: parseInt(i[3], 16) } : null; }, e.overrideOpacity = function (t, i) { let o; return t.indexOf('rgba') != -1 ? t : t.indexOf('rgb') != -1 ? (o = t.substr(t.indexOf('(') + 1).replace(')', '').split(','), `rgba(${o[0]},${o[1]},${o[2]},${i})`) : (o = e.hexToRGB(t), o == null ? t : `rgba(${o.r},${o.g},${o.b},${i})`); }, e.RGBToHex = function (t, e, i) { return `#${((1 << 24) + (t << 16) + (e << 8) + i).toString(16).slice(1)}`; }, e.parseColor = function (t) {
        let i; if (!0 === e.isString(t)) {
          if (!0 === e.isValidRGB(t)) { const o = t.substr(4).substr(0, t.length - 5).split(',').map(t => parseInt(t)); t = e.RGBToHex(o[0], o[1], o[2]); } if (!0 === e.isValidHex(t)) {
            const n = e.hexToHSV(t); const s = { h: n.h, s: 0.8 * n.s, v: Math.min(1, 1.02 * n.v) }; const r = { h: n.h, s: Math.min(1, 1.25 * n.s), v: 0.8 * n.v }; const a = e.HSVToHex(r.h, r.s, r.v); const h = e.HSVToHex(s.h, s.s, s.v); i = {
              background: t, border: a, highlight: { background: h, border: a }, hover: { background: h, border: a },
            };
          } else {
            i = {
              background: t, border: t, highlight: { background: t, border: t }, hover: { background: t, border: t },
            };
          }
        } else i = {}, i.background = t.background || void 0, i.border = t.border || void 0, e.isString(t.highlight) ? i.highlight = { border: t.highlight, background: t.highlight } : (i.highlight = {}, i.highlight.background = t.highlight && t.highlight.background || void 0, i.highlight.border = t.highlight && t.highlight.border || void 0), e.isString(t.hover) ? i.hover = { border: t.hover, background: t.hover } : (i.hover = {}, i.hover.background = t.hover && t.hover.background || void 0, i.hover.border = t.hover && t.hover.border || void 0); return i;
      }, e.RGBToHSV = function (t, e, i) { t /= 255, e /= 255, i /= 255; const o = Math.min(t, Math.min(e, i)); const n = Math.max(t, Math.max(e, i)); if (o == n) return { h: 0, s: 0, v: o }; const s = t == o ? e - i : i == o ? t - e : i - t; const r = t == o ? 3 : i == o ? 1 : 5; const a = 60 * (r - s / (n - o)) / 360; const h = (n - o) / n; const d = n; return { h: a, s: h, v: d }; }; const v = { split(t) { const e = {}; return t.split(';').forEach((t) => { if (t.trim() != '') { const i = t.split(':'); const o = i[0].trim(); const n = i[1].trim(); e[o] = n; } }), e; }, join(t) { return (0, h.default)(t).map(e => `${e}: ${t[e]}`).join('; '); } }; e.addCssText = function (t, i) { const o = v.split(t.style.cssText); const n = v.split(i); const s = e.extend(o, n); t.style.cssText = v.join(s); }, e.removeCssText = function (t, e) { const i = v.split(t.style.cssText); const o = v.split(e); for (const n in o)o.hasOwnProperty(n) && delete i[n]; t.style.cssText = v.join(i); }, e.HSVToRGB = function (t, e, i) { let o; let n; let s; const r = Math.floor(6 * t); const a = 6 * t - r; const h = i * (1 - e); const d = i * (1 - a * e); const l = i * (1 - (1 - a) * e); switch (r % 6) { case 0: o = i, n = l, s = h; break; case 1: o = d, n = i, s = h; break; case 2: o = h, n = i, s = l; break; case 3: o = h, n = d, s = i; break; case 4: o = l, n = h, s = i; break; case 5: o = i, n = h, s = d; break; } return { r: Math.floor(255 * o), g: Math.floor(255 * n), b: Math.floor(255 * s) }; }, e.HSVToHex = function (t, i, o) { const n = e.HSVToRGB(t, i, o); return e.RGBToHex(n.r, n.g, n.b); }, e.hexToHSV = function (t) { const i = e.hexToRGB(t); return e.RGBToHSV(i.r, i.g, i.b); }, e.isValidHex = function (t) { const e = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(t); return e; }, e.isValidRGB = function (t) { t = t.replace(' ', ''); const e = /rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/i.test(t); return e; }, e.isValidRGBA = function (t) { t = t.replace(' ', ''); const e = /rgba\((\d{1,3}),(\d{1,3}),(\d{1,3}),(.{1,3})\)/i.test(t); return e; }, e.selectiveBridgeObject = function (t, i) { if (i !== null && (typeof i === 'undefined' ? 'undefined' : (0, l.default)(i)) === 'object') { for (var o = (0, r.default)(i), n = 0; n < t.length; n++)i.hasOwnProperty(t[n]) && (0, l.default)(i[t[n]]) == 'object' && (o[t[n]] = e.bridgeObject(i[t[n]])); return o; } return null; }, e.bridgeObject = function (t) { if (t !== null && (typeof t === 'undefined' ? 'undefined' : (0, l.default)(t)) === 'object') { let i = (0, r.default)(t); if (t instanceof Element)i = t; else for (const o in i = (0, r.default)(t), t)t.hasOwnProperty(o) && (0, l.default)(t[o]) == 'object' && (i[o] = e.bridgeObject(t[o])); return i; } return null; }, e.insertSort = function (t, e) { for (let i = 0; i < t.length; i++) { for (var o = t[i], n = i; n > 0 && e(o, t[n - 1]) < 0; n--)t[n] = t[n - 1]; t[n] = o; } return t; }, e.mergeOptions = function (t, e, i) { const o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}; const n = function (t) { return t !== null && void 0 !== t; }; const s = function (t) { return t !== null && (typeof t === 'undefined' ? 'undefined' : (0, l.default)(t)) === 'object'; }; const a = function (t) { for (const e in t) if (t.hasOwnProperty(e)) return !1; return !0; }; if (!s(t)) throw new Error('Parameter mergeTarget must be an object'); if (!s(e)) throw new Error('Parameter options must be an object'); if (!n(i)) throw new Error('Parameter option must have a value'); if (!s(o)) throw new Error('Parameter globalOptions must be an object'); const h = function (t, e, i) { s(t[i]) || (t[i] = {}); const o = e[i]; const n = t[i]; for (const r in o)o.hasOwnProperty(r) && (n[r] = o[r]); }; const d = e[i]; const u = s(o) && !a(o); const c = u ? o[i] : void 0; const p = c ? c.enabled : void 0; if (void 0 !== d) { if (typeof d === 'boolean') return s(t[i]) || (t[i] = {}), void (t[i].enabled = d); if (d === null && !s(t[i])) { if (!n(c)) return; t[i] = (0, r.default)(c); } if (s(d)) { let f = !0; void 0 !== d.enabled ? f = d.enabled : void 0 !== p && (f = c.enabled), h(t, e, i), t[i].enabled = f; } } }, e.binarySearchCustom = function (t, e, i, o) { const n = 1e4; let s = 0; let r = 0; let a = t.length - 1; while (r <= a && s < n) { const h = Math.floor((r + a) / 2); const d = t[h]; const l = void 0 === o ? d[i] : d[i][o]; const u = e(l); if (u == 0) return h; u == -1 ? r = h + 1 : a = h - 1, s++; } return -1; }, e.binarySearchValue = function (t, e, i, o, n) { let s; let r; let a; let h; const d = 1e4; let l = 0; let u = 0; let c = t.length - 1; n = void 0 != n ? n : function (t, e) { return t == e ? 0 : t < e ? -1 : 1; }; while (u <= c && l < d) { if (h = Math.floor(0.5 * (c + u)), s = t[Math.max(0, h - 1)][i], r = t[h][i], a = t[Math.min(t.length - 1, h + 1)][i], n(r, e) == 0) return h; if (n(s, e) < 0 && n(r, e) > 0) return o == 'before' ? Math.max(0, h - 1) : h; if (n(r, e) < 0 && n(a, e) > 0) return o == 'before' ? h : Math.min(t.length - 1, h + 1); n(r, e) < 0 ? u = h + 1 : c = h - 1, l++; } return -1; }, e.easingFunctions = {
        linear(t) { return t; }, easeInQuad(t) { return t * t; }, easeOutQuad(t) { return t * (2 - t); }, easeInOutQuad(t) { return t < 0.5 ? 2 * t * t : (4 - 2 * t) * t - 1; }, easeInCubic(t) { return t * t * t; }, easeOutCubic(t) { return --t * t * t + 1; }, easeInOutCubic(t) { return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1; }, easeInQuart(t) { return t * t * t * t; }, easeOutQuart(t) { return 1 - --t * t * t * t; }, easeInOutQuart(t) { return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t; }, easeInQuint(t) { return t * t * t * t * t; }, easeOutQuint(t) { return 1 + --t * t * t * t * t; }, easeInOutQuint(t) { return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t; },
      }, e.getScrollBarWidth = function () { const t = document.createElement('p'); t.style.width = '100%', t.style.height = '200px'; const e = document.createElement('div'); e.style.position = 'absolute', e.style.top = '0px', e.style.left = '0px', e.style.visibility = 'hidden', e.style.width = '200px', e.style.height = '150px', e.style.overflow = 'hidden', e.appendChild(t), document.body.appendChild(e); const i = t.offsetWidth; e.style.overflow = 'scroll'; let o = t.offsetWidth; return i == o && (o = e.clientWidth), document.body.removeChild(e), i - o; }, e.topMost = function (t, e) { let i = void 0; Array.isArray(e) || (e = [e]); let o = !0; let s = !1; let r = void 0; try { for (var a, h = (0, n.default)(t); !(o = (a = h.next()).done); o = !0) { const d = a.value; if (d) { i = d[e[0]]; for (let l = 1; l < e.length; l++)i && (i = i[e[l]]); if (typeof i !== 'undefined') break; } } } catch (u) { s = !0, r = u; } finally { try { !o && h.return && h.return(); } finally { if (s) throw r; } } return i; };
    }, function (t, e, i) { t.exports = { default: i(194), __esModule: !0 }; }, function (t, e, i) { e.__esModule = !0; const o = i(6); const n = s(o); function s(t) { return t && t.__esModule ? t : { default: t }; }e.default = function (t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || (typeof e === 'undefined' ? 'undefined' : (0, n.default)(e)) !== 'object' && typeof e !== 'function' ? t : e; }; }, function (t, e, i) {
      e.__esModule = !0; const o = i(196); const n = d(o); const s = i(29); const r = d(s); const a = i(6); const h = d(a); function d(t) { return t && t.__esModule ? t : { default: t }; }e.default = function (t, e) {
        if (typeof e !== 'function' && e !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof e === 'undefined' ? 'undefined' : (0, h.default)(e)}`); t.prototype = (0, r.default)(e && e.prototype, {
          constructor: {
            value: t, enumerable: !1, writable: !0, configurable: !0,
          },
        }), e && (n.default ? (0, n.default)(t, e) : t.__proto__ = e);
      };
    }, function (t, e, i) { e.__esModule = !0; const o = i(142); const n = h(o); const s = i(144); const r = h(s); const a = typeof r.default === 'function' && typeof n.default === 'symbol' ? function (t) { return typeof t; } : function (t) { return t && typeof r.default === 'function' && t.constructor === r.default && t !== r.default.prototype ? 'symbol' : typeof t; }; function h(t) { return t && t.__esModule ? t : { default: t }; }e.default = typeof r.default === 'function' && a(n.default) === 'symbol' ? function (t) { return typeof t === 'undefined' ? 'undefined' : a(t); } : function (t) { return t && typeof r.default === 'function' && t.constructor === r.default && t !== r.default.prototype ? 'symbol' : typeof t === 'undefined' ? 'undefined' : a(t); }; }, function (t, e) { const i = t.exports = { version: '2.5.1' }; typeof __e === 'number' && (__e = i); }, function (t, e, i) { t.exports = { default: i(140), __esModule: !0 }; }, function (t, e, i) { t.exports = typeof window !== 'undefined' && window.moment || i(154); }, function (t, e, i) {
      function o() {
        const t = function () {}; return {
          on: t, off: t, destroy: t, emit: t, get(e) { return { set: t }; },
        };
      } if (typeof window !== 'undefined') { const n = i(175); const s = window.Hammer || i(176); t.exports = n(s, { preventDefault: 'mouse' }); } else t.exports = function () { return o(); };
    }, function (t, e, i) { const o = i(19); const n = d(o); const s = i(6); const r = d(s); const a = i(8); const h = d(a); function d(t) { return t && t.__esModule ? t : { default: t }; } const l = i(2); const u = i(43); function c(t, e) { if (t && !Array.isArray(t) && (e = t, t = null), this._options = e || {}, this._data = {}, this.length = 0, this._fieldId = this._options.fieldId || 'id', this._type = {}, this._options.type) for (let i = (0, h.default)(this._options.type), o = 0, n = i.length; o < n; o++) { const s = i[o]; const r = this._options.type[s]; this._type[s] = r == 'Date' || r == 'ISODate' || r == 'ASPDate' ? 'Date' : r; } this._subscribers = {}, t && this.add(t), this.setOptions(e); }c.prototype.setOptions = function (t) { t && void 0 !== t.queue && (!1 === t.queue ? this._queue && (this._queue.destroy(), delete this._queue) : (this._queue || (this._queue = u.extend(this, { replace: ['add', 'update', 'remove'] })), (0, r.default)(t.queue) === 'object' && this._queue.setOptions(t.queue))); }, c.prototype.on = function (t, e) { let i = this._subscribers[t]; i || (i = [], this._subscribers[t] = i), i.push({ callback: e }); }, c.prototype.off = function (t, e) { const i = this._subscribers[t]; i && (this._subscribers[t] = i.filter(t => t.callback != e)); }, c.prototype._trigger = function (t, e, i) { if (t == '*') throw new Error('Cannot trigger event *'); let o = []; t in this._subscribers && (o = o.concat(this._subscribers[t])), '*' in this._subscribers && (o = o.concat(this._subscribers['*'])); for (let n = 0, s = o.length; n < s; n++) { const r = o[n]; r.callback && r.callback(t, e, i || null); } }, c.prototype.add = function (t, e) { let i; const o = []; const n = this; if (Array.isArray(t)) for (let s = 0, a = t.length; s < a; s++)i = n._addItem(t[s]), o.push(i); else { if (!t || (typeof t === 'undefined' ? 'undefined' : (0, r.default)(t)) !== 'object') throw new Error('Unknown dataType'); i = n._addItem(t), o.push(i); } return o.length && this._trigger('add', { items: o }, e), o; }, c.prototype.update = function (t, e) { const i = []; const o = []; const n = []; const s = []; const a = this; const h = a._fieldId; const d = function (t) { let e = t[h]; if (a._data[e]) { const r = l.extend({}, a._data[e]); e = a._updateItem(t), o.push(e), s.push(t), n.push(r); } else e = a._addItem(t), i.push(e); }; if (Array.isArray(t)) for (let u = 0, c = t.length; u < c; u++)t[u] && (0, r.default)(t[u]) === 'object' ? d(t[u]) : console.warn(`Ignoring input item, which is not an object at index ${u}`); else { if (!t || (typeof t === 'undefined' ? 'undefined' : (0, r.default)(t)) !== 'object') throw new Error('Unknown dataType'); d(t); } if (i.length && this._trigger('add', { items: i }, e), o.length) { const p = { items: o, oldData: n, data: s }; this._trigger('update', p, e); } return i.concat(o); }, c.prototype.get = function (t) { let e; let i; let o; let n; const s = this; const r = l.getType(arguments[0]); if (r == 'String' || r == 'Number' ? (e = arguments[0], o = arguments[1]) : r == 'Array' ? (i = arguments[0], o = arguments[1]) : o = arguments[0], o && o.returnType) { const a = ['Array', 'Object']; n = a.indexOf(o.returnType) == -1 ? 'Array' : o.returnType; } else n = 'Array'; let d; let u; let c; let p; let f; const m = o && o.type || this._options.type; const v = o && o.filter; const g = []; if (void 0 != e)d = s._getItem(e, m), d && v && !v(d) && (d = null); else if (void 0 != i) for (p = 0, f = i.length; p < f; p++)d = s._getItem(i[p], m), v && !v(d) || g.push(d); else for (u = (0, h.default)(this._data), p = 0, f = u.length; p < f; p++)c = u[p], d = s._getItem(c, m), v && !v(d) || g.push(d); if (o && o.order && void 0 == e && this._sort(g, o.order), o && o.fields) { const y = o.fields; if (void 0 != e)d = this._filterFields(d, y); else for (p = 0, f = g.length; p < f; p++)g[p] = this._filterFields(g[p], y); } if (n == 'Object') { let b; const _ = {}; for (p = 0, f = g.length; p < f; p++)b = g[p], _[b.id] = b; return _; } return void 0 != e ? d : g; }, c.prototype.getIds = function (t) { let e; let i; let o; let n; let s; const r = this._data; const a = t && t.filter; const d = t && t.order; const l = t && t.type || this._options.type; const u = (0, h.default)(r); const c = []; if (a) if (d) { for (s = [], e = 0, i = u.length; e < i; e++)o = u[e], n = this._getItem(o, l), a(n) && s.push(n); for (this._sort(s, d), e = 0, i = s.length; e < i; e++)c.push(s[e][this._fieldId]); } else for (e = 0, i = u.length; e < i; e++)o = u[e], n = this._getItem(o, l), a(n) && c.push(n[this._fieldId]); else if (d) { for (s = [], e = 0, i = u.length; e < i; e++)o = u[e], s.push(r[o]); for (this._sort(s, d), e = 0, i = s.length; e < i; e++)c.push(s[e][this._fieldId]); } else for (e = 0, i = u.length; e < i; e++)o = u[e], n = r[o], c.push(n[this._fieldId]); return c; }, c.prototype.getDataSet = function () { return this; }, c.prototype.forEach = function (t, e) { let i; let o; let n; let s; const r = e && e.filter; const a = e && e.type || this._options.type; const d = this._data; const l = (0, h.default)(d); if (e && e.order) { const u = this.get(e); for (i = 0, o = u.length; i < o; i++)n = u[i], s = n[this._fieldId], t(n, s); } else for (i = 0, o = l.length; i < o; i++)s = l[i], n = this._getItem(s, a), r && !r(n) || t(n, s); }, c.prototype.map = function (t, e) { let i; let o; let n; let s; const r = e && e.filter; const a = e && e.type || this._options.type; const d = []; const l = this._data; const u = (0, h.default)(l); for (i = 0, o = u.length; i < o; i++)n = u[i], s = this._getItem(n, a), r && !r(s) || d.push(t(s, n)); return e && e.order && this._sort(d, e.order), d; }, c.prototype._filterFields = function (t, e) { if (!t) return t; let i; let o; const n = {}; const s = (0, h.default)(t); const r = s.length; if (Array.isArray(e)) for (i = 0; i < r; i++)o = s[i], e.indexOf(o) != -1 && (n[o] = t[o]); else for (i = 0; i < r; i++)o = s[i], e.hasOwnProperty(o) && (n[e[o]] = t[o]); return n; }, c.prototype._sort = function (t, e) { if (l.isString(e)) { const i = e; t.sort((t, e) => { const o = t[i]; const n = e[i]; return o > n ? 1 : o < n ? -1 : 0; }); } else { if (typeof e !== 'function') throw new TypeError('Order must be a function or a string'); t.sort(e); } }, c.prototype.remove = function (t, e) { let i; let o; let n; let s; const r = []; const a = []; let h = []; for (h = Array.isArray(t) ? t : [t], i = 0, o = h.length; i < o; i++)s = this._remove(h[i]), s && (n = s[this._fieldId], void 0 != n && (r.push(n), a.push(s))); return r.length && this._trigger('remove', { items: r, oldData: a }, e), r; }, c.prototype._remove = function (t) { let e; let i; return l.isNumber(t) || l.isString(t) ? i = t : t && (typeof t === 'undefined' ? 'undefined' : (0, r.default)(t)) === 'object' && (i = t[this._fieldId]), void 0 !== i && this._data[i] ? (e = this._data[i], delete this._data[i], this.length--, e) : null; }, c.prototype.clear = function (t) { let e; let i; const o = (0, h.default)(this._data); const n = []; for (e = 0, i = o.length; e < i; e++)n.push(this._data[o[e]]); return this._data = {}, this.length = 0, this._trigger('remove', { items: o, oldData: n }, t), o; }, c.prototype.max = function (t) { let e; let i; const o = this._data; const n = (0, h.default)(o); let s = null; let r = null; for (e = 0, i = n.length; e < i; e++) { const a = n[e]; const d = o[a]; const l = d[t]; l != null && (!s || l > r) && (s = d, r = l); } return s; }, c.prototype.min = function (t) { let e; let i; const o = this._data; const n = (0, h.default)(o); let s = null; let r = null; for (e = 0, i = n.length; e < i; e++) { const a = n[e]; const d = o[a]; const l = d[t]; l != null && (!s || l < r) && (s = d, r = l); } return s; }, c.prototype.distinct = function (t) { let e; let i; let o; const n = this._data; const s = (0, h.default)(n); const r = []; const a = this._options.type && this._options.type[t] || null; let d = 0; for (e = 0, o = s.length; e < o; e++) { const u = s[e]; const c = n[u]; const p = c[t]; let f = !1; for (i = 0; i < d; i++) if (r[i] == p) { f = !0; break; }f || void 0 === p || (r[d] = p, d++); } if (a) for (e = 0, o = r.length; e < o; e++)r[e] = l.convert(r[e], a); return r; }, c.prototype._addItem = function (t) { let e = t[this._fieldId]; if (void 0 != e) { if (this._data[e]) throw new Error(`Cannot add item: item with id ${e} already exists`); } else e = l.randomUUID(), t[this._fieldId] = e; let i; let o; const n = {}; const s = (0, h.default)(t); for (i = 0, o = s.length; i < o; i++) { const r = s[i]; const a = this._type[r]; n[r] = l.convert(t[r], a); } return this._data[e] = n, this.length++, e; }, c.prototype._getItem = function (t, e) { let i; let o; let n; let s; const r = this._data[t]; if (!r) return null; const a = {}; const d = (0, h.default)(r); if (e) for (n = 0, s = d.length; n < s; n++)i = d[n], o = r[i], a[i] = l.convert(o, e[i]); else for (n = 0, s = d.length; n < s; n++)i = d[n], o = r[i], a[i] = o; return a[this._fieldId] || (a[this._fieldId] = r.id), a; }, c.prototype._updateItem = function (t) { const e = t[this._fieldId]; if (void 0 == e) throw new Error(`Cannot update item: item has no id (item: ${(0, n.default)(t)})`); const i = this._data[e]; if (!i) throw new Error(`Cannot update item: no item with id ${e} found`); for (let o = (0, h.default)(t), s = 0, r = o.length; s < r; s++) { const a = o[s]; const d = this._type[a]; i[a] = l.convert(t[a], d); } return e; }, t.exports = c; }, function (t, e, i) { const o = i(8); const n = s(o); function s(t) { return t && t.__esModule ? t : { default: t }; } const r = i(2); const a = i(11); function h(t, e) { this._data = null, this._ids = {}, this.length = 0, this._options = e || {}, this._fieldId = 'id', this._subscribers = {}; const i = this; this.listener = function () { i._onEvent(...arguments); }, this.setData(t); }h.prototype.setData = function (t) { let e; let i; let o; let n; let s; if (this._data) { for (this._data.off && this._data.off('*', this.listener), e = this._data.getIds({ filter: this._options && this._options.filter }), s = [], o = 0, n = e.length; o < n; o++)s.push(this._data._data[e[o]]); this._ids = {}, this.length = 0, this._trigger('remove', { items: e, oldData: s }); } if (this._data = t, this._data) { for (this._fieldId = this._options.fieldId || this._data && this._data.options && this._data.options.fieldId || 'id', e = this._data.getIds({ filter: this._options && this._options.filter }), o = 0, n = e.length; o < n; o++)i = e[o], this._ids[i] = !0; this.length = e.length, this._trigger('add', { items: e }), this._data.on && this._data.on('*', this.listener); } }, h.prototype.refresh = function () { let t; let e; let i; const o = this._data.getIds({ filter: this._options && this._options.filter }); const s = (0, n.default)(this._ids); const r = {}; const a = []; const h = []; const d = []; for (e = 0, i = o.length; e < i; e++)t = o[e], r[t] = !0, this._ids[t] || (a.push(t), this._ids[t] = !0); for (e = 0, i = s.length; e < i; e++)t = s[e], r[t] || (h.push(t), d.push(this._data._data[t]), delete this._ids[t]); this.length += a.length - h.length, a.length && this._trigger('add', { items: a }), h.length && this._trigger('remove', { items: h, oldData: d }); }, h.prototype.get = function (t) { let e; let i; let o; const n = this; const s = r.getType(arguments[0]); s == 'String' || s == 'Number' || s == 'Array' ? (e = arguments[0], i = arguments[1], o = arguments[2]) : (i = arguments[0], o = arguments[1]); const a = r.extend({}, this._options, i); this._options.filter && i && i.filter && (a.filter = function (t) { return n._options.filter(t) && i.filter(t); }); const h = []; return void 0 != e && h.push(e), h.push(a), h.push(o), this._data && this._data.get.apply(this._data, h); }, h.prototype.getIds = function (t) { let e; if (this._data) { let i; const o = this._options.filter; i = t && t.filter ? o ? function (e) { return o(e) && t.filter(e); } : t.filter : o, e = this._data.getIds({ filter: i, order: t && t.order }); } else e = []; return e; }, h.prototype.map = function (t, e) { let i = []; if (this._data) { let o; const n = this._options.filter; o = e && e.filter ? n ? function (t) { return n(t) && e.filter(t); } : e.filter : n, i = this._data.map(t, { filter: o, order: e && e.order }); } else i = []; return i; }, h.prototype.getDataSet = function () { let t = this; while (t instanceof h)t = t._data; return t || null; }, h.prototype._onEvent = function (t, e, i) { let o; let n; let s; let r; const a = e && e.items; const h = []; const d = []; const l = []; const u = []; const c = []; const p = []; if (a && this._data) { switch (t) { case 'add': for (o = 0, n = a.length; o < n; o++)s = a[o], r = this.get(s), r && (this._ids[s] = !0, h.push(s)); break; case 'update': for (o = 0, n = a.length; o < n; o++)s = a[o], r = this.get(s), r ? this._ids[s] ? (d.push(s), c.push(e.data[o]), u.push(e.oldData[o])) : (this._ids[s] = !0, h.push(s)) : this._ids[s] && (delete this._ids[s], l.push(s), p.push(e.oldData[o])); break; case 'remove': for (o = 0, n = a.length; o < n; o++)s = a[o], this._ids[s] && (delete this._ids[s], l.push(s), p.push(e.oldData[o])); break; } this.length += h.length - l.length, h.length && this._trigger('add', { items: h }, i), d.length && this._trigger('update', { items: d, oldData: u, data: c }, i), l.length && this._trigger('remove', { items: l, oldData: p }, i); } }, h.prototype.on = a.prototype.on, h.prototype.off = a.prototype.off, h.prototype._trigger = a.prototype._trigger, h.prototype.subscribe = h.prototype.on, h.prototype.unsubscribe = h.prototype.off, t.exports = h; }, function (t, e, i) { const o = i(57)('wks'); const n = i(40); const s = i(18).Symbol; const r = typeof s === 'function'; const a = t.exports = function (t) { return o[t] || (o[t] = r && s[t] || (r ? s : n)(`Symbol.${t}`)); }; a.store = o; }, function (t, e, i) { e.prepareElements = function (t) { for (const e in t)t.hasOwnProperty(e) && (t[e].redundant = t[e].used, t[e].used = []); }, e.cleanupElements = function (t) { for (const e in t) if (t.hasOwnProperty(e) && t[e].redundant) { for (let i = 0; i < t[e].redundant.length; i++)t[e].redundant[i].parentNode.removeChild(t[e].redundant[i]); t[e].redundant = []; } }, e.resetElements = function (t) { e.prepareElements(t), e.cleanupElements(t), e.prepareElements(t); }, e.getSVGElement = function (t, e, i) { let o; return e.hasOwnProperty(t) ? e[t].redundant.length > 0 ? (o = e[t].redundant[0], e[t].redundant.shift()) : (o = document.createElementNS('http://www.w3.org/2000/svg', t), i.appendChild(o)) : (o = document.createElementNS('http://www.w3.org/2000/svg', t), e[t] = { used: [], redundant: [] }, i.appendChild(o)), e[t].used.push(o), o; }, e.getDOMElement = function (t, e, i, o) { let n; return e.hasOwnProperty(t) ? e[t].redundant.length > 0 ? (n = e[t].redundant[0], e[t].redundant.shift()) : (n = document.createElement(t), void 0 !== o ? i.insertBefore(n, o) : i.appendChild(n)) : (n = document.createElement(t), e[t] = { used: [], redundant: [] }, void 0 !== o ? i.insertBefore(n, o) : i.appendChild(n)), e[t].used.push(n), n; }, e.drawPoint = function (t, i, o, n, s, r) { let a; if (o.style == 'circle' ? (a = e.getSVGElement('circle', n, s), a.setAttributeNS(null, 'cx', t), a.setAttributeNS(null, 'cy', i), a.setAttributeNS(null, 'r', 0.5 * o.size)) : (a = e.getSVGElement('rect', n, s), a.setAttributeNS(null, 'x', t - 0.5 * o.size), a.setAttributeNS(null, 'y', i - 0.5 * o.size), a.setAttributeNS(null, 'width', o.size), a.setAttributeNS(null, 'height', o.size)), void 0 !== o.styles && a.setAttributeNS(null, 'style', o.styles), a.setAttributeNS(null, 'class', `${o.className} vis-point`), r) { const h = e.getSVGElement('text', n, s); r.xOffset && (t += r.xOffset), r.yOffset && (i += r.yOffset), r.content && (h.textContent = r.content), r.className && h.setAttributeNS(null, 'class', `${r.className} vis-label`), h.setAttributeNS(null, 'x', t), h.setAttributeNS(null, 'y', i); } return a; }, e.drawBar = function (t, i, o, n, s, r, a, h) { if (n != 0) { n < 0 && (n *= -1, i -= n); const d = e.getSVGElement('rect', r, a); d.setAttributeNS(null, 'x', t - 0.5 * o), d.setAttributeNS(null, 'y', i), d.setAttributeNS(null, 'width', o), d.setAttributeNS(null, 'height', n), d.setAttributeNS(null, 'class', s), h && d.setAttributeNS(null, 'style', h); } }; }, function (t, e, i) {
      Object.defineProperty(e, '__esModule', { value: !0 }), e.printStyle = void 0; const o = i(19); const n = p(o); const s = i(6); const r = p(s); const a = i(8); const h = p(a); const d = i(0); const l = p(d); const u = i(1); const c = p(u); function p(t) { return t && t.__esModule ? t : { default: t }; } const f = i(2); let m = !1; let v = void 0; const g = 'background: #FFeeee; color: #dd0000'; const y = (function () {
        function t() { (0, l.default)(this, t); } return (0, c.default)(t, null, [{ key: 'validate', value(e, i, o) { m = !1, v = i; let n = i; return void 0 !== o && (n = i[o]), t.parse(e, n, []), m; } }, { key: 'parse', value(e, i, o) { for (const n in e)e.hasOwnProperty(n) && t.check(n, e, i, o); } }, { key: 'check', value(e, i, o, n) { if (void 0 !== o[e] || void 0 !== o.__any__) { let s = e; let r = !0; void 0 === o[e] && void 0 !== o.__any__ && (s = '__any__', r = t.getType(i[e]) === 'object'); let a = o[s]; r && void 0 !== a.__type__ && (a = a.__type__), t.checkFields(e, i, o, s, a, n); } else t.getSuggestion(e, o, n); } }, { key: 'checkFields', value(e, i, o, n, s, r) { const a = function (i) { console.log(`%c${i}${t.printLocation(r, e)}`, g); }; const d = t.getType(i[e]); const l = s[d]; void 0 !== l ? t.getType(l) === 'array' && l.indexOf(i[e]) === -1 ? (a(`Invalid option detected in "${e}". Allowed values are:${t.print(l)} not "${i[e]}". `), m = !0) : d === 'object' && n !== '__any__' && (r = f.copyAndExtendArray(r, e), t.parse(i[e], o[n], r)) : void 0 === s.any && (a(`Invalid type received for "${e}". Expected: ${t.print((0, h.default)(s))}. Received [${d}] "${i[e]}"`), m = !0); } }, { key: 'getType', value(t) { const e = typeof t === 'undefined' ? 'undefined' : (0, r.default)(t); return e === 'object' ? t === null ? 'null' : t instanceof Boolean ? 'boolean' : t instanceof Number ? 'number' : t instanceof String ? 'string' : Array.isArray(t) ? 'array' : t instanceof Date ? 'date' : void 0 !== t.nodeType ? 'dom' : !0 === t._isAMomentObject ? 'moment' : 'object' : e === 'number' ? 'number' : e === 'boolean' ? 'boolean' : e === 'string' ? 'string' : void 0 === e ? 'undefined' : e; } }, { key: 'getSuggestion', value(e, i, o) { const n = t.findInOptions(e, i, o, !1); const s = t.findInOptions(e, v, [], !0); const r = 8; const a = 4; let d = void 0; d = void 0 !== n.indexMatch ? ` in ${t.printLocation(n.path, e, '') }Perhaps it was incomplete? Did you mean: "${n.indexMatch }"?\n\n` : s.distance <= a && n.distance > s.distance ? ` in ${t.printLocation(n.path, e, '') }Perhaps it was misplaced? Matching option found at: ${t.printLocation(s.path, s.closestMatch, '')}` : n.distance <= r ? `. Did you mean "${n.closestMatch}"?${t.printLocation(n.path, e)}` : `. Did you mean one of these: ${t.print((0, h.default)(i))}${t.printLocation(o, e)}`, console.log(`%cUnknown option detected: "${e}"${d}`, g), m = !0; } }, {
          key: 'findInOptions',
          value(e, i, o) {
            const n = arguments.length > 3 && void 0 !== arguments[3] && arguments[3]; let s = 1e9; let r = ''; let a = []; const h = e.toLowerCase(); let d = void 0; for (const l in i) { let u = void 0; if (void 0 !== i[l].__type__ && !0 === n) { const c = t.findInOptions(e, i[l], f.copyAndExtendArray(o, l)); s > c.distance && (r = c.closestMatch, a = c.path, s = c.distance, d = c.indexMatch); } else l.toLowerCase().indexOf(h) !== -1 && (d = l), u = t.levenshteinDistance(e, l), s > u && (r = l, a = f.copyArray(o), s = u); } return {
              closestMatch: r, path: a, distance: s, indexMatch: d,
            };
          }, 
        }, { key: 'printLocation', value(t, e) { for (var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 'Problem value found at: \n', o = `\n\n${i }options = {\n`, n = 0; n < t.length; n++) { for (let s = 0; s < n + 1; s++)o += '  '; o += `${t[n]}: {\n`; } for (let r = 0; r < t.length + 1; r++)o += '  '; o += `${e}\n`; for (let a = 0; a < t.length + 1; a++) { for (let h = 0; h < t.length - a; h++)o += '  '; o += '}\n'; } return `${o}\n\n`; } }, { key: 'print', value(t) { return (0, n.default)(t).replace(/(\")|(\[)|(\])|(,"__type__")/g, '').replace(/(\,)/g, ', '); } }, { key: 'levenshteinDistance', value(t, e) { if (t.length === 0) return e.length; if (e.length === 0) return t.length; let i; let o; const n = []; for (i = 0; i <= e.length; i++)n[i] = [i]; for (o = 0; o <= t.length; o++)n[0][o] = o; for (i = 1; i <= e.length; i++) for (o = 1; o <= t.length; o++)e.charAt(i - 1) == t.charAt(o - 1) ? n[i][o] = n[i - 1][o - 1] : n[i][o] = Math.min(n[i - 1][o - 1] + 1, Math.min(n[i][o - 1] + 1, n[i - 1][o] + 1)); return n[e.length][t.length]; } }]), t;
      }()); e.default = y, e.printStyle = g;
    }, function (t, e, i) { const o = i(2); function n(t, e) { this.options = null, this.props = null; }n.prototype.setOptions = function (t) { t && o.extend(this.options, t); }, n.prototype.redraw = function () { return !1; }, n.prototype.destroy = function () {}, n.prototype._isResized = function () { const t = this.props._previousWidth !== this.props.width || this.props._previousHeight !== this.props.height; return this.props._previousWidth = this.props.width, this.props._previousHeight = this.props.height, t; }, t.exports = n; }, function (t, e, i) { const o = i(18); const n = i(7); const s = i(80); const r = i(26); const a = 'prototype'; var h = function (t, e, i) { let d; let l; let u; const c = t & h.F; const p = t & h.G; const f = t & h.S; const m = t & h.P; const v = t & h.B; const g = t & h.W; const y = p ? n : n[e] || (n[e] = {}); const b = y[a]; const _ = p ? o : f ? o[e] : (o[e] || {})[a]; for (d in p && (i = e), i)l = !c && _ && void 0 !== _[d], l && d in y || (u = l ? _[d] : i[d], y[d] = p && typeof _[d] !== 'function' ? i[d] : v && l ? s(u, o) : g && _[d] == u ? (function (t) { const e = function (e, i, o) { if (this instanceof t) { switch (arguments.length) { case 0: return new t(); case 1: return new t(e); case 2: return new t(e, i); } return new t(e, i, o); } return t.apply(this, arguments); }; return e[a] = t[a], e; }(u)) : m && typeof u === 'function' ? s(Function.call, u) : u, m && ((y.virtual || (y.virtual = {}))[d] = u, t & h.R && b && !b[d] && r(b, d, u))); }; h.F = 1, h.G = 2, h.S = 4, h.P = 8, h.B = 16, h.W = 32, h.U = 64, h.R = 128, t.exports = h; }, function (t, e) { const i = t.exports = typeof window !== 'undefined' && window.Math == Math ? window : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(); typeof __g === 'number' && (__g = i); }, function (t, e, i) { t.exports = { default: i(160), __esModule: !0 }; }, function (t, e, i) { const o = i(27); const n = i(81); const s = i(53); const r = Object.defineProperty; e.f = i(21) ? Object.defineProperty : function (t, e, i) { if (o(t), e = s(e, !0), o(i), n) try { return r(t, e, i); } catch (a) {} if ('get' in i || 'set' in i) throw TypeError('Accessors not supported!'); return 'value' in i && (t[e] = i.value), t; }; }, function (t, e, i) { t.exports = !i(28)(() => Object.defineProperty({}, 'a', { get() { return 7; } }).a != 7); }, function (t, e) { const i = {}.hasOwnProperty; t.exports = function (t, e) { return i.call(t, e); }; }, function (t, e, i) {
      Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(6); const n = d(o); const s = i(0); const r = d(s); const a = i(1); const h = d(a); function d(t) { return t && t.__esModule ? t : { default: t }; } const l = (function () {
        function t(e, i, o) {
          (0, r.default)(this, t), this.body = i, this.labelModule = o, this.setOptions(e), this.top = void 0, this.left = void 0, this.height = void 0, this.width = void 0, this.radius = void 0, this.margin = void 0, this.refreshNeeded = !0, this.boundingBox = {
            top: 0, left: 0, right: 0, bottom: 0,
          };
        } return (0, h.default)(t, [{ key: 'setOptions', value(t) { this.options = t; } }, { key: '_setMargins', value(t) { this.margin = {}, this.options.margin && ((0, n.default)(this.options.margin) == 'object' ? (this.margin.top = this.options.margin.top, this.margin.right = this.options.margin.right, this.margin.bottom = this.options.margin.bottom, this.margin.left = this.options.margin.left) : (this.margin.top = this.options.margin, this.margin.right = this.options.margin, this.margin.bottom = this.options.margin, this.margin.left = this.options.margin)), t.adjustSizes(this.margin); } }, { key: '_distanceToBorder', value(t, e) { const i = this.options.borderWidth; return this.resize(t), Math.min(Math.abs(this.width / 2 / Math.cos(e)), Math.abs(this.height / 2 / Math.sin(e))) + i; } }, { key: 'enableShadow', value(t, e) { e.shadow && (t.shadowColor = e.shadowColor, t.shadowBlur = e.shadowSize, t.shadowOffsetX = e.shadowX, t.shadowOffsetY = e.shadowY); } }, { key: 'disableShadow', value(t, e) { e.shadow && (t.shadowColor = 'rgba(0,0,0,0)', t.shadowBlur = 0, t.shadowOffsetX = 0, t.shadowOffsetY = 0); } }, { key: 'enableBorderDashes', value(t, e) { if (!1 !== e.borderDashes) if (void 0 !== t.setLineDash) { let i = e.borderDashes; !0 === i && (i = [5, 15]), t.setLineDash(i); } else console.warn('setLineDash is not supported in this browser. The dashed borders cannot be used.'), this.options.shapeProperties.borderDashes = !1, e.borderDashes = !1; } }, { key: 'disableBorderDashes', value(t, e) { !1 !== e.borderDashes && (void 0 !== t.setLineDash ? t.setLineDash([0]) : (console.warn('setLineDash is not supported in this browser. The dashed borders cannot be used.'), this.options.shapeProperties.borderDashes = !1, e.borderDashes = !1)); } }, { key: 'needsRefresh', value(t, e) { return !0 === this.refreshNeeded ? (this.refreshNeeded = !1, !0) : void 0 === this.width || this.labelModule.differentState(t, e); } }, { key: 'initContextForDraw', value(t, e) { const i = e.borderWidth / this.body.view.scale; t.lineWidth = Math.min(this.width, i), t.strokeStyle = e.borderColor, t.fillStyle = e.color; } }, { key: 'performStroke', value(t, e) { const i = e.borderWidth / this.body.view.scale; t.save(), i > 0 && (this.enableBorderDashes(t, e), t.stroke(), this.disableBorderDashes(t, e)), t.restore(); } }, { key: 'performFill', value(t, e) { this.enableShadow(t, e), t.fill(), this.disableShadow(t, e), this.performStroke(t, e); } }, { key: '_addBoundingBoxMargin', value(t) { this.boundingBox.left -= t, this.boundingBox.top -= t, this.boundingBox.bottom += t, this.boundingBox.right += t; } }, { key: '_updateBoundingBox', value(t, e, i, o, n) { void 0 !== i && this.resize(i, o, n), this.left = t - this.width / 2, this.top = e - this.height / 2, this.boundingBox.left = this.left, this.boundingBox.top = this.top, this.boundingBox.bottom = this.top + this.height, this.boundingBox.right = this.left + this.width; } }, { key: 'updateBoundingBox', value(t, e, i, o, n) { this._updateBoundingBox(t, e, i, o, n); } }, { key: 'getDimensionsFromLabel', value(t, e, i) { this.textSize = this.labelModule.getTextSize(t, e, i); let o = this.textSize.width; let n = this.textSize.height; const s = 14; return o === 0 && (o = s, n = s), { width: o, height: n }; } }]), t;
      }()); e.default = l;
    }, function (t, e, i) { Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(3); const n = m(o); const s = i(0); const r = m(s); const a = i(1); const h = m(a); const d = i(4); const l = m(d); const u = i(5); const c = m(u); const p = i(23); const f = m(p); function m(t) { return t && t.__esModule ? t : { default: t }; } const v = (function (t) { function e(t, i, o) { return (0, r.default)(this, e), (0, l.default)(this, (e.__proto__ || (0, n.default)(e)).call(this, t, i, o)); } return (0, c.default)(e, t), (0, h.default)(e, [{ key: 'resize', value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.selected; const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.hover; const o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : { size: this.options.size }; if (this.needsRefresh(e, i)) { this.labelModule.getTextSize(t, e, i); const n = 2 * o.size; this.width = n, this.height = n, this.radius = 0.5 * this.width; } } }, { key: '_drawShape', value(t, e, i, o, n, s, r, a) { if (this.resize(t, s, r, a), this.left = o - this.width / 2, this.top = n - this.height / 2, this.initContextForDraw(t, a), t[e](o, n, a.size), this.performFill(t, a), void 0 !== this.options.label) { this.labelModule.calculateLabelSize(t, s, r, o, n, 'hanging'); const h = n + 0.5 * this.height + 0.5 * this.labelModule.size.height; this.labelModule.draw(t, o, h, s, r, 'hanging'); } this.updateBoundingBox(o, n); } }, { key: 'updateBoundingBox', value(t, e) { this.boundingBox.top = e - this.options.size, this.boundingBox.left = t - this.options.size, this.boundingBox.right = t + this.options.size, this.boundingBox.bottom = e + this.options.size, void 0 !== this.options.label && this.labelModule.size.width > 0 && (this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left), this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width), this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelModule.size.height)); } }]), e; }(f.default)); e.default = v; }, function (t, e, i) { const o = i(78); const n = i(51); t.exports = function (t) { return o(n(t)); }; }, function (t, e, i) { const o = i(20); const n = i(39); t.exports = i(21) ? function (t, e, i) { return o.f(t, e, n(1, i)); } : function (t, e, i) { return t[e] = i, t; }; }, function (t, e, i) { const o = i(32); t.exports = function (t) { if (!o(t)) throw TypeError(`${t} is not an object!`); return t; }; }, function (t, e) { t.exports = function (t) { try { return !!t(); } catch (e) { return !0; } }; }, function (t, e, i) { t.exports = { default: i(138), __esModule: !0 }; }, function (t, e, i) { e.__esModule = !0; const o = i(188); const n = a(o); const s = i(77); const r = a(s); function a(t) { return t && t.__esModule ? t : { default: t }; }e.default = (function () { function t(t, e) { const i = []; let o = !0; let n = !1; let s = void 0; try { for (var a, h = (0, r.default)(t); !(o = (a = h.next()).done); o = !0) if (i.push(a.value), e && i.length === e) break; } catch (d) { n = !0, s = d; } finally { try { !o && h.return && h.return(); } finally { if (n) throw s; } } return i; } return function (e, i) { if (Array.isArray(e)) return e; if ((0, n.default)(Object(e))) return t(e, i); throw new TypeError('Invalid attempt to destructure non-iterable instance'); }; }()); }, function (t, e) { t.exports = {}; }, function (t, e) { t.exports = function (t) { return typeof t === 'object' ? t !== null : typeof t === 'function'; }; }, function (t, e, i) { const o = i(84); const n = i(58); t.exports = Object.keys || function (t) { return o(t, n); }; }, function (t, e, i) { function o(t, e, i) { this.x = void 0 !== t ? t : 0, this.y = void 0 !== e ? e : 0, this.z = void 0 !== i ? i : 0; }o.subtract = function (t, e) { const i = new o(); return i.x = t.x - e.x, i.y = t.y - e.y, i.z = t.z - e.z, i; }, o.add = function (t, e) { const i = new o(); return i.x = t.x + e.x, i.y = t.y + e.y, i.z = t.z + e.z, i; }, o.avg = function (t, e) { return new o((t.x + e.x) / 2, (t.y + e.y) / 2, (t.z + e.z) / 2); }, o.crossProduct = function (t, e) { const i = new o(); return i.x = t.y * e.z - t.z * e.y, i.y = t.z * e.x - t.x * e.z, i.z = t.x * e.y - t.y * e.x, i; }, o.prototype.length = function () { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z); }, t.exports = o; }, function (t, e, i) { let o; let n; let s; (function (i, r) { n = [], o = r, s = typeof o === 'function' ? o.apply(e, n) : o, void 0 === s || (t.exports = s); }(0, () => { function t(t) { let e; const i = t && t.preventDefault || !1; const o = t && t.container || window; const n = {}; let s = { keydown: {}, keyup: {} }; const r = {}; for (e = 97; e <= 122; e++)r[String.fromCharCode(e)] = { code: e - 97 + 65, shift: !1 }; for (e = 65; e <= 90; e++)r[String.fromCharCode(e)] = { code: e, shift: !0 }; for (e = 0; e <= 9; e++)r[`${e}`] = { code: 48 + e, shift: !1 }; for (e = 1; e <= 12; e++)r[`F${e}`] = { code: 111 + e, shift: !1 }; for (e = 0; e <= 9; e++)r[`num${e}`] = { code: 96 + e, shift: !1 }; r['num*'] = { code: 106, shift: !1 }, r['num+'] = { code: 107, shift: !1 }, r['num-'] = { code: 109, shift: !1 }, r['num/'] = { code: 111, shift: !1 }, r['num.'] = { code: 110, shift: !1 }, r.left = { code: 37, shift: !1 }, r.up = { code: 38, shift: !1 }, r.right = { code: 39, shift: !1 }, r.down = { code: 40, shift: !1 }, r.space = { code: 32, shift: !1 }, r.enter = { code: 13, shift: !1 }, r.shift = { code: 16, shift: void 0 }, r.esc = { code: 27, shift: !1 }, r.backspace = { code: 8, shift: !1 }, r.tab = { code: 9, shift: !1 }, r.ctrl = { code: 17, shift: !1 }, r.alt = { code: 18, shift: !1 }, r.delete = { code: 46, shift: !1 }, r.pageup = { code: 33, shift: !1 }, r.pagedown = { code: 34, shift: !1 }, r['='] = { code: 187, shift: !1 }, r['-'] = { code: 189, shift: !1 }, r[']'] = { code: 221, shift: !1 }, r['['] = { code: 219, shift: !1 }; const a = function (t) { d(t, 'keydown'); }; const h = function (t) { d(t, 'keyup'); }; var d = function (t, e) { if (void 0 !== s[e][t.keyCode]) { for (let o = s[e][t.keyCode], n = 0; n < o.length; n++) void 0 === o[n].shift ? o[n].fn(t) : o[n].shift == 1 && t.shiftKey == 1 ? o[n].fn(t) : o[n].shift == 0 && t.shiftKey == 0 && o[n].fn(t); i == 1 && t.preventDefault(); } }; return n.bind = function (t, e, i) { if (void 0 === i && (i = 'keydown'), void 0 === r[t]) throw new Error(`unsupported key: ${t}`); void 0 === s[i][r[t].code] && (s[i][r[t].code] = []), s[i][r[t].code].push({ fn: e, shift: r[t].shift }); }, n.bindAll = function (t, e) { for (const i in void 0 === e && (e = 'keydown'), r)r.hasOwnProperty(i) && n.bind(i, t, e); }, n.getKey = function (t) { for (const e in r) if (r.hasOwnProperty(e)) { if (t.shiftKey == 1 && r[e].shift == 1 && t.keyCode == r[e].code) return e; if (t.shiftKey == 0 && r[e].shift == 0 && t.keyCode == r[e].code) return e; if (t.keyCode == r[e].code && e == 'shift') return e; } return 'unknown key, currently not supported'; }, n.unbind = function (t, e, i) { if (void 0 === i && (i = 'keydown'), void 0 === r[t]) throw new Error(`unsupported key: ${t}`); if (void 0 !== e) { const o = []; const n = s[i][r[t].code]; if (void 0 !== n) for (let a = 0; a < n.length; a++)n[a].fn == e && n[a].shift == r[t].shift || o.push(s[i][r[t].code][a]); s[i][r[t].code] = o; } else s[i][r[t].code] = []; }, n.reset = function () { s = { keydown: {}, keyup: {} }; }, n.destroy = function () { s = { keydown: {}, keyup: {} }, o.removeEventListener('keydown', a, !0), o.removeEventListener('keyup', h, !0); }, o.addEventListener('keydown', a, !0), o.addEventListener('keyup', h, !0), n; } return t; })); }, function (t, e, i) { e.convertHiddenOptions = function (t, i, o) { if (o && !Array.isArray(o)) return e.convertHiddenOptions(t, i, [o]); if (i.hiddenDates = [], o && Array.isArray(o) == 1) { for (let n = 0; n < o.length; n++) if (void 0 === o[n].repeat) { const s = {}; s.start = t(o[n].start).toDate().valueOf(), s.end = t(o[n].end).toDate().valueOf(), i.hiddenDates.push(s); }i.hiddenDates.sort((t, e) => t.start - e.start); } }, e.updateHiddenDates = function (t, i, o) { if (o && !Array.isArray(o)) return e.updateHiddenDates(t, i, [o]); if (o && void 0 !== i.domProps.centerContainer.width) { e.convertHiddenOptions(t, i, o); for (let n = t(i.range.start), s = t(i.range.end), r = i.range.end - i.range.start, a = r / i.domProps.centerContainer.width, h = 0; h < o.length; h++) if (void 0 !== o[h].repeat) { const d = t(o[h].start); let l = t(o[h].end); if (d._d == 'Invalid Date') throw new Error(`Supplied start date is not valid: ${o[h].start}`); if (l._d == 'Invalid Date') throw new Error(`Supplied end date is not valid: ${o[h].end}`); const u = l - d; if (u >= 4 * a) { let c = 0; const p = s.clone(); switch (o[h].repeat) { case 'daily': d.day() != l.day() && (c = 1), d.dayOfYear(n.dayOfYear()), d.year(n.year()), d.subtract(7, 'days'), l.dayOfYear(n.dayOfYear()), l.year(n.year()), l.subtract(7 - c, 'days'), p.add(1, 'weeks'); break; case 'weekly': var f = l.diff(d, 'days'); var m = d.day(); d.date(n.date()), d.month(n.month()), d.year(n.year()), l = d.clone(), d.day(m), l.day(m), l.add(f, 'days'), d.subtract(1, 'weeks'), l.subtract(1, 'weeks'), p.add(1, 'weeks'); break; case 'monthly': d.month() != l.month() && (c = 1), d.month(n.month()), d.year(n.year()), d.subtract(1, 'months'), l.month(n.month()), l.year(n.year()), l.subtract(1, 'months'), l.add(c, 'months'), p.add(1, 'months'); break; case 'yearly': d.year() != l.year() && (c = 1), d.year(n.year()), d.subtract(1, 'years'), l.year(n.year()), l.subtract(1, 'years'), l.add(c, 'years'), p.add(1, 'years'); break; default: return void console.log('Wrong repeat format, allowed are: daily, weekly, monthly, yearly. Given:', o[h].repeat); } while (d < p) switch (i.hiddenDates.push({ start: d.valueOf(), end: l.valueOf() }), o[h].repeat) { case 'daily': d.add(1, 'days'), l.add(1, 'days'); break; case 'weekly': d.add(1, 'weeks'), l.add(1, 'weeks'); break; case 'monthly': d.add(1, 'months'), l.add(1, 'months'); break; case 'yearly': d.add(1, 'y'), l.add(1, 'y'); break; default: return void console.log('Wrong repeat format, allowed are: daily, weekly, monthly, yearly. Given:', o[h].repeat); }i.hiddenDates.push({ start: d.valueOf(), end: l.valueOf() }); } }e.removeDuplicates(i); const v = e.isHidden(i.range.start, i.hiddenDates); const g = e.isHidden(i.range.end, i.hiddenDates); let y = i.range.start; let b = i.range.end; v.hidden == 1 && (y = i.range.startToFront == 1 ? v.startDate - 1 : v.endDate + 1), g.hidden == 1 && (b = i.range.endToFront == 1 ? g.startDate - 1 : g.endDate + 1), v.hidden != 1 && g.hidden != 1 || i.range._applyRange(y, b); } }, e.removeDuplicates = function (t) { for (var e = t.hiddenDates, i = [], o = 0; o < e.length; o++) for (let n = 0; n < e.length; n++)o != n && e[n].remove != 1 && e[o].remove != 1 && (e[n].start >= e[o].start && e[n].end <= e[o].end ? e[n].remove = !0 : e[n].start >= e[o].start && e[n].start <= e[o].end ? (e[o].end = e[n].end, e[n].remove = !0) : e[n].end >= e[o].start && e[n].end <= e[o].end && (e[o].start = e[n].start, e[n].remove = !0)); for (o = 0; o < e.length; o++)!0 !== e[o].remove && i.push(e[o]); t.hiddenDates = i, t.hiddenDates.sort((t, e) => t.start - e.start); }, e.printDates = function (t) { for (let e = 0; e < t.length; e++)console.log(e, new Date(t[e].start), new Date(t[e].end), t[e].start, t[e].end, t[e].remove); }, e.stepOverHiddenDates = function (t, e, i) { for (var o = !1, n = e.current.valueOf(), s = 0; s < e.hiddenDates.length; s++) { const r = e.hiddenDates[s].start; var a = e.hiddenDates[s].end; if (n >= r && n < a) { o = !0; break; } } if (o == 1 && n < e._end.valueOf() && n != i) { const h = t(i); const d = t(a); h.year() != d.year() ? e.switchedYear = !0 : h.month() != d.month() ? e.switchedMonth = !0 : h.dayOfYear() != d.dayOfYear() && (e.switchedDay = !0), e.current = d; } }, e.toScreen = function (t, i, o) { let n; if (t.body.hiddenDates.length == 0) return n = t.range.conversion(o), (i.valueOf() - n.offset) * n.scale; const s = e.isHidden(i, t.body.hiddenDates); s.hidden == 1 && (i = s.startDate); const r = e.getHiddenDurationBetween(t.body.hiddenDates, t.range.start, t.range.end); if (i < t.range.start) { n = t.range.conversion(o, r); const a = e.getHiddenDurationBeforeStart(t.body.hiddenDates, i, n.offset); return i = t.options.moment(i).toDate().valueOf(), i += a, -(n.offset - i.valueOf()) * n.scale; } if (i > t.range.end) { const h = { start: t.range.start, end: i }; return i = e.correctTimeForHidden(t.options.moment, t.body.hiddenDates, h, i), n = t.range.conversion(o, r), (i.valueOf() - n.offset) * n.scale; } return i = e.correctTimeForHidden(t.options.moment, t.body.hiddenDates, t.range, i), n = t.range.conversion(o, r), (i.valueOf() - n.offset) * n.scale; }, e.toTime = function (t, i, o) { if (t.body.hiddenDates.length == 0) { const n = t.range.conversion(o); return new Date(i / n.scale + n.offset); } const s = e.getHiddenDurationBetween(t.body.hiddenDates, t.range.start, t.range.end); const r = t.range.end - t.range.start - s; const a = r * i / o; const h = e.getAccumulatedHiddenDuration(t.body.hiddenDates, t.range, a); return new Date(h + a + t.range.start); }, e.getHiddenDurationBetween = function (t, e, i) { for (var o = 0, n = 0; n < t.length; n++) { const s = t[n].start; const r = t[n].end; s >= e && r < i && (o += r - s); } return o; }, e.getHiddenDurationBeforeStart = function (t, e, i) { for (var o = 0, n = 0; n < t.length; n++) { const s = t[n].start; const r = t[n].end; s >= e && r <= i && (o += r - s); } return o; }, e.correctTimeForHidden = function (t, i, o, n) { return n = t(n).toDate().valueOf(), n -= e.getHiddenDurationBefore(t, i, o, n), n; }, e.getHiddenDurationBefore = function (t, e, i, o) { let n = 0; o = t(o).toDate().valueOf(); for (let s = 0; s < e.length; s++) { const r = e[s].start; const a = e[s].end; r >= i.start && a < i.end && o >= a && (n += a - r); } return n; }, e.getAccumulatedHiddenDuration = function (t, e, i) { for (var o = 0, n = 0, s = e.start, r = 0; r < t.length; r++) { const a = t[r].start; const h = t[r].end; if (a >= e.start && h < e.end) { if (n += a - s, s = h, n >= i) break; o += h - a; } } return o; }, e.snapAwayFromHidden = function (t, i, o, n) { const s = e.isHidden(i, t); return s.hidden == 1 ? o < 0 ? n == 1 ? s.startDate - (s.endDate - i) - 1 : s.startDate - 1 : n == 1 ? s.endDate + (i - s.startDate) + 1 : s.endDate + 1 : i; }, e.isHidden = function (t, e) { for (let i = 0; i < e.length; i++) { var o = e[i].start; var n = e[i].end; if (t >= o && t < n) return { hidden: !0, startDate: o, endDate: n }; } return { hidden: !1, startDate: o, endDate: n }; }; }, function (t, e, i) { e.onTouch = function (t, e) { e.inputHandler = function (t) { t.isFirst && e(t); }, t.on('hammer.input', e.inputHandler); }, e.onRelease = function (t, e) { return e.inputHandler = function (t) { t.isFinal && e(t); }, t.on('hammer.input', e.inputHandler); }, e.offTouch = function (t, e) { t.off('hammer.input', e.inputHandler); }, e.offRelease = e.offTouch, e.disablePreventDefaultVertically = function (t) { const e = 'pan-y'; return t.getTouchAction = function () { return [e]; }, t; }; }, function (t, e, i) { const o = i(6); const n = a(o); const s = i(8); const r = a(s); function a(t) { return t && t.__esModule ? t : { default: t }; } const h = i(10); const d = i(2); const l = i(9); function u(t, e, i) { this.id = null, this.parent = null, this.data = t, this.dom = null, this.conversion = e || {}, this.options = i || {}, this.selected = !1, this.displayed = !1, this.groupShowing = !0, this.dirty = !0, this.top = null, this.right = null, this.left = null, this.width = null, this.height = null, this.editable = null, this._updateEditStatus(); }u.prototype.stack = !0, u.prototype.select = function () { this.selected = !0, this.dirty = !0, this.displayed && this.redraw(); }, u.prototype.unselect = function () { this.selected = !1, this.dirty = !0, this.displayed && this.redraw(); }, u.prototype.setData = function (t) { const e = void 0 != t.group && this.data.group != t.group; e && this.parent != null && this.parent.itemSet._moveToGroup(this, t.group), this.parent && (this.parent.stackDirty = !0); const i = void 0 != t.subgroup && this.data.subgroup != t.subgroup; i && this.parent != null && this.parent.changeSubgroup(this, this.data.subgroup, t.subgroup), this.data = t, this._updateEditStatus(), this.dirty = !0, this.displayed && this.redraw(); }, u.prototype.setParent = function (t) { this.displayed ? (this.hide(), this.parent = t, this.parent && this.show()) : this.parent = t; }, u.prototype.isVisible = function (t) { return !1; }, u.prototype.show = function () { return !1; }, u.prototype.hide = function () { return !1; }, u.prototype.redraw = function () {}, u.prototype.repositionX = function () {}, u.prototype.repositionY = function () {}, u.prototype._repaintDragCenter = function () { if (this.selected && this.options.editable.updateTime && !this.dom.dragCenter) { const t = this; const e = document.createElement('div'); e.className = 'vis-drag-center', e.dragCenterItem = this; const i = new h(e); i.on('tap', (e) => { t.parent.itemSet.body.emitter.emit('click', { event: e, item: t.id }); }), i.on('doubletap', (e) => { e.stopPropagation(), t.parent.itemSet._onUpdateItem(t), t.parent.itemSet.body.emitter.emit('doubleClick', { event: e, item: t.id }); }), this.dom.box ? this.dom.dragLeft ? this.dom.box.insertBefore(e, this.dom.dragLeft) : this.dom.box.appendChild(e) : this.dom.point && this.dom.point.appendChild(e), this.dom.dragCenter = e; } else !this.selected && this.dom.dragCenter && (this.dom.dragCenter.parentNode && this.dom.dragCenter.parentNode.removeChild(this.dom.dragCenter), this.dom.dragCenter = null); }, u.prototype._repaintDeleteButton = function (t) { const e = (this.options.editable.overrideItems || this.editable == null) && this.options.editable.remove || !this.options.editable.overrideItems && this.editable != null && this.editable.remove; if (this.selected && e && !this.dom.deleteButton) { const i = this; const o = document.createElement('div'); this.options.rtl ? o.className = 'vis-delete-rtl' : o.className = 'vis-delete', o.title = 'Delete this item', new h(o).on('tap', (t) => { t.stopPropagation(), i.parent.removeFromDataSet(i); }), t.appendChild(o), this.dom.deleteButton = o; } else !this.selected && this.dom.deleteButton && (this.dom.deleteButton.parentNode && this.dom.deleteButton.parentNode.removeChild(this.dom.deleteButton), this.dom.deleteButton = null); }, u.prototype._repaintOnItemUpdateTimeTooltip = function (t) { if (this.options.tooltipOnItemUpdateTime) { const e = (this.options.editable.updateTime || !0 === this.data.editable) && !1 !== this.data.editable; if (this.selected && e && !this.dom.onItemUpdateTimeTooltip) { const i = document.createElement('div'); i.className = 'vis-onUpdateTime-tooltip', t.appendChild(i), this.dom.onItemUpdateTimeTooltip = i; } else !this.selected && this.dom.onItemUpdateTimeTooltip && (this.dom.onItemUpdateTimeTooltip.parentNode && this.dom.onItemUpdateTimeTooltip.parentNode.removeChild(this.dom.onItemUpdateTimeTooltip), this.dom.onItemUpdateTimeTooltip = null); if (this.dom.onItemUpdateTimeTooltip) { this.dom.onItemUpdateTimeTooltip.style.visibility = this.parent.itemSet.touchParams.itemIsDragging ? 'visible' : 'hidden', this.options.rtl ? this.dom.onItemUpdateTimeTooltip.style.right = this.dom.content.style.right : this.dom.onItemUpdateTimeTooltip.style.left = this.dom.content.style.left; let o; const n = 50; const s = this.parent.itemSet.body.domProps.scrollTop; o = this.options.orientation.item == 'top' ? this.top : this.parent.height - this.top - this.height; let r; let a; const h = o + this.parent.top - n < -s; h ? (this.dom.onItemUpdateTimeTooltip.style.bottom = '', this.dom.onItemUpdateTimeTooltip.style.top = `${this.height + 2}px`) : (this.dom.onItemUpdateTimeTooltip.style.top = '', this.dom.onItemUpdateTimeTooltip.style.bottom = `${this.height + 2}px`), this.options.tooltipOnItemUpdateTime && this.options.tooltipOnItemUpdateTime.template ? (a = this.options.tooltipOnItemUpdateTime.template.bind(this), r = a(this.data)) : (r = `start: ${l(this.data.start).format('MM/DD/YYYY hh:mm')}`, this.data.end && (r += `<br> end: ${l(this.data.end).format('MM/DD/YYYY hh:mm')}`)), this.dom.onItemUpdateTimeTooltip.innerHTML = r; } } }, u.prototype._updateContents = function (t) { let e; let i; let o; let n; let s; const r = this.parent.itemSet.itemsData.get(this.id); const a = this.dom.box || this.dom.point; const h = a.getElementsByClassName('vis-item-visible-frame')[0]; if (this.options.visibleFrameTemplate ? (s = this.options.visibleFrameTemplate.bind(this), n = s(r, a)) : n = '', h) if (n instanceof Object && !(n instanceof Element))s(r, h); else if (i = this._contentToString(this.itemVisibleFrameContent) !== this._contentToString(n), i) { if (n instanceof Element)h.innerHTML = '', h.appendChild(n); else if (void 0 != n)h.innerHTML = n; else if (this.data.type != 'background' || void 0 !== this.data.content) throw new Error(`Property "content" missing in item ${this.id}`); this.itemVisibleFrameContent = n; } if (this.options.template ? (o = this.options.template.bind(this), e = o(r, t, this.data)) : e = this.data.content, e instanceof Object && !(e instanceof Element))o(r, t); else if (i = this._contentToString(this.content) !== this._contentToString(e), i) { if (e instanceof Element)t.innerHTML = '', t.appendChild(e); else if (void 0 != e)t.innerHTML = e; else if (this.data.type != 'background' || void 0 !== this.data.content) throw new Error(`Property "content" missing in item ${this.id}`); this.content = e; } }, u.prototype._updateDataAttributes = function (t) { if (this.options.dataAttributes && this.options.dataAttributes.length > 0) { let e = []; if (Array.isArray(this.options.dataAttributes))e = this.options.dataAttributes; else { if (this.options.dataAttributes != 'all') return; e = (0, r.default)(this.data); } for (let i = 0; i < e.length; i++) { const o = e[i]; const n = this.data[o]; n != null ? t.setAttribute(`data-${o}`, n) : t.removeAttribute(`data-${o}`); } } }, u.prototype._updateStyle = function (t) { this.style && (d.removeCssText(t, this.style), this.style = null), this.data.style && (d.addCssText(t, this.data.style), this.style = this.data.style); }, u.prototype._contentToString = function (t) { return typeof t === 'string' ? t : t && 'outerHTML' in t ? t.outerHTML : t; }, u.prototype._updateEditStatus = function () { this.options && (typeof this.options.editable === 'boolean' ? this.editable = { updateTime: this.options.editable, updateGroup: this.options.editable, remove: this.options.editable } : (0, n.default)(this.options.editable) === 'object' && (this.editable = {}, d.selectiveExtend(['updateTime', 'updateGroup', 'remove'], this.editable, this.options.editable))), this.options && this.options.editable && !0 === this.options.editable.overrideItems || this.data && (typeof this.data.editable === 'boolean' ? this.editable = { updateTime: this.data.editable, updateGroup: this.data.editable, remove: this.data.editable } : (0, n.default)(this.data.editable) === 'object' && (this.editable = {}, d.selectiveExtend(['updateTime', 'updateGroup', 'remove'], this.editable, this.data.editable))); }, u.prototype.getWidthLeft = function () { return 0; }, u.prototype.getWidthRight = function () { return 0; }, u.prototype.getTitle = function () { return this.data.title; }, t.exports = u; }, function (t, e) {
      t.exports = function (t, e) {
        return {
          enumerable: !(1 & t), configurable: !(2 & t), writable: !(4 & t), value: e,
        };
      };
    }, function (t, e) { let i = 0; const o = Math.random(); t.exports = function (t) { return 'Symbol('.concat(void 0 === t ? '' : t, ')_', (++i + o).toString(36)); }; }, function (t, e, i) { const o = i(51); t.exports = function (t) { return Object(o(t)); }; }, function (t, e) { e.f = {}.propertyIsEnumerable; }, function (t, e, i) { function o(t) { this.delay = null, this.max = 1 / 0, this._queue = [], this._timeout = null, this._extended = null, this.setOptions(t); }o.prototype.setOptions = function (t) { t && typeof t.delay !== 'undefined' && (this.delay = t.delay), t && typeof t.max !== 'undefined' && (this.max = t.max), this._flushIfNeeded(); }, o.extend = function (t, e) { const i = new o(e); if (void 0 !== t.flush) throw new Error('Target object already has a property flush'); t.flush = function () { i.flush(); }; const n = [{ name: 'flush', original: void 0 }]; if (e && e.replace) for (let s = 0; s < e.replace.length; s++) { const r = e.replace[s]; n.push({ name: r, original: t[r] }), i.replace(t, r); } return i._extended = { object: t, methods: n }, i; }, o.prototype.destroy = function () { if (this.flush(), this._extended) { for (let t = this._extended.object, e = this._extended.methods, i = 0; i < e.length; i++) { const o = e[i]; o.original ? t[o.name] = o.original : delete t[o.name]; } this._extended = null; } }, o.prototype.replace = function (t, e) { const i = this; const o = t[e]; if (!o) throw new Error(`Method ${e} undefined`); t[e] = function () { for (var t = [], e = 0; e < arguments.length; e++)t[e] = arguments[e]; i.queue({ args: t, fn: o, context: this }); }; }, o.prototype.queue = function (t) { typeof t === 'function' ? this._queue.push({ fn: t }) : this._queue.push(t), this._flushIfNeeded(); }, o.prototype._flushIfNeeded = function () { if (this._queue.length > this.max && this.flush(), clearTimeout(this._timeout), this.queue.length > 0 && typeof this.delay === 'number') { const t = this; this._timeout = setTimeout(() => { t.flush(); }, this.delay); } }, o.prototype.flush = function () { while (this._queue.length > 0) { const t = this._queue.shift(); t.fn.apply(t.context || t.fn, t.args || []); } }, t.exports = o; }, function (t, e) { function i(t) { if (t) return o(t); } function o(t) { for (const e in i.prototype)t[e] = i.prototype[e]; return t; }t.exports = i, i.prototype.on = i.prototype.addEventListener = function (t, e) { return this._callbacks = this._callbacks || {}, (this._callbacks[t] = this._callbacks[t] || []).push(e), this; }, i.prototype.once = function (t, e) { const i = this; function o() { i.off(t, o), e.apply(this, arguments); } return this._callbacks = this._callbacks || {}, o.fn = e, this.on(t, o), this; }, i.prototype.off = i.prototype.removeListener = i.prototype.removeAllListeners = i.prototype.removeEventListener = function (t, e) { if (this._callbacks = this._callbacks || {}, arguments.length == 0) return this._callbacks = {}, this; let i; const o = this._callbacks[t]; if (!o) return this; if (arguments.length == 1) return delete this._callbacks[t], this; for (let n = 0; n < o.length; n++) if (i = o[n], i === e || i.fn === e) { o.splice(n, 1); break; } return this; }, i.prototype.emit = function (t) { this._callbacks = this._callbacks || {}; const e = [].slice.call(arguments, 1); let i = this._callbacks[t]; if (i) { i = i.slice(0); for (let o = 0, n = i.length; o < n; ++o)i[o].apply(this, e); } return this; }, i.prototype.listeners = function (t) { return this._callbacks = this._callbacks || {}, this._callbacks[t] || []; }, i.prototype.hasListeners = function (t) { return !!this.listeners(t).length; }; }, function (t, e, i) {
      const o = i(6); const n = s(o); function s(t) { return t && t.__esModule ? t : { default: t }; } const r = i(2); const a = i(16); const h = i(66); const d = i(36); const l = i(9); function u(t, e) {
        this.dom = {
          foreground: null, lines: [], majorTexts: [], minorTexts: [], redundant: { lines: [], majorTexts: [], minorTexts: [] },
        }, this.props = { range: { start: 0, end: 0, minimumStep: 0 }, lineTop: 0 }, this.defaultOptions = {
          orientation: { axis: 'bottom' }, showMinorLabels: !0, showMajorLabels: !0, maxMinorChars: 7, format: h.FORMAT, moment: l, timeAxis: null,
        }, this.options = r.extend({}, this.defaultOptions), this.body = t, this._create(), this.setOptions(e);
      }u.prototype = new a(), u.prototype.setOptions = function (t) { t && (r.selectiveExtend(['showMinorLabels', 'showMajorLabels', 'maxMinorChars', 'hiddenDates', 'timeAxis', 'moment', 'rtl'], this.options, t), r.selectiveDeepExtend(['format'], this.options, t), 'orientation' in t && (typeof t.orientation === 'string' ? this.options.orientation.axis = t.orientation : (0, n.default)(t.orientation) === 'object' && 'axis' in t.orientation && (this.options.orientation.axis = t.orientation.axis)), 'locale' in t && (typeof l.locale === 'function' ? l.locale(t.locale) : l.lang(t.locale))); }, u.prototype._create = function () { this.dom.foreground = document.createElement('div'), this.dom.background = document.createElement('div'), this.dom.foreground.className = 'vis-time-axis vis-foreground', this.dom.background.className = 'vis-time-axis vis-background'; }, u.prototype.destroy = function () { this.dom.foreground.parentNode && this.dom.foreground.parentNode.removeChild(this.dom.foreground), this.dom.background.parentNode && this.dom.background.parentNode.removeChild(this.dom.background), this.body = null; }, u.prototype.redraw = function () { const t = this.props; const e = this.dom.foreground; const i = this.dom.background; const o = this.options.orientation.axis == 'top' ? this.body.dom.top : this.body.dom.bottom; const n = e.parentNode !== o; this._calculateCharSize(); const s = this.options.showMinorLabels && this.options.orientation.axis !== 'none'; const r = this.options.showMajorLabels && this.options.orientation.axis !== 'none'; t.minorLabelHeight = s ? t.minorCharHeight : 0, t.majorLabelHeight = r ? t.majorCharHeight : 0, t.height = t.minorLabelHeight + t.majorLabelHeight, t.width = e.offsetWidth, t.minorLineHeight = this.body.domProps.root.height - t.majorLabelHeight - (this.options.orientation.axis == 'top' ? this.body.domProps.bottom.height : this.body.domProps.top.height), t.minorLineWidth = 1, t.majorLineHeight = t.minorLineHeight + t.majorLabelHeight, t.majorLineWidth = 1; const a = e.nextSibling; const h = i.nextSibling; return e.parentNode && e.parentNode.removeChild(e), i.parentNode && i.parentNode.removeChild(i), e.style.height = `${this.props.height}px`, this._repaintLabels(), a ? o.insertBefore(e, a) : o.appendChild(e), h ? this.body.dom.backgroundVertical.insertBefore(i, h) : this.body.dom.backgroundVertical.appendChild(i), this._isResized() || n; }, u.prototype._repaintLabels = function () { const t = this.options.orientation.axis; const e = r.convert(this.body.range.start, 'Number'); const i = r.convert(this.body.range.end, 'Number'); const o = this.body.util.toTime((this.props.minorCharWidth || 10) * this.options.maxMinorChars).valueOf(); let n = o - d.getHiddenDurationBefore(this.options.moment, this.body.hiddenDates, this.body.range, o); n -= this.body.util.toTime(0).valueOf(); const s = new h(new Date(e), new Date(i), n, this.body.hiddenDates, this.options); s.setMoment(this.options.moment), this.options.format && s.setFormat(this.options.format), this.options.timeAxis && s.setScale(this.options.timeAxis), this.step = s; let a; let l; let u; let p; let f; const m = this.dom; m.redundant.lines = m.lines, m.redundant.majorTexts = m.majorTexts, m.redundant.minorTexts = m.minorTexts, m.lines = [], m.majorTexts = [], m.minorTexts = []; let v; let g; let y; let b; let _ = 0; let w = void 0; let x = 0; const k = 1e3; s.start(), a = s.getCurrent(), u = this.body.util.toScreen(a); while (s.hasNext() && x < k) { switch (x++, p = s.isMajor(), b = s.getClassName(), y = s.getLabelMinor(), a, l = u, s.next(), a = s.getCurrent(), s.isMajor(), u = this.body.util.toScreen(a), v = _, _ = u - l, s.scale) { case 'week': f = !0; break; default: f = _ >= 0.4 * v; break; } if (this.options.showMinorLabels && f) { var D = this._repaintMinorText(l, y, t, b); D.style.width = `${_}px`; }p && this.options.showMajorLabels ? (l > 0 && (void 0 == w && (w = l), D = this._repaintMajorText(l, s.getLabelMajor(), t, b)), g = this._repaintMajorLine(l, _, t, b)) : f ? g = this._repaintMinorLine(l, _, t, b) : g && (g.style.width = `${parseInt(g.style.width) + _}px`); } if (x !== k || c || (console.warn(`Something is wrong with the Timeline scale. Limited drawing of grid lines to ${k} lines.`), c = !0), this.options.showMajorLabels) { const S = this.body.util.toTime(0); const C = s.getLabelMajor(S); const M = C.length * (this.props.majorCharWidth || 10) + 10; (void 0 == w || M < w) && this._repaintMajorText(0, C, t, b); }r.forEach(this.dom.redundant, (t) => { while (t.length) { const e = t.pop(); e && e.parentNode && e.parentNode.removeChild(e); } }); }, u.prototype._repaintMinorText = function (t, e, i, o) { let n = this.dom.redundant.minorTexts.shift(); if (!n) { const s = document.createTextNode(''); n = document.createElement('div'), n.appendChild(s), this.dom.foreground.appendChild(n); } return this.dom.minorTexts.push(n), n.innerHTML = e, n.style.top = i == 'top' ? `${this.props.majorLabelHeight}px` : '0', this.options.rtl ? (n.style.left = '', n.style.right = `${t}px`) : n.style.left = `${t}px`, n.className = `vis-text vis-minor ${o}`, n; }, u.prototype._repaintMajorText = function (t, e, i, o) { let n = this.dom.redundant.majorTexts.shift(); if (!n) { const s = document.createElement('div'); n = document.createElement('div'), n.appendChild(s), this.dom.foreground.appendChild(n); } return n.childNodes[0].innerHTML = e, n.className = `vis-text vis-major ${o}`, n.style.top = i == 'top' ? '0' : `${this.props.minorLabelHeight}px`, this.options.rtl ? (n.style.left = '', n.style.right = `${t}px`) : n.style.left = `${t}px`, this.dom.majorTexts.push(n), n; }, u.prototype._repaintMinorLine = function (t, e, i, o) { let n = this.dom.redundant.lines.shift(); n || (n = document.createElement('div'), this.dom.background.appendChild(n)), this.dom.lines.push(n); const s = this.props; return n.style.top = i == 'top' ? `${s.majorLabelHeight}px` : `${this.body.domProps.top.height}px`, n.style.height = `${s.minorLineHeight}px`, this.options.rtl ? (n.style.left = '', n.style.right = `${t - s.minorLineWidth / 2}px`, n.className = `vis-grid vis-vertical-rtl vis-minor ${o}`) : (n.style.left = `${t - s.minorLineWidth / 2}px`, n.className = `vis-grid vis-vertical vis-minor ${o}`), n.style.width = `${e}px`, n; }, u.prototype._repaintMajorLine = function (t, e, i, o) { let n = this.dom.redundant.lines.shift(); n || (n = document.createElement('div'), this.dom.background.appendChild(n)), this.dom.lines.push(n); const s = this.props; return n.style.top = i == 'top' ? '0' : `${this.body.domProps.top.height}px`, this.options.rtl ? (n.style.left = '', n.style.right = `${t - s.majorLineWidth / 2}px`, n.className = `vis-grid vis-vertical-rtl vis-major ${o}`) : (n.style.left = `${t - s.majorLineWidth / 2}px`, n.className = `vis-grid vis-vertical vis-major ${o}`), n.style.height = `${s.majorLineHeight}px`, n.style.width = `${e}px`, n; }, u.prototype._calculateCharSize = function () { this.dom.measureCharMinor || (this.dom.measureCharMinor = document.createElement('DIV'), this.dom.measureCharMinor.className = 'vis-text vis-minor vis-measure', this.dom.measureCharMinor.style.position = 'absolute', this.dom.measureCharMinor.appendChild(document.createTextNode('0')), this.dom.foreground.appendChild(this.dom.measureCharMinor)), this.props.minorCharHeight = this.dom.measureCharMinor.clientHeight, this.props.minorCharWidth = this.dom.measureCharMinor.clientWidth, this.dom.measureCharMajor || (this.dom.measureCharMajor = document.createElement('DIV'), this.dom.measureCharMajor.className = 'vis-text vis-major vis-measure', this.dom.measureCharMajor.style.position = 'absolute', this.dom.measureCharMajor.appendChild(document.createTextNode('0')), this.dom.foreground.appendChild(this.dom.measureCharMajor)), this.props.majorCharHeight = this.dom.measureCharMajor.clientHeight, this.props.majorCharWidth = this.dom.measureCharMajor.clientWidth; }; var c = !1; t.exports = u;
    }, function (t, e, i) {
      const o = i(10); const n = i(2); const s = i(16); const r = i(9); const a = i(98); function h(t, e) {
        this.body = t, this.defaultOptions = {
          moment: r, locales: a, locale: 'en', id: void 0, title: void 0,
        }, this.options = n.extend({}, this.defaultOptions), e && e.time ? this.customTime = e.time : this.customTime = new Date(), this.eventParams = {}, this.setOptions(e), this._create();
      }h.prototype = new s(), h.prototype.setOptions = function (t) { t && n.selectiveExtend(['moment', 'locale', 'locales', 'id'], this.options, t); }, h.prototype._create = function () { const t = document.createElement('div'); t['custom-time'] = this, t.className = `vis-custom-time ${this.options.id || ''}`, t.style.position = 'absolute', t.style.top = '0px', t.style.height = '100%', this.bar = t; const e = document.createElement('div'); function i(t) { this.body.range._onMouseWheel(t); }e.style.position = 'relative', e.style.top = '0px', e.style.left = '-10px', e.style.height = '100%', e.style.width = '20px', e.addEventListener ? (e.addEventListener('mousewheel', i.bind(this), !1), e.addEventListener('DOMMouseScroll', i.bind(this), !1)) : e.attachEvent('onmousewheel', i.bind(this)), t.appendChild(e), this.hammer = new o(e), this.hammer.on('panstart', this._onDragStart.bind(this)), this.hammer.on('panmove', this._onDrag.bind(this)), this.hammer.on('panend', this._onDragEnd.bind(this)), this.hammer.get('pan').set({ threshold: 5, direction: o.DIRECTION_HORIZONTAL }); }, h.prototype.destroy = function () { this.hide(), this.hammer.destroy(), this.hammer = null, this.body = null; }, h.prototype.redraw = function () { const t = this.body.dom.backgroundVertical; this.bar.parentNode != t && (this.bar.parentNode && this.bar.parentNode.removeChild(this.bar), t.appendChild(this.bar)); const e = this.body.util.toScreen(this.customTime); let i = this.options.locales[this.options.locale]; i || (this.warned || (console.log(`WARNING: options.locales['${this.options.locale}'] not found. See http://visjs.org/docs/timeline/#Localization`), this.warned = !0), i = this.options.locales.en); let o = this.options.title; return void 0 === o ? (o = `${i.time}: ${this.options.moment(this.customTime).format('dddd, MMMM Do YYYY, H:mm:ss')}`, o = o.charAt(0).toUpperCase() + o.substring(1)) : typeof o === 'function' && (o = o.call(this.customTime)), this.bar.style.left = `${e}px`, this.bar.title = o, !1; }, h.prototype.hide = function () { this.bar.parentNode && this.bar.parentNode.removeChild(this.bar); }, h.prototype.setCustomTime = function (t) { this.customTime = n.convert(t, 'Date'), this.redraw(); }, h.prototype.getCustomTime = function () { return new Date(this.customTime.valueOf()); }, h.prototype.setCustomTitle = function (t) { this.options.title = t; }, h.prototype._onDragStart = function (t) { this.eventParams.dragging = !0, this.eventParams.customTime = this.customTime, t.stopPropagation(); }, h.prototype._onDrag = function (t) { if (this.eventParams.dragging) { const e = this.body.util.toScreen(this.eventParams.customTime) + t.deltaX; const i = this.body.util.toTime(e); this.setCustomTime(i), this.body.emitter.emit('timechange', { id: this.options.id, time: new Date(this.customTime.valueOf()), event: t }), t.stopPropagation(); } }, h.prototype._onDragEnd = function (t) { this.eventParams.dragging && (this.body.emitter.emit('timechanged', { id: this.options.id, time: new Date(this.customTime.valueOf()), event: t }), t.stopPropagation()); }, h.customTimeFromTarget = function (t) { let e = t.target; while (e) { if (e.hasOwnProperty('custom-time')) return e['custom-time']; e = e.parentNode; } return null; }, t.exports = h;
    }, function (t, e, i) {
      Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(0); const n = a(o); const s = i(1); const r = a(s); function a(t) { return t && t.__esModule ? t : { default: t }; } const h = i(2); const d = i(117).default; const l = i(48).default; const u = i(193).default; const c = i(200).default; const p = i(201).default; const f = i(202).default; const m = i(203).default; const v = i(204).default; const g = i(205).default; const y = i(206).default; const b = i(207).default; const _ = i(208).default; const w = i(209).default; const x = i(210).default; const k = i(211).default; const D = i(212).default; const S = i(213).default; const C = i(15); const M = C.printStyle; const O = (function () {
        function t(e, i, o, s, r, a) { (0, n.default)(this, t), this.options = h.bridgeObject(r), this.globalOptions = r, this.defaultOptions = a, this.body = i, this.edges = [], this.id = void 0, this.imagelist = o, this.grouplist = s, this.x = void 0, this.y = void 0, this.baseSize = this.options.size, this.baseFontSize = this.options.font.size, this.predefinedPosition = !1, this.selected = !1, this.hover = !1, this.labelModule = new d(this.body, this.options, !1), this.setOptions(e); } return (0, r.default)(t, [{ key: 'attachEdge', value(t) { this.edges.indexOf(t) === -1 && this.edges.push(t); } }, { key: 'detachEdge', value(t) { const e = this.edges.indexOf(t); e != -1 && this.edges.splice(e, 1); } }, { key: 'setOptions', value(e) { const i = this.options.shape; if (e) { if (void 0 !== e.id && (this.id = e.id), void 0 === this.id) throw new Error('Node must have an id'); t.checkMass(e, this.id), void 0 !== e.x && (e.x === null ? (this.x = void 0, this.predefinedPosition = !1) : (this.x = parseInt(e.x), this.predefinedPosition = !0)), void 0 !== e.y && (e.y === null ? (this.y = void 0, this.predefinedPosition = !1) : (this.y = parseInt(e.y), this.predefinedPosition = !0)), void 0 !== e.size && (this.baseSize = e.size), void 0 !== e.value && (e.value = parseFloat(e.value)), t.parseOptions(this.options, e, !0, this.globalOptions, this.grouplist); const o = [e, this.options, this.defaultOptions]; return this.chooser = l.choosify('node', o), this._load_images(), this.updateLabelModule(e), this.updateShape(i), void 0 !== e.hidden || void 0 !== e.physics; } } }, { key: '_load_images', value() { if (this.options.shape === 'circularImage' || this.options.shape === 'image') { if (void 0 === this.options.image) throw new Error(`Option image must be defined for node type '${this.options.shape}'`); if (void 0 === this.imagelist) throw new Error('Internal Error: No images provided'); if (typeof this.options.image === 'string') this.imageObj = this.imagelist.load(this.options.image, this.options.brokenImage, this.id); else { if (void 0 === this.options.image.unselected) throw new Error('No unselected image provided'); this.imageObj = this.imagelist.load(this.options.image.unselected, this.options.brokenImage, this.id), void 0 !== this.options.image.selected ? this.imageObjAlt = this.imagelist.load(this.options.image.selected, this.options.brokenImage, this.id) : this.imageObjAlt = void 0; } } } }, {
          key: 'getFormattingValues',
          value() {
            const t = {
              color: this.options.color.background, borderWidth: this.options.borderWidth, borderColor: this.options.color.border, size: this.options.size, borderDashes: this.options.shapeProperties.borderDashes, borderRadius: this.options.shapeProperties.borderRadius, shadow: this.options.shadow.enabled, shadowColor: this.options.shadow.color, shadowSize: this.options.shadow.size, shadowX: this.options.shadow.x, shadowY: this.options.shadow.y,
            }; return this.selected || this.hover ? !0 === this.chooser ? this.selected ? (t.borderWidth *= 2, t.color = this.options.color.highlight.background, t.borderColor = this.options.color.highlight.border, t.shadow = this.options.shadow.enabled) : this.hover && (t.color = this.options.color.hover.background, t.borderColor = this.options.color.hover.border, t.shadow = this.options.shadow.enabled) : typeof this.chooser === 'function' && (this.chooser(t, this.options.id, this.selected, this.hover), !1 === t.shadow && (t.shadowColor === this.options.shadow.color && t.shadowSize === this.options.shadow.size && t.shadowX === this.options.shadow.x && t.shadowY === this.options.shadow.y || (t.shadow = !0))) : t.shadow = this.options.shadow.enabled, t;
          }, 
        }, { key: 'updateLabelModule', value(e) { void 0 !== this.options.label && this.options.label !== null || (this.options.label = ''), t.updateGroupOptions(this.options, e, this.grouplist); const i = this.grouplist.get(this.options.group, !1); const o = [e, this.options, i, this.globalOptions, this.defaultOptions]; this.labelModule.update(this.options, o), void 0 !== this.labelModule.baseSize && (this.baseFontSize = this.labelModule.baseSize); } }, { key: 'updateShape', value(t) { if (t === this.options.shape && this.shape) this.shape.setOptions(this.options, this.imageObj, this.imageObjAlt); else switch (this.options.shape) { case 'box': this.shape = new u(this.options, this.body, this.labelModule); break; case 'circle': this.shape = new c(this.options, this.body, this.labelModule); break; case 'circularImage': this.shape = new p(this.options, this.body, this.labelModule, this.imageObj, this.imageObjAlt); break; case 'database': this.shape = new f(this.options, this.body, this.labelModule); break; case 'diamond': this.shape = new m(this.options, this.body, this.labelModule); break; case 'dot': this.shape = new v(this.options, this.body, this.labelModule); break; case 'ellipse': this.shape = new g(this.options, this.body, this.labelModule); break; case 'icon': this.shape = new y(this.options, this.body, this.labelModule); break; case 'image': this.shape = new b(this.options, this.body, this.labelModule, this.imageObj, this.imageObjAlt); break; case 'square': this.shape = new _(this.options, this.body, this.labelModule); break; case 'hexagon': this.shape = new w(this.options, this.body, this.labelModule); break; case 'star': this.shape = new x(this.options, this.body, this.labelModule); break; case 'text': this.shape = new k(this.options, this.body, this.labelModule); break; case 'triangle': this.shape = new D(this.options, this.body, this.labelModule); break; case 'triangleDown': this.shape = new S(this.options, this.body, this.labelModule); break; default: this.shape = new g(this.options, this.body, this.labelModule); break; } this.needsRefresh(); } }, { key: 'select', value() { this.selected = !0, this.needsRefresh(); } }, { key: 'unselect', value() { this.selected = !1, this.needsRefresh(); } }, { key: 'needsRefresh', value() { this.shape.refreshNeeded = !0; } }, { key: 'getTitle', value() { return this.options.title; } }, { key: 'distanceToBorder', value(t, e) { return this.shape.distanceToBorder(t, e); } }, { key: 'isFixed', value() { return this.options.fixed.x && this.options.fixed.y; } }, { key: 'isSelected', value() { return this.selected; } }, { key: 'getValue', value() { return this.options.value; } }, { key: 'getLabelSize', value() { return this.labelModule.size(); } }, { key: 'setValueRange', value(t, e, i) { if (void 0 !== this.options.value) { const o = this.options.scaling.customScalingFunction(t, e, i, this.options.value); const n = this.options.scaling.max - this.options.scaling.min; if (!0 === this.options.scaling.label.enabled) { const s = this.options.scaling.label.max - this.options.scaling.label.min; this.options.font.size = this.options.scaling.label.min + o * s; } this.options.size = this.options.scaling.min + o * n; } else this.options.size = this.baseSize, this.options.font.size = this.baseFontSize; this.updateLabelModule(); } }, { key: 'draw', value(t) { const e = this.getFormattingValues(); this.shape.draw(t, this.x, this.y, this.selected, this.hover, e); } }, { key: 'updateBoundingBox', value(t) { this.shape.updateBoundingBox(this.x, this.y, t); } }, { key: 'resize', value(t) { const e = this.getFormattingValues(); this.shape.resize(t, this.selected, this.hover, e); } }, { key: 'getItemsOnPoint', value(t) { const e = []; return this.labelModule.visible() && l.pointInRect(this.labelModule.getSize(), t) && e.push({ nodeId: this.id, labelId: 0 }), l.pointInRect(this.shape.boundingBox, t) && e.push({ nodeId: this.id }), e; } }, { key: 'isOverlappingWith', value(t) { return this.shape.left < t.right && this.shape.left + this.shape.width > t.left && this.shape.top < t.bottom && this.shape.top + this.shape.height > t.top; } }, { key: 'isBoundingBoxOverlappingWith', value(t) { return this.shape.boundingBox.left < t.right && this.shape.boundingBox.right > t.left && this.shape.boundingBox.top < t.bottom && this.shape.boundingBox.bottom > t.top; } }], [{ key: 'updateGroupOptions', value(t, e, i) { if (void 0 !== i) { const o = t.group; if (void 0 !== e && void 0 !== e.group && o !== e.group) throw new Error("updateGroupOptions: group values in options don't match."); const n = typeof o === 'number' || typeof o === 'string' && o != ''; if (n) { const s = i.get(o); h.selectiveNotDeepExtend(['font'], t, s), t.color = h.parseColor(t.color); } } } }, { key: 'parseOptions', value(e, i) { const o = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; const n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}; const s = arguments[4]; const r = ['color', 'fixed', 'shadow']; if (h.selectiveNotDeepExtend(r, e, i, o), t.checkMass(i), h.mergeOptions(e, i, 'shadow', n), void 0 !== i.color && i.color !== null) { const a = h.parseColor(i.color); h.fillIfDefined(e.color, a); } else !0 === o && i.color === null && (e.color = h.bridgeObject(n.color)); void 0 !== i.fixed && i.fixed !== null && (typeof i.fixed === 'boolean' ? (e.fixed.x = i.fixed, e.fixed.y = i.fixed) : (void 0 !== i.fixed.x && typeof i.fixed.x === 'boolean' && (e.fixed.x = i.fixed.x), void 0 !== i.fixed.y && typeof i.fixed.y === 'boolean' && (e.fixed.y = i.fixed.y))), !0 === o && i.font === null && (e.font = h.bridgeObject(n.font)), t.updateGroupOptions(e, i, s), void 0 !== i.scaling && h.mergeOptions(e.scaling, i.scaling, 'label', n.scaling); } }, { key: 'checkMass', value(t, e) { if (void 0 !== t.mass && t.mass <= 0) { let i = ''; void 0 !== e && (i = ` in node id: ${e}`), console.log(`%cNegative or zero mass disallowed${i}, setting mass to 1.`, M), t.mass = 1; } } }]), t;
      }()); e.default = O;
    }, function (t, e, i) { Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(6); const n = d(o); const s = i(0); const r = d(s); const a = i(1); const h = d(a); function d(t) { return t && t.__esModule ? t : { default: t }; } const l = i(2); const u = (function () { function t() { (0, r.default)(this, t); } return (0, h.default)(t, null, [{ key: 'choosify', value(t, e) { const i = ['node', 'edge', 'label']; let o = !0; const s = l.topMost(e, 'chosen'); if (typeof s === 'boolean')o = s; else if ((typeof s === 'undefined' ? 'undefined' : (0, n.default)(s)) === 'object') { if (i.indexOf(t) === -1) throw new Error(`choosify: subOption '${t}' should be one of '${i.join("', '")}'`); const r = l.topMost(e, ['chosen', t]); typeof r !== 'boolean' && typeof r !== 'function' || (o = r); } return o; } }, { key: 'pointInRect', value(t, e, i) { if (t.width <= 0 || t.height <= 0) return !1; if (void 0 !== i) { const o = { x: e.x - i.x, y: e.y - i.y }; if (i.angle !== 0) { const n = -i.angle; const s = { x: Math.cos(n) * o.x - Math.sin(n) * o.y, y: Math.sin(n) * o.x + Math.cos(n) * o.y }; e = s; } else e = o; } const r = t.x + t.width; const a = t.y + t.width; return t.left < e.x && r > e.x && t.top < e.y && a > e.y; } }, { key: 'isValidLabel', value(t) { return typeof t === 'string' && t !== ''; } }]), t; }()); e.default = u; }, function (t, e, i) { i(125); for (let o = i(18), n = i(26), s = i(31), r = i(13)('toStringTag'), a = 'CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,TextTrackList,TouchList'.split(','), h = 0; h < a.length; h++) { const d = a[h]; const l = o[d]; const u = l && l.prototype; u && !u[r] && n(u, r, d), s[d] = s.Array; } }, function (t, e) { const i = {}.toString; t.exports = function (t) { return i.call(t).slice(8, -1); }; }, function (t, e) { t.exports = function (t) { if (void 0 == t) throw TypeError(`Can't call method on  ${t}`); return t; }; }, function (t, e) { t.exports = !0; }, function (t, e, i) { const o = i(32); t.exports = function (t, e) { if (!o(t)) return t; let i; let n; if (e && typeof (i = t.toString) === 'function' && !o(n = i.call(t))) return n; if (typeof (i = t.valueOf) === 'function' && !o(n = i.call(t))) return n; if (!e && typeof (i = t.toString) === 'function' && !o(n = i.call(t))) return n; throw TypeError("Can't convert object to primitive value"); }; }, function (t, e, i) { const o = i(27); const n = i(130); const s = i(58); const r = i(56)('IE_PROTO'); const a = function () {}; const h = 'prototype'; var d = function () { let t; const e = i(82)('iframe'); let o = s.length; const n = '<'; const r = '>'; e.style.display = 'none', i(134).appendChild(e), e.src = 'javascript:', t = e.contentWindow.document, t.open(), t.write(`${n}script${r}document.F=Object${n}/script${r}`), t.close(), d = t.F; while (o--) delete d[h][s[o]]; return d(); }; t.exports = Object.create || function (t, e) { let i; return t !== null ? (a[h] = o(t), i = new a(), a[h] = null, i[r] = t) : i = d(), void 0 === e ? i : n(i, e); }; }, function (t, e) { const i = Math.ceil; const o = Math.floor; t.exports = function (t) { return isNaN(t = +t) ? 0 : (t > 0 ? o : i)(t); }; }, function (t, e, i) { const o = i(57)('keys'); const n = i(40); t.exports = function (t) { return o[t] || (o[t] = n(t)); }; }, function (t, e, i) { const o = i(18); const n = '__core-js_shared__'; const s = o[n] || (o[n] = {}); t.exports = function (t) { return s[t] || (s[t] = {}); }; }, function (t, e) { t.exports = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(','); }, function (t, e, i) { const o = i(20).f; const n = i(22); const s = i(13)('toStringTag'); t.exports = function (t, e, i) { t && !n(t = i ? t : t.prototype, s) && o(t, s, { configurable: !0, value: e }); }; }, function (t, e, i) { const o = i(135)(!0); i(79)(String, 'String', function (t) { this._t = String(t), this._i = 0; }, function () { let t; const e = this._t; const i = this._i; return i >= e.length ? { value: void 0, done: !0 } : (t = o(e, i), this._i += t.length, { value: t, done: !1 }); }); }, function (t, e, i) { e.f = i(13); }, function (t, e, i) { const o = i(18); const n = i(7); const s = i(52); const r = i(61); const a = i(20).f; t.exports = function (t) { const e = n.Symbol || (n.Symbol = s ? {} : o.Symbol || {}); t.charAt(0) == '_' || t in e || a(e, t, { value: r.f(t) }); }; }, function (t, e) { e.f = Object.getOwnPropertySymbols; }, function (t, e, i) {
      const o = i(8); const n = d(o); const s = i(19); const r = d(s); const a = i(6); const h = d(a); function d(t) { return t && t.__esModule ? t : { default: t }; } const l = i(2); const u = i(9); const c = i(16); const p = i(36); function f(t, e) {
        const i = u().hours(0).minutes(0).seconds(0)
          .milliseconds(0); const o = i.clone().add(-3, 'days').valueOf(); const n = i.clone().add(3, 'days').valueOf(); this.millisecondsPerPixelCache = void 0, void 0 === e ? (this.start = o, this.end = n) : (this.start = e.start || o, this.end = e.end || n), this.rolling = !1, this.body = t, this.deltaDifference = 0, this.scaleOffset = 0, this.startToFront = !1, this.endToFront = !0, this.defaultOptions = {
          rtl: !1, start: null, end: null, moment: u, direction: 'horizontal', moveable: !0, zoomable: !0, min: null, max: null, zoomMin: 10, zoomMax: 31536e10, rollingMode: { follow: !1, offset: 0.5 },
        }, this.options = l.extend({}, this.defaultOptions), this.props = { touch: {} }, this.animationTimer = null, this.body.emitter.on('panstart', this._onDragStart.bind(this)), this.body.emitter.on('panmove', this._onDrag.bind(this)), this.body.emitter.on('panend', this._onDragEnd.bind(this)), this.body.emitter.on('mousewheel', this._onMouseWheel.bind(this)), this.body.emitter.on('touch', this._onTouch.bind(this)), this.body.emitter.on('pinch', this._onPinch.bind(this)), this.body.dom.rollingModeBtn.addEventListener('click', this.startRolling.bind(this)), this.setOptions(e);
      } function m(t) { if (t != 'horizontal' && t != 'vertical') throw new TypeError(`Unknown direction "${t}". Choose "horizontal" or "vertical".`); }f.prototype = new c(), f.prototype.setOptions = function (t) { if (t) { const e = ['animation', 'direction', 'min', 'max', 'zoomMin', 'zoomMax', 'moveable', 'zoomable', 'moment', 'activate', 'hiddenDates', 'zoomKey', 'rtl', 'showCurrentTime', 'rollingMode', 'horizontalScroll']; l.selectiveExtend(e, this.options, t), t.rollingMode && t.rollingMode.follow && this.startRolling(), ('start' in t || 'end' in t) && this.setRange(t.start, t.end); } }, f.prototype.startRolling = function () { const t = this; function e() { t.stopRolling(), t.rolling = !0; let i = t.end - t.start; const o = l.convert(new Date(), 'Date').valueOf(); const n = o - i * t.options.rollingMode.offset; const s = o + i * (1 - t.options.rollingMode.offset); const r = { animation: !1 }; t.setRange(n, s, r); const a = t.conversion(t.body.domProps.center.width).scale; i = 1 / a / 10, i < 30 && (i = 30), i > 1e3 && (i = 1e3), t.body.dom.rollingModeBtn.style.visibility = 'hidden', t.currentTimeTimer = setTimeout(e, i); }e(); }, f.prototype.stopRolling = function () { void 0 !== this.currentTimeTimer && (clearTimeout(this.currentTimeTimer), this.rolling = !1, this.body.dom.rollingModeBtn.style.visibility = 'visible'); }, f.prototype.setRange = function (t, e, i, o, s) {
        i || (i = {}), !0 !== i.byUser && (i.byUser = !1); const a = this; const d = void 0 != t ? l.convert(t, 'Date').valueOf() : null; const u = void 0 != e ? l.convert(e, 'Date').valueOf() : null; if (this._cancelAnimation(), this.millisecondsPerPixelCache = void 0, i.animation) {
          const c = this.start; const f = this.end; const m = (0, h.default)(i.animation) === 'object' && 'duration' in i.animation ? i.animation.duration : 500; const v = (0, h.default)(i.animation) === 'object' && 'easingFunction' in i.animation ? i.animation.easingFunction : 'easeInOutQuad'; const g = l.easingFunctions[v]; if (!g) throw new Error(`Unknown easing function ${(0, r.default)(v)}. Choose from: ${(0, n.default)(l.easingFunctions).join(', ')}`); const y = (new Date()).valueOf(); let b = !1; const _ = function t() {
            if (!a.props.touch.dragging) {
              const e = (new Date()).valueOf(); const n = e - y; const r = g(n / m); const h = n > m; const l = h || d === null ? d : c + (d - c) * r; const v = h || u === null ? u : f + (u - f) * r; w = a._applyRange(l, v), p.updateHiddenDates(a.options.moment, a.body, a.options.hiddenDates), b = b || w; const _ = {
                start: new Date(a.start), end: new Date(a.end), byUser: i.byUser, event: i.event,
              }; if (s && s(r, w, h), w && a.body.emitter.emit('rangechange', _), h) { if (b && (a.body.emitter.emit('rangechanged', _), o)) return o(); } else a.animationTimer = setTimeout(t, 20);
            }
          }; return _();
        } var w = this._applyRange(d, u); if (p.updateHiddenDates(this.options.moment, this.body, this.options.hiddenDates), w) {
          const x = {
            start: new Date(this.start), end: new Date(this.end), byUser: i.byUser, event: i.event,
          }; if (this.body.emitter.emit('rangechange', x), clearTimeout(a.timeoutID), a.timeoutID = setTimeout(() => { a.body.emitter.emit('rangechanged', x); }, 200), o) return o();
        }
      }, f.prototype.getMillisecondsPerPixel = function () { return void 0 === this.millisecondsPerPixelCache && (this.millisecondsPerPixelCache = (this.end - this.start) / this.body.dom.center.clientWidth), this.millisecondsPerPixelCache; }, f.prototype._cancelAnimation = function () { this.animationTimer && (clearTimeout(this.animationTimer), this.animationTimer = null); }, f.prototype._applyRange = function (t, e) { let i; let o = t != null ? l.convert(t, 'Date').valueOf() : this.start; let n = e != null ? l.convert(e, 'Date').valueOf() : this.end; const s = this.options.max != null ? l.convert(this.options.max, 'Date').valueOf() : null; const r = this.options.min != null ? l.convert(this.options.min, 'Date').valueOf() : null; if (isNaN(o) || o === null) throw new Error(`Invalid start "${t}"`); if (isNaN(n) || n === null) throw new Error(`Invalid end "${e}"`); if (n < o && (n = o), r !== null && o < r && (i = r - o, o += i, n += i, s != null && n > s && (n = s)), s !== null && n > s && (i = n - s, o -= i, n -= i, r != null && o < r && (o = r)), this.options.zoomMin !== null) { let a = parseFloat(this.options.zoomMin); if (a < 0 && (a = 0), n - o < a) { const h = 0.5; this.end - this.start === a && o >= this.start - h && n <= this.end ? (o = this.start, n = this.end) : (i = a - (n - o), o -= i / 2, n += i / 2); } } if (this.options.zoomMax !== null) { let d = parseFloat(this.options.zoomMax); d < 0 && (d = 0), n - o > d && (this.end - this.start === d && o < this.start && n > this.end ? (o = this.start, n = this.end) : (i = n - o - d, o += i / 2, n -= i / 2)); } const u = this.start != o || this.end != n; return o >= this.start && o <= this.end || n >= this.start && n <= this.end || this.start >= o && this.start <= n || this.end >= o && this.end <= n || this.body.emitter.emit('checkRangedItems'), this.start = o, this.end = n, u; }, f.prototype.getRange = function () { return { start: this.start, end: this.end }; }, f.prototype.conversion = function (t, e) { return f.conversion(this.start, this.end, t, e); }, f.conversion = function (t, e, i, o) { return void 0 === o && (o = 0), i != 0 && e - t != 0 ? { offset: t, scale: i / (e - t - o) } : { offset: 0, scale: 1 }; }, f.prototype._onDragStart = function (t) { this.deltaDifference = 0, this.previousDelta = 0, this.options.moveable && this._isInsideRange(t) && this.props.touch.allowDragging && (this.stopRolling(), this.props.touch.start = this.start, this.props.touch.end = this.end, this.props.touch.dragging = !0, this.body.dom.root && (this.body.dom.root.style.cursor = 'move')); }, f.prototype._onDrag = function (t) {
        if (t && this.props.touch.dragging && this.options.moveable && this.props.touch.allowDragging) {
          const e = this.options.direction; m(e); let i = e == 'horizontal' ? t.deltaX : t.deltaY; i -= this.deltaDifference; let o = this.props.touch.end - this.props.touch.start; const n = p.getHiddenDurationBetween(this.body.hiddenDates, this.start, this.end); o -= n; let s; const r = e == 'horizontal' ? this.body.domProps.center.width : this.body.domProps.center.height; s = this.options.rtl ? i / r * o : -i / r * o; const a = this.props.touch.start + s; const h = this.props.touch.end + s; const d = p.snapAwayFromHidden(this.body.hiddenDates, a, this.previousDelta - i, !0); const l = p.snapAwayFromHidden(this.body.hiddenDates, h, this.previousDelta - i, !0); if (d != a || l != h) return this.deltaDifference += i, this.props.touch.start = d, this.props.touch.end = l, void this._onDrag(t); this.previousDelta = i, this._applyRange(a, h); const u = new Date(this.start); const c = new Date(this.end); this.body.emitter.emit('rangechange', {
            start: u, end: c, byUser: !0, event: t,
          }), this.body.emitter.emit('panmove');
        }
      }, f.prototype._onDragEnd = function (t) {
        this.props.touch.dragging && this.options.moveable && this.props.touch.allowDragging && (this.props.touch.dragging = !1, this.body.dom.root && (this.body.dom.root.style.cursor = 'auto'), this.body.emitter.emit('rangechanged', {
          start: new Date(this.start), end: new Date(this.end), byUser: !0, event: t,
        }));
      }, f.prototype._onMouseWheel = function (t) { let e = 0; if (t.wheelDelta ? e = t.wheelDelta / 120 : t.detail && (e = -t.detail / 3), !(this.options.zoomKey && !t[this.options.zoomKey] && this.options.zoomable || !this.options.zoomable && this.options.moveable) && this.options.zoomable && this.options.moveable && this._isInsideRange(t) && e) { let i; let o; if (i = e < 0 ? 1 - e / 5 : 1 / (1 + e / 5), this.rolling)o = this.start + (this.end - this.start) * this.options.rollingMode.offset; else { const n = this.getPointer({ x: t.clientX, y: t.clientY }, this.body.dom.center); o = this._pointerToDate(n); } this.zoom(i, o, e, t), t.preventDefault(); } }, f.prototype._onTouch = function (t) { this.props.touch.start = this.start, this.props.touch.end = this.end, this.props.touch.allowDragging = !0, this.props.touch.center = null, this.scaleOffset = 0, this.deltaDifference = 0, l.preventDefault(t); }, f.prototype._onPinch = function (t) { if (this.options.zoomable && this.options.moveable) { l.preventDefault(t), this.props.touch.allowDragging = !1, this.props.touch.center || (this.props.touch.center = this.getPointer(t.center, this.body.dom.center)), this.stopRolling(); const e = 1 / (t.scale + this.scaleOffset); const i = this._pointerToDate(this.props.touch.center); const o = p.getHiddenDurationBetween(this.body.hiddenDates, this.start, this.end); const n = p.getHiddenDurationBefore(this.options.moment, this.body.hiddenDates, this, i); const s = o - n; let r = i - n + (this.props.touch.start - (i - n)) * e; let a = i + s + (this.props.touch.end - (i + s)) * e; this.startToFront = 1 - e <= 0, this.endToFront = e - 1 <= 0; const h = p.snapAwayFromHidden(this.body.hiddenDates, r, 1 - e, !0); const d = p.snapAwayFromHidden(this.body.hiddenDates, a, e - 1, !0); h == r && d == a || (this.props.touch.start = h, this.props.touch.end = d, this.scaleOffset = 1 - t.scale, r = h, a = d); const u = { animation: !1, byUser: !0, event: t }; this.setRange(r, a, u), this.startToFront = !1, this.endToFront = !0; } }, f.prototype._isInsideRange = function (t) { let e; const i = t.center ? t.center.x : t.clientX; e = this.options.rtl ? i - l.getAbsoluteLeft(this.body.dom.centerContainer) : l.getAbsoluteRight(this.body.dom.centerContainer) - i; const o = this.body.util.toTime(e); return o >= this.start && o <= this.end; }, f.prototype._pointerToDate = function (t) { let e; const i = this.options.direction; if (m(i), i == 'horizontal') return this.body.util.toTime(t.x).valueOf(); const o = this.body.domProps.center.height; return e = this.conversion(o), t.y / e.scale + e.offset; }, f.prototype.getPointer = function (t, e) { return this.options.rtl ? { x: l.getAbsoluteRight(e) - t.x, y: t.y - l.getAbsoluteTop(e) } : { x: t.x - l.getAbsoluteLeft(e), y: t.y - l.getAbsoluteTop(e) }; }, f.prototype.zoom = function (t, e, i, o) { e == null && (e = (this.start + this.end) / 2); const n = p.getHiddenDurationBetween(this.body.hiddenDates, this.start, this.end); const s = p.getHiddenDurationBefore(this.options.moment, this.body.hiddenDates, this, e); const r = n - s; let a = e - s + (this.start - (e - s)) * t; let h = e + r + (this.end - (e + r)) * t; this.startToFront = !(i > 0), this.endToFront = !(-i > 0); const d = p.snapAwayFromHidden(this.body.hiddenDates, a, i, !0); const l = p.snapAwayFromHidden(this.body.hiddenDates, h, -i, !0); d == a && l == h || (a = d, h = l); const u = { animation: !1, byUser: !0, event: o }; this.setRange(a, h, u), this.startToFront = !1, this.endToFront = !0; }, f.prototype.move = function (t) { const e = this.end - this.start; const i = this.start + e * t; const o = this.end + e * t; this.start = i, this.end = o; }, f.prototype.moveTo = function (t) { const e = (this.start + this.end) / 2; const i = e - t; const o = this.start - i; const n = this.end - i; const s = { animation: !1, byUser: !0, event: null }; this.setRange(o, n, s); }, t.exports = f;
    }, function (t, e, i) {
      const o = i(19); const n = a(o); const s = i(6); const r = a(s); function a(t) { return t && t.__esModule ? t : { default: t }; } const h = i(44); const d = i(10); const l = i(37); const u = i(2); const c = i(45); const p = i(97); const f = i(36); const m = i(46); function v() {}h(v.prototype), v.prototype._create = function (t) {
        this.dom = {}, this.dom.container = t, this.dom.root = document.createElement('div'), this.dom.background = document.createElement('div'), this.dom.backgroundVertical = document.createElement('div'), this.dom.backgroundHorizontal = document.createElement('div'), this.dom.centerContainer = document.createElement('div'), this.dom.leftContainer = document.createElement('div'), this.dom.rightContainer = document.createElement('div'), this.dom.center = document.createElement('div'), this.dom.left = document.createElement('div'), this.dom.right = document.createElement('div'), this.dom.top = document.createElement('div'), this.dom.bottom = document.createElement('div'), this.dom.shadowTop = document.createElement('div'), this.dom.shadowBottom = document.createElement('div'), this.dom.shadowTopLeft = document.createElement('div'), this.dom.shadowBottomLeft = document.createElement('div'), this.dom.shadowTopRight = document.createElement('div'), this.dom.shadowBottomRight = document.createElement('div'), this.dom.rollingModeBtn = document.createElement('div'), this.dom.root.className = 'vis-timeline', this.dom.background.className = 'vis-panel vis-background', this.dom.backgroundVertical.className = 'vis-panel vis-background vis-vertical', this.dom.backgroundHorizontal.className = 'vis-panel vis-background vis-horizontal', this.dom.centerContainer.className = 'vis-panel vis-center', this.dom.leftContainer.className = 'vis-panel vis-left', this.dom.rightContainer.className = 'vis-panel vis-right', this.dom.top.className = 'vis-panel vis-top', this.dom.bottom.className = 'vis-panel vis-bottom', this.dom.left.className = 'vis-content', this.dom.center.className = 'vis-content', this.dom.right.className = 'vis-content', this.dom.shadowTop.className = 'vis-shadow vis-top', this.dom.shadowBottom.className = 'vis-shadow vis-bottom', this.dom.shadowTopLeft.className = 'vis-shadow vis-top', this.dom.shadowBottomLeft.className = 'vis-shadow vis-bottom', this.dom.shadowTopRight.className = 'vis-shadow vis-top', this.dom.shadowBottomRight.className = 'vis-shadow vis-bottom', this.dom.rollingModeBtn.className = 'vis-rolling-mode-btn', this.dom.root.appendChild(this.dom.background), this.dom.root.appendChild(this.dom.backgroundVertical), this.dom.root.appendChild(this.dom.backgroundHorizontal), this.dom.root.appendChild(this.dom.centerContainer), this.dom.root.appendChild(this.dom.leftContainer), this.dom.root.appendChild(this.dom.rightContainer), this.dom.root.appendChild(this.dom.top), this.dom.root.appendChild(this.dom.bottom), this.dom.root.appendChild(this.dom.bottom), this.dom.root.appendChild(this.dom.rollingModeBtn), this.dom.centerContainer.appendChild(this.dom.center), this.dom.leftContainer.appendChild(this.dom.left), this.dom.rightContainer.appendChild(this.dom.right), this.dom.centerContainer.appendChild(this.dom.shadowTop), this.dom.centerContainer.appendChild(this.dom.shadowBottom), this.dom.leftContainer.appendChild(this.dom.shadowTopLeft), this.dom.leftContainer.appendChild(this.dom.shadowBottomLeft), this.dom.rightContainer.appendChild(this.dom.shadowTopRight), this.dom.rightContainer.appendChild(this.dom.shadowBottomRight), this.props = {
          root: {}, background: {}, centerContainer: {}, leftContainer: {}, rightContainer: {}, center: {}, left: {}, right: {}, top: {}, bottom: {}, border: {}, scrollTop: 0, scrollTopMin: 0,
        }, this.on('rangechange', () => { !0 === this.initialDrawDone && this._redraw(); }), this.on('rangechanged', () => { this.initialRangeChangeDone || (this.initialRangeChangeDone = !0); }), this.on('touch', this._onTouch.bind(this)), this.on('panmove', this._onDrag.bind(this)); const e = this; this._origRedraw = this._redraw.bind(this), this._redraw = u.throttle(this._origRedraw), this.on('_change', (t) => { e.itemSet && e.itemSet.initialItemSetDrawn && t && t.queue == 1 ? e._redraw() : e._origRedraw(); }), this.hammer = new d(this.dom.root); const i = this.hammer.get('pinch').set({ enable: !0 }); l.disablePreventDefaultVertically(i), this.hammer.get('pan').set({ threshold: 5, direction: d.DIRECTION_HORIZONTAL }), this.listeners = {}; const o = ['tap', 'doubletap', 'press', 'pinch', 'pan', 'panstart', 'panmove', 'panend']; function n(t) { this.isActive() && this.emit('mousewheel', t); let e = 0; let i = 0; if ('detail' in t && (i = -1 * t.detail), 'wheelDelta' in t && (i = t.wheelDelta), 'wheelDeltaY' in t && (i = t.wheelDeltaY), 'wheelDeltaX' in t && (e = -1 * t.wheelDeltaX), 'axis' in t && t.axis === t.HORIZONTAL_AXIS && (e = -1 * i, i = 0), 'deltaY' in t && (i = -1 * t.deltaY), 'deltaX' in t && (e = t.deltaX), this.options.zoomKey && !t[this.options.zoomKey]) if (t.preventDefault(), this.options.verticalScroll && Math.abs(i) >= Math.abs(e)) { const o = this.props.scrollTop; const n = o + i; this.isActive() && (this._setScrollTop(n), this._redraw(), this.emit('scroll', t)); } else if (this.options.horizontalScroll) { const s = Math.abs(e) >= Math.abs(i) ? e : i; const r = s / 120 * (this.range.end - this.range.start) / 20; const a = this.range.start + r; const h = this.range.end + r; const d = { animation: !1, byUser: !0, event: t }; this.range.setRange(a, h, d); } } function s(t) { if (e.options.verticalScroll && (t.preventDefault(), e.isActive())) { const i = -t.target.scrollTop; e._setScrollTop(i), e._redraw(), e.emit('scrollSide', t); } }o.forEach((t) => { const i = function (i) { e.isActive() && e.emit(t, i); }; e.hammer.on(t, i), e.listeners[t] = i; }), l.onTouch(this.hammer, (t) => { e.emit('touch', t); }), l.onRelease(this.hammer, (t) => { e.emit('release', t); }), this.dom.centerContainer.addEventListener ? (this.dom.centerContainer.addEventListener('mousewheel', n.bind(this), !1), this.dom.centerContainer.addEventListener('DOMMouseScroll', n.bind(this), !1)) : this.dom.centerContainer.attachEvent('onmousewheel', n.bind(this)), this.dom.left.parentNode.addEventListener('scroll', s.bind(this)), this.dom.right.parentNode.addEventListener('scroll', s.bind(this)); let r = !1; function a(t) { if (t.preventDefault && t.preventDefault(), !(!t.target.className.indexOf('vis') > -1) && !r) return t.dataTransfer.dropEffect = 'move', r = !0, !1; } function h(t) { t.preventDefault && t.preventDefault(), t.stopPropagation && t.stopPropagation(); try { var i = JSON.parse(t.dataTransfer.getData('text')); if (!i || !i.content) return; } catch (o) { return !1; } return r = !1, t.center = { x: t.clientX, y: t.clientY }, i.target !== 'item' ? e.itemSet._onAddItem(t) : e.itemSet._onDropObjectOnItem(t), e.emit('drop', e.getEventProperties(t)), !1; } if (this.dom.center.addEventListener('dragover', a.bind(this), !1), this.dom.center.addEventListener('drop', h.bind(this), !1), this.customTimes = [], this.touch = {}, this.redrawCount = 0, this.initialDrawDone = !1, this.initialRangeChangeDone = !1, !t) throw new Error('No container provided'); t.appendChild(this.dom.root);
      }, v.prototype.setOptions = function (t) { if (t) { const e = ['width', 'height', 'minHeight', 'maxHeight', 'autoResize', 'start', 'end', 'clickToUse', 'dataAttributes', 'hiddenDates', 'locale', 'locales', 'moment', 'rtl', 'zoomKey', 'horizontalScroll', 'verticalScroll']; if (u.selectiveExtend(e, this.options, t), this.dom.rollingModeBtn.style.visibility = 'hidden', this.options.rtl && (this.dom.container.style.direction = 'rtl', this.dom.backgroundVertical.className = 'vis-panel vis-background vis-vertical-rtl'), this.options.verticalScroll && (this.options.rtl ? this.dom.rightContainer.className = 'vis-panel vis-right vis-vertical-scroll' : this.dom.leftContainer.className = 'vis-panel vis-left vis-vertical-scroll'), (0, r.default)(this.options.orientation) !== 'object' && (this.options.orientation = { item: void 0, axis: void 0 }), 'orientation' in t && (typeof t.orientation === 'string' ? this.options.orientation = { item: t.orientation, axis: t.orientation } : (0, r.default)(t.orientation) === 'object' && ('item' in t.orientation && (this.options.orientation.item = t.orientation.item), 'axis' in t.orientation && (this.options.orientation.axis = t.orientation.axis))), this.options.orientation.axis === 'both') { if (!this.timeAxis2) { const i = this.timeAxis2 = new c(this.body); i.setOptions = function (t) { const e = t ? u.extend({}, t) : {}; e.orientation = 'top', c.prototype.setOptions.call(i, e); }, this.components.push(i); } } else if (this.timeAxis2) { const o = this.components.indexOf(this.timeAxis2); o !== -1 && this.components.splice(o, 1), this.timeAxis2.destroy(), this.timeAxis2 = null; } if (typeof t.drawPoints === 'function' && (t.drawPoints = { onRender: t.drawPoints }), 'hiddenDates' in this.options && f.convertHiddenOptions(this.options.moment, this.body, this.options.hiddenDates), 'clickToUse' in t && (t.clickToUse ? this.activator || (this.activator = new p(this.dom.root)) : this.activator && (this.activator.destroy(), delete this.activator)), 'showCustomTime' in t) throw new Error('Option `showCustomTime` is deprecated. Create a custom time bar via timeline.addCustomTime(time [, id])'); this._initAutoResize(); } if (this.components.forEach(e => e.setOptions(t)), 'configure' in t) { this.configurator || (this.configurator = this._createConfigurator()), this.configurator.setOptions(t.configure); const n = u.deepExtend({}, this.options); this.components.forEach((t) => { u.deepExtend(n, t.options); }), this.configurator.setModuleOptions({ global: n }); } this._redraw(); }, v.prototype.isActive = function () { return !this.activator || this.activator.active; }, v.prototype.destroy = function () { for (const t in this.setItems(null), this.setGroups(null), this.off(), this._stopAutoResize(), this.dom.root.parentNode && this.dom.root.parentNode.removeChild(this.dom.root), this.dom = null, this.activator && (this.activator.destroy(), delete this.activator), this.listeners) this.listeners.hasOwnProperty(t) && delete this.listeners[t]; this.listeners = null, this.hammer = null, this.components.forEach(t => t.destroy()), this.body = null; }, v.prototype.setCustomTime = function (t, e) { const i = this.customTimes.filter(t => e === t.options.id); if (i.length === 0) throw new Error(`No custom time bar found with id ${(0, n.default)(e)}`); i.length > 0 && i[0].setCustomTime(t); }, v.prototype.getCustomTime = function (t) { const e = this.customTimes.filter(e => e.options.id === t); if (e.length === 0) throw new Error(`No custom time bar found with id ${(0, n.default)(t)}`); return e[0].getCustomTime(); }, v.prototype.setCustomTimeTitle = function (t, e) { const i = this.customTimes.filter(t => t.options.id === e); if (i.length === 0) throw new Error(`No custom time bar found with id ${(0, n.default)(e)}`); if (i.length > 0) return i[0].setCustomTitle(t); }, v.prototype.getEventProperties = function (t) { return { event: t }; }, v.prototype.addCustomTime = function (t, e) {
        const i = void 0 !== t ? u.convert(t, 'Date').valueOf() : new Date(); const
          o = this.customTimes.some(t => t.options.id === e); if (o) throw new Error(`A custom time with id ${(0, n.default)(e)} already exists`); const s = new m(this.body, u.extend({}, this.options, { time: i, id: e })); return this.customTimes.push(s), this.components.push(s), this._redraw(), e;
      }, v.prototype.removeCustomTime = function (t) { const e = this.customTimes.filter(e => e.options.id === t); if (e.length === 0) throw new Error(`No custom time bar found with id ${(0, n.default)(t)}`); e.forEach((t) => { this.customTimes.splice(this.customTimes.indexOf(t), 1), this.components.splice(this.components.indexOf(t), 1), t.destroy(); }); }, v.prototype.getVisibleItems = function () { return this.itemSet && this.itemSet.getVisibleItems() || []; }, v.prototype.fit = function (t, e) { const i = this.getDataRange(); if (i.min !== null || i.max !== null) { const o = i.max - i.min; const n = new Date(i.min.valueOf() - 0.01 * o); const s = new Date(i.max.valueOf() + 0.01 * o); const r = !t || void 0 === t.animation || t.animation; this.range.setRange(n, s, { animation: r }, e); } }, v.prototype.getDataRange = function () { throw new Error('Cannot invoke abstract method getDataRange'); }, v.prototype.setWindow = function (t, e, i, o) { let n; let s; typeof arguments[2] === 'function' && (o = arguments[2], i = {}), arguments.length == 1 ? (s = arguments[0], n = void 0 === s.animation || s.animation, this.range.setRange(s.start, s.end, { animation: n })) : arguments.length == 2 && typeof arguments[1] === 'function' ? (s = arguments[0], o = arguments[1], n = void 0 === s.animation || s.animation, this.range.setRange(s.start, s.end, { animation: n }, o)) : (n = !i || void 0 === i.animation || i.animation, this.range.setRange(t, e, { animation: n }, o)); }, v.prototype.moveTo = function (t, e, i) { typeof arguments[1] === 'function' && (i = arguments[1], e = {}); const o = this.range.end - this.range.start; const n = u.convert(t, 'Date').valueOf(); const s = n - o / 2; const r = n + o / 2; const a = !e || void 0 === e.animation || e.animation; this.range.setRange(s, r, { animation: a }, i); }, v.prototype.getWindow = function () { const t = this.range.getRange(); return { start: new Date(t.start), end: new Date(t.end) }; }, v.prototype.zoomIn = function (t, e, i) { if (!(!t || t < 0 || t > 1)) { typeof arguments[1] === 'function' && (i = arguments[1], e = {}); const o = this.getWindow(); const n = o.start.valueOf(); const s = o.end.valueOf(); const r = s - n; const a = r / (1 + t); const h = (r - a) / 2; const d = n + h; const l = s - h; this.setWindow(d, l, e, i); } }, v.prototype.zoomOut = function (t, e, i) { if (!(!t || t < 0 || t > 1)) { typeof arguments[1] === 'function' && (i = arguments[1], e = {}); const o = this.getWindow(); const n = o.start.valueOf(); const s = o.end.valueOf(); const r = s - n; const a = n - r * t / 2; const h = s + r * t / 2; this.setWindow(a, h, e, i); } }, v.prototype.redraw = function () { this._redraw(); }, v.prototype._redraw = function () {
        this.redrawCount++; let t = !1; const e = this.options; const i = this.props; const o = this.dom; if (o && o.container && o.root.offsetWidth != 0) {
          f.updateHiddenDates(this.options.moment, this.body, this.options.hiddenDates), e.orientation == 'top' ? (u.addClassName(o.root, 'vis-top'), u.removeClassName(o.root, 'vis-bottom')) : (u.removeClassName(o.root, 'vis-top'), u.addClassName(o.root, 'vis-bottom')), o.root.style.maxHeight = u.option.asSize(e.maxHeight, ''), o.root.style.minHeight = u.option.asSize(e.minHeight, ''), o.root.style.width = u.option.asSize(e.width, ''), i.border.left = (o.centerContainer.offsetWidth - o.centerContainer.clientWidth) / 2, i.border.right = i.border.left, i.border.top = (o.centerContainer.offsetHeight - o.centerContainer.clientHeight) / 2, i.border.bottom = i.border.top, i.borderRootHeight = o.root.offsetHeight - o.root.clientHeight, i.borderRootWidth = o.root.offsetWidth - o.root.clientWidth, o.centerContainer.clientHeight === 0 && (i.border.left = i.border.top, i.border.right = i.border.left), o.root.clientHeight === 0 && (i.borderRootWidth = i.borderRootHeight), i.center.height = o.center.offsetHeight, i.left.height = o.left.offsetHeight, i.right.height = o.right.offsetHeight, i.top.height = o.top.clientHeight || -i.border.top, i.bottom.height = o.bottom.clientHeight || -i.border.bottom; const n = Math.max(i.left.height, i.center.height, i.right.height); const s = i.top.height + n + i.bottom.height + i.borderRootHeight + i.border.top + i.border.bottom; o.root.style.height = u.option.asSize(e.height, `${s}px`), i.root.height = o.root.offsetHeight, i.background.height = i.root.height - i.borderRootHeight; const r = i.root.height - i.top.height - i.bottom.height - i.borderRootHeight; i.centerContainer.height = r, i.leftContainer.height = r, i.rightContainer.height = i.leftContainer.height, i.root.width = o.root.offsetWidth, i.background.width = i.root.width - i.borderRootWidth, this.initialDrawDone || (i.scrollbarWidth = u.getScrollBarWidth()), e.verticalScroll ? e.rtl ? (i.left.width = o.leftContainer.clientWidth || -i.border.left, i.right.width = o.rightContainer.clientWidth + i.scrollbarWidth || -i.border.right) : (i.left.width = o.leftContainer.clientWidth + i.scrollbarWidth || -i.border.left, i.right.width = o.rightContainer.clientWidth || -i.border.right) : (i.left.width = o.leftContainer.clientWidth || -i.border.left, i.right.width = o.rightContainer.clientWidth || -i.border.right), this._setDOM(); let a = this._updateScrollTop(); e.orientation.item != 'top' && (a += Math.max(i.centerContainer.height - i.center.height - i.border.top - i.border.bottom, 0)), o.center.style.top = `${a}px`; const h = i.scrollTop == 0 ? 'hidden' : ''; const
            l = i.scrollTop == i.scrollTopMin ? 'hidden' : ''; o.shadowTop.style.visibility = h, o.shadowBottom.style.visibility = l, o.shadowTopLeft.style.visibility = h, o.shadowBottomLeft.style.visibility = l, o.shadowTopRight.style.visibility = h, o.shadowBottomRight.style.visibility = l, e.verticalScroll && (o.rightContainer.className = 'vis-panel vis-right vis-vertical-scroll', o.leftContainer.className = 'vis-panel vis-left vis-vertical-scroll', o.shadowTopRight.style.visibility = 'hidden', o.shadowBottomRight.style.visibility = 'hidden', o.shadowTopLeft.style.visibility = 'hidden', o.shadowBottomLeft.style.visibility = 'hidden', o.left.style.top = '0px', o.right.style.top = '0px'), (!e.verticalScroll || i.center.height < i.centerContainer.height) && (o.left.style.top = `${a}px`, o.right.style.top = `${a}px`, o.rightContainer.className = o.rightContainer.className.replace(new RegExp('(?:^|\\s)vis-vertical-scroll(?:\\s|$)'), ' '), o.leftContainer.className = o.leftContainer.className.replace(new RegExp('(?:^|\\s)vis-vertical-scroll(?:\\s|$)'), ' '), i.left.width = o.leftContainer.clientWidth || -i.border.left, i.right.width = o.rightContainer.clientWidth || -i.border.right, this._setDOM()); const c = i.center.height > i.centerContainer.height; this.hammer.get('pan').set({ direction: c ? d.DIRECTION_ALL : d.DIRECTION_HORIZONTAL }), this.components.forEach((e) => { t = e.redraw() || t; }); const p = 5; if (t) { if (this.redrawCount < p) return void this.body.emitter.emit('_change'); console.log('WARNING: infinite loop in redraw?'); } else this.redrawCount = 0; this.body.emitter.emit('changed');
        }
      }, v.prototype._setDOM = function () { const t = this.props; const e = this.dom; t.leftContainer.width = t.left.width, t.rightContainer.width = t.right.width; const i = t.root.width - t.left.width - t.right.width - t.borderRootWidth; t.center.width = i, t.centerContainer.width = i, t.top.width = i, t.bottom.width = i, e.background.style.height = `${t.background.height}px`, e.backgroundVertical.style.height = `${t.background.height}px`, e.backgroundHorizontal.style.height = `${t.centerContainer.height}px`, e.centerContainer.style.height = `${t.centerContainer.height}px`, e.leftContainer.style.height = `${t.leftContainer.height}px`, e.rightContainer.style.height = `${t.rightContainer.height}px`, e.background.style.width = `${t.background.width}px`, e.backgroundVertical.style.width = `${t.centerContainer.width}px`, e.backgroundHorizontal.style.width = `${t.background.width}px`, e.centerContainer.style.width = `${t.center.width}px`, e.top.style.width = `${t.top.width}px`, e.bottom.style.width = `${t.bottom.width}px`, e.background.style.left = '0', e.background.style.top = '0', e.backgroundVertical.style.left = `${t.left.width + t.border.left}px`, e.backgroundVertical.style.top = '0', e.backgroundHorizontal.style.left = '0', e.backgroundHorizontal.style.top = `${t.top.height}px`, e.centerContainer.style.left = `${t.left.width}px`, e.centerContainer.style.top = `${t.top.height}px`, e.leftContainer.style.left = '0', e.leftContainer.style.top = `${t.top.height}px`, e.rightContainer.style.left = `${t.left.width + t.center.width}px`, e.rightContainer.style.top = `${t.top.height}px`, e.top.style.left = `${t.left.width}px`, e.top.style.top = '0', e.bottom.style.left = `${t.left.width}px`, e.bottom.style.top = `${t.top.height + t.centerContainer.height}px`, e.center.style.left = '0', e.left.style.left = '0', e.right.style.left = '0'; }, v.prototype.repaint = function () { throw new Error('Function repaint is deprecated. Use redraw instead.'); }, v.prototype.setCurrentTime = function (t) { if (!this.currentTime) throw new Error('Option showCurrentTime must be true'); this.currentTime.setCurrentTime(t); }, v.prototype.getCurrentTime = function () { if (!this.currentTime) throw new Error('Option showCurrentTime must be true'); return this.currentTime.getCurrentTime(); }, v.prototype._toTime = function (t) { return f.toTime(this, t, this.props.center.width); }, v.prototype._toGlobalTime = function (t) { return f.toTime(this, t, this.props.root.width); }, v.prototype._toScreen = function (t) { return f.toScreen(this, t, this.props.center.width); }, v.prototype._toGlobalScreen = function (t) { return f.toScreen(this, t, this.props.root.width); }, v.prototype._initAutoResize = function () { this.options.autoResize == 1 ? this._startAutoResize() : this._stopAutoResize(); }, v.prototype._startAutoResize = function () { const t = this; this._stopAutoResize(), this._onResize = function () { t.options.autoResize == 1 ? t.dom.root && (t.dom.root.offsetWidth == t.props.lastWidth && t.dom.root.offsetHeight == t.props.lastHeight || (t.props.lastWidth = t.dom.root.offsetWidth, t.props.lastHeight = t.dom.root.offsetHeight, t.props.scrollbarWidth = u.getScrollBarWidth(), t.body.emitter.emit('_change'))) : t._stopAutoResize(); }, u.addEventListener(window, 'resize', this._onResize), t.dom.root && (t.props.lastWidth = t.dom.root.offsetWidth, t.props.lastHeight = t.dom.root.offsetHeight), this.watchTimer = setInterval(this._onResize, 1e3); }, v.prototype._stopAutoResize = function () { this.watchTimer && (clearInterval(this.watchTimer), this.watchTimer = void 0), this._onResize && (u.removeEventListener(window, 'resize', this._onResize), this._onResize = null); }, v.prototype._onTouch = function (t) { this.touch.allowDragging = !0, this.touch.initialScrollTop = this.props.scrollTop; }, v.prototype._onPinch = function (t) { this.touch.allowDragging = !1; }, v.prototype._onDrag = function (t) { if (t && this.touch.allowDragging) { const e = t.deltaY; const i = this._getScrollTop(); const o = this._setScrollTop(this.touch.initialScrollTop + e); this.options.verticalScroll && (this.dom.left.parentNode.scrollTop = -this.props.scrollTop, this.dom.right.parentNode.scrollTop = -this.props.scrollTop), o != i && this.emit('verticalDrag'); } }, v.prototype._setScrollTop = function (t) { return this.props.scrollTop = t, this._updateScrollTop(), this.props.scrollTop; }, v.prototype._updateScrollTop = function () { const t = Math.min(this.props.centerContainer.height - this.props.center.height, 0); return t != this.props.scrollTopMin && (this.options.orientation.item != 'top' && (this.props.scrollTop += t - this.props.scrollTopMin), this.props.scrollTopMin = t), this.props.scrollTop > 0 && (this.props.scrollTop = 0), this.props.scrollTop < t && (this.props.scrollTop = t), this.options.verticalScroll && (this.dom.left.parentNode.scrollTop = -this.props.scrollTop, this.dom.right.parentNode.scrollTop = -this.props.scrollTop), this.props.scrollTop; }, v.prototype._getScrollTop = function () { return this.props.scrollTop; }, v.prototype._createConfigurator = function () { throw new Error('Cannot invoke abstract method _createConfigurator'); }, t.exports = v;
    }, function (t, e, i) {
      const o = i(9); const n = i(36); const s = i(2); function r(t, e, i, n, s) { this.moment = o, this.current = this.moment(), this._start = this.moment(), this._end = this.moment(), this.autoScale = !0, this.scale = 'day', this.step = 1, this.setRange(t, e, i), this.switchedDay = !1, this.switchedMonth = !1, this.switchedYear = !1, Array.isArray(n) ? this.hiddenDates = n : this.hiddenDates = void 0 != n ? [n] : [], this.format = r.FORMAT, this.options = s || {}; }r.FORMAT = {
        minorLabels: {
          millisecond: 'SSS', second: 's', minute: 'HH:mm', hour: 'HH:mm', weekday: 'ddd D', day: 'D', week: 'w', month: 'MMM', year: 'YYYY',
        },
        majorLabels: {
          millisecond: 'HH:mm:ss', second: 'D MMMM HH:mm', minute: 'ddd D MMMM', hour: 'ddd D MMMM', weekday: 'MMMM YYYY', day: 'MMMM YYYY', week: 'MMMM YYYY', month: 'YYYY', year: '',
        },
      }, r.prototype.setMoment = function (t) { this.moment = t, this.current = this.moment(this.current.valueOf()), this._start = this.moment(this._start.valueOf()), this._end = this.moment(this._end.valueOf()); }, r.prototype.setFormat = function (t) { const e = s.deepExtend({}, r.FORMAT); this.format = s.deepExtend(e, t); }, r.prototype.setRange = function (t, e, i) { if (!(t instanceof Date) || !(e instanceof Date)) throw 'No legal start or end date in method setRange'; this._start = void 0 != t ? this.moment(t.valueOf()) : new Date(), this._end = void 0 != e ? this.moment(e.valueOf()) : new Date(), this.autoScale && this.setMinimumStep(i); }, r.prototype.start = function () { this.current = this._start.clone(), this.roundToMinor(); }, r.prototype.roundToMinor = function () { switch (this.scale == 'week' && this.current.weekday(0), this.scale) { case 'year': this.current.year(this.step * Math.floor(this.current.year() / this.step)), this.current.month(0); case 'month': this.current.date(1); case 'week': case 'day': case 'weekday': this.current.hours(0); case 'hour': this.current.minutes(0); case 'minute': this.current.seconds(0); case 'second': this.current.milliseconds(0); } if (this.step != 1) switch (this.scale) { case 'millisecond': this.current.subtract(this.current.milliseconds() % this.step, 'milliseconds'); break; case 'second': this.current.subtract(this.current.seconds() % this.step, 'seconds'); break; case 'minute': this.current.subtract(this.current.minutes() % this.step, 'minutes'); break; case 'hour': this.current.subtract(this.current.hours() % this.step, 'hours'); break; case 'weekday': case 'day': this.current.subtract((this.current.date() - 1) % this.step, 'day'); break; case 'week': this.current.subtract(this.current.week() % this.step, 'week'); break; case 'month': this.current.subtract(this.current.month() % this.step, 'month'); break; case 'year': this.current.subtract(this.current.year() % this.step, 'year'); break; default: break; } }, r.prototype.hasNext = function () { return this.current.valueOf() <= this._end.valueOf(); }, r.prototype.next = function () { const t = this.current.valueOf(); switch (this.scale) { case 'millisecond': this.current.add(this.step, 'millisecond'); break; case 'second': this.current.add(this.step, 'second'); break; case 'minute': this.current.add(this.step, 'minute'); break; case 'hour': this.current.add(this.step, 'hour'), this.current.month() < 6 ? this.current.subtract(this.current.hours() % this.step, 'hour') : this.current.hours() % this.step !== 0 && this.current.add(this.step - this.current.hours() % this.step, 'hour'); break; case 'weekday': case 'day': this.current.add(this.step, 'day'); break; case 'week': if (this.current.weekday() !== 0) this.current.weekday(0), this.current.add(this.step, 'week'); else if (!1 === this.options.showMajorLabels) this.current.add(this.step, 'week'); else { const e = this.current.clone(); e.add(1, 'week'), e.isSame(this.current, 'month') ? this.current.add(this.step, 'week') : (this.current.add(this.step, 'week'), this.current.date(1)); } break; case 'month': this.current.add(this.step, 'month'); break; case 'year': this.current.add(this.step, 'year'); break; default: break; } if (this.step != 1) switch (this.scale) { case 'millisecond': this.current.milliseconds() > 0 && this.current.milliseconds() < this.step && this.current.milliseconds(0); break; case 'second': this.current.seconds() > 0 && this.current.seconds() < this.step && this.current.seconds(0); break; case 'minute': this.current.minutes() > 0 && this.current.minutes() < this.step && this.current.minutes(0); break; case 'hour': this.current.hours() > 0 && this.current.hours() < this.step && this.current.hours(0); break; case 'weekday': case 'day': this.current.date() < this.step + 1 && this.current.date(1); break; case 'week': this.current.week() < this.step && this.current.week(1); break; case 'month': this.current.month() < this.step && this.current.month(0); break; case 'year': break; default: break; } this.current.valueOf() == t && (this.current = this._end.clone()), this.switchedDay = !1, this.switchedMonth = !1, this.switchedYear = !1, n.stepOverHiddenDates(this.moment, this, t); }, r.prototype.getCurrent = function () { return this.current; }, r.prototype.setScale = function (t) { t && typeof t.scale === 'string' && (this.scale = t.scale, this.step = t.step > 0 ? t.step : 1, this.autoScale = !1); }, r.prototype.setAutoScale = function (t) { this.autoScale = t; }, r.prototype.setMinimumStep = function (t) { if (void 0 != t) { const e = 31104e6; const i = 2592e6; const o = 864e5; const n = 36e5; const s = 6e4; const r = 1e3; const a = 1; 1e3 * e > t && (this.scale = 'year', this.step = 1e3), 500 * e > t && (this.scale = 'year', this.step = 500), 100 * e > t && (this.scale = 'year', this.step = 100), 50 * e > t && (this.scale = 'year', this.step = 50), 10 * e > t && (this.scale = 'year', this.step = 10), 5 * e > t && (this.scale = 'year', this.step = 5), e > t && (this.scale = 'year', this.step = 1), 3 * i > t && (this.scale = 'month', this.step = 3), i > t && (this.scale = 'month', this.step = 1), 5 * o > t && (this.scale = 'day', this.step = 5), 2 * o > t && (this.scale = 'day', this.step = 2), o > t && (this.scale = 'day', this.step = 1), o / 2 > t && (this.scale = 'weekday', this.step = 1), 4 * n > t && (this.scale = 'hour', this.step = 4), n > t && (this.scale = 'hour', this.step = 1), 15 * s > t && (this.scale = 'minute', this.step = 15), 10 * s > t && (this.scale = 'minute', this.step = 10), 5 * s > t && (this.scale = 'minute', this.step = 5), s > t && (this.scale = 'minute', this.step = 1), 15 * r > t && (this.scale = 'second', this.step = 15), 10 * r > t && (this.scale = 'second', this.step = 10), 5 * r > t && (this.scale = 'second', this.step = 5), r > t && (this.scale = 'second', this.step = 1), 200 * a > t && (this.scale = 'millisecond', this.step = 200), 100 * a > t && (this.scale = 'millisecond', this.step = 100), 50 * a > t && (this.scale = 'millisecond', this.step = 50), 10 * a > t && (this.scale = 'millisecond', this.step = 10), 5 * a > t && (this.scale = 'millisecond', this.step = 5), a > t && (this.scale = 'millisecond', this.step = 1); } }, r.snap = function (t, e, i) { const n = o(t); if (e == 'year') { const s = n.year() + Math.round(n.month() / 12); n.year(Math.round(s / i) * i), n.month(0), n.date(0), n.hours(0), n.minutes(0), n.seconds(0), n.milliseconds(0); } else if (e == 'month')n.date() > 15 ? (n.date(1), n.add(1, 'month')) : n.date(1), n.hours(0), n.minutes(0), n.seconds(0), n.milliseconds(0); else if (e == 'week')n.weekday() > 2 ? (n.weekday(0), n.add(1, 'week')) : n.weekday(0), n.hours(0), n.minutes(0), n.seconds(0), n.milliseconds(0); else if (e == 'day') { switch (i) { case 5: case 2: n.hours(24 * Math.round(n.hours() / 24)); break; default: n.hours(12 * Math.round(n.hours() / 12)); break; }n.minutes(0), n.seconds(0), n.milliseconds(0); } else if (e == 'weekday') { switch (i) { case 5: case 2: n.hours(12 * Math.round(n.hours() / 12)); break; default: n.hours(6 * Math.round(n.hours() / 6)); break; }n.minutes(0), n.seconds(0), n.milliseconds(0); } else if (e == 'hour') { switch (i) { case 4: n.minutes(60 * Math.round(n.minutes() / 60)); break; default: n.minutes(30 * Math.round(n.minutes() / 30)); break; }n.seconds(0), n.milliseconds(0); } else if (e == 'minute') { switch (i) { case 15: case 10: n.minutes(5 * Math.round(n.minutes() / 5)), n.seconds(0); break; case 5: n.seconds(60 * Math.round(n.seconds() / 60)); break; default: n.seconds(30 * Math.round(n.seconds() / 30)); break; }n.milliseconds(0); } else if (e == 'second') switch (i) { case 15: case 10: n.seconds(5 * Math.round(n.seconds() / 5)), n.milliseconds(0); break; case 5: n.milliseconds(1e3 * Math.round(n.milliseconds() / 1e3)); break; default: n.milliseconds(500 * Math.round(n.milliseconds() / 500)); break; } else if (e == 'millisecond') { const r = i > 5 ? i / 2 : 1; n.milliseconds(Math.round(n.milliseconds() / r) * r); } return n; }, r.prototype.isMajor = function () { if (this.switchedYear == 1) switch (this.scale) { case 'year': case 'month': case 'week': case 'weekday': case 'day': case 'hour': case 'minute': case 'second': case 'millisecond': return !0; default: return !1; } else if (this.switchedMonth == 1) switch (this.scale) { case 'week': case 'weekday': case 'day': case 'hour': case 'minute': case 'second': case 'millisecond': return !0; default: return !1; } else if (this.switchedDay == 1) switch (this.scale) { case 'millisecond': case 'second': case 'minute': case 'hour': return !0; default: return !1; } const t = this.moment(this.current); switch (this.scale) { case 'millisecond': return t.milliseconds() == 0; case 'second': return t.seconds() == 0; case 'minute': return t.hours() == 0 && t.minutes() == 0; case 'hour': return t.hours() == 0; case 'weekday': case 'day': return t.date() == 1; case 'week': return t.date() == 1; case 'month': return t.month() == 0; case 'year': return !1; default: return !1; } }, r.prototype.getLabelMinor = function (t) { if (void 0 == t && (t = this.current), t instanceof Date && (t = this.moment(t)), typeof this.format.minorLabels === 'function') return this.format.minorLabels(t, this.scale, this.step); const e = this.format.minorLabels[this.scale]; switch (this.scale) { case 'week': if (this.isMajor() && t.weekday() !== 0) return ''; default: return e && e.length > 0 ? this.moment(t).format(e) : ''; } }, r.prototype.getLabelMajor = function (t) { if (void 0 == t && (t = this.current), t instanceof Date && (t = this.moment(t)), typeof this.format.majorLabels === 'function') return this.format.majorLabels(t, this.scale, this.step); const e = this.format.majorLabels[this.scale]; return e && e.length > 0 ? this.moment(t).format(e) : ''; }, r.prototype.getClassName = function () { const t = this.moment; const e = this.moment(this.current); const i = e.locale ? e.locale('en') : e.lang('en'); const o = this.step; const n = []; function s(t) { return t / o % 2 == 0 ? ' vis-even' : ' vis-odd'; } function r(e) { return e.isSame(new Date(), 'day') ? ' vis-today' : e.isSame(t().add(1, 'day'), 'day') ? ' vis-tomorrow' : e.isSame(t().add(-1, 'day'), 'day') ? ' vis-yesterday' : ''; } function a(t) { return t.isSame(new Date(), 'week') ? ' vis-current-week' : ''; } function h(t) { return t.isSame(new Date(), 'month') ? ' vis-current-month' : ''; } function d(t) { return t.isSame(new Date(), 'year') ? ' vis-current-year' : ''; } switch (this.scale) { case 'millisecond': n.push(r(i)), n.push(s(i.milliseconds())); break; case 'second': n.push(r(i)), n.push(s(i.seconds())); break; case 'minute': n.push(r(i)), n.push(s(i.minutes())); break; case 'hour': n.push(`vis-h${i.hours()}${this.step == 4 ? `-h${i.hours() + 4}` : ''}`), n.push(r(i)), n.push(s(i.hours())); break; case 'weekday': n.push(`vis-${i.format('dddd').toLowerCase()}`), n.push(r(i)), n.push(a(i)), n.push(s(i.date())); break; case 'day': n.push(`vis-day${i.date()}`), n.push(`vis-${i.format('MMMM').toLowerCase()}`), n.push(r(i)), n.push(h(i)), n.push(this.step <= 2 ? r(i) : ''), n.push(this.step <= 2 ? `vis-${i.format('dddd').toLowerCase()}` : ''), n.push(s(i.date() - 1)); break; case 'week': n.push(`vis-week${i.format('w')}`), n.push(a(i)), n.push(s(i.week())); break; case 'month': n.push(`vis-${i.format('MMMM').toLowerCase()}`), n.push(h(i)), n.push(s(i.month())); break; case 'year': n.push(`vis-year${i.year()}`), n.push(d(i)), n.push(s(i.year())); break; } return n.filter(String).join(' '); }, t.exports = r;
    }, function (t, e, i) {
      const o = i(2); const n = i(16); const s = i(9); const r = i(98); function a(t, e) {
        this.body = t, this.defaultOptions = {
          rtl: !1, showCurrentTime: !0, moment: s, locales: r, locale: 'en',
        }, this.options = o.extend({}, this.defaultOptions), this.offset = 0, this._create(), this.setOptions(e);
      }a.prototype = new n(), a.prototype._create = function () { const t = document.createElement('div'); t.className = 'vis-current-time', t.style.position = 'absolute', t.style.top = '0px', t.style.height = '100%', this.bar = t; }, a.prototype.destroy = function () { this.options.showCurrentTime = !1, this.redraw(), this.body = null; }, a.prototype.setOptions = function (t) { t && o.selectiveExtend(['rtl', 'showCurrentTime', 'moment', 'locale', 'locales'], this.options, t); }, a.prototype.redraw = function () { if (this.options.showCurrentTime) { const t = this.body.dom.backgroundVertical; this.bar.parentNode != t && (this.bar.parentNode && this.bar.parentNode.removeChild(this.bar), t.appendChild(this.bar), this.start()); const e = this.options.moment((new Date()).valueOf() + this.offset); const i = this.body.util.toScreen(e); let o = this.options.locales[this.options.locale]; o || (this.warned || (console.log(`WARNING: options.locales['${this.options.locale}'] not found. See http://visjs.org/docs/timeline/#Localization`), this.warned = !0), o = this.options.locales.en); let n = `${o.current} ${o.time}: ${e.format('dddd, MMMM Do YYYY, H:mm:ss')}`; n = n.charAt(0).toUpperCase() + n.substring(1), this.options.rtl ? this.bar.style.right = `${i}px` : this.bar.style.left = `${i}px`, this.bar.title = n; } else this.bar.parentNode && this.bar.parentNode.removeChild(this.bar), this.stop(); return !1; }, a.prototype.start = function () { const t = this; function e() { t.stop(); const i = t.body.range.conversion(t.body.domProps.center.width).scale; let o = 1 / i / 10; o < 30 && (o = 30), o > 1e3 && (o = 1e3), t.redraw(), t.body.emitter.emit('currentTimeTick'), t.currentTimeTimer = setTimeout(e, o); }e(); }, a.prototype.stop = function () { void 0 !== this.currentTimeTimer && (clearTimeout(this.currentTimeTimer), delete this.currentTimeTimer); }, a.prototype.setCurrentTime = function (t) { const e = o.convert(t, 'Date').valueOf(); const i = (new Date()).valueOf(); this.offset = e - i, this.redraw(); }, a.prototype.getCurrentTime = function () { return new Date((new Date()).valueOf() + this.offset); }, t.exports = a;
    }, function (t, e, i) {
      const o = i(8); const n = s(o); function s(t) { return t && t.__esModule ? t : { default: t }; } const r = i(2); const a = i(100); function h(t, e, i) { if (this.groupId = t, this.subgroups = {}, this.subgroupStack = {}, this.subgroupStackAll = !1, this.doInnerStack = !1, this.subgroupIndex = 0, this.subgroupOrderer = e && e.subgroupOrder, this.itemSet = i, this.isVisible = null, this.stackDirty = !0, e && e.nestedGroups && (this.nestedGroups = e.nestedGroups, e.showNested == 0 ? this.showNested = !1 : this.showNested = !0), e && e.subgroupStack) if (typeof e.subgroupStack === 'boolean') this.doInnerStack = e.subgroupStack, this.subgroupStackAll = e.subgroupStack; else for (const o in e.subgroupStack) this.subgroupStack[o] = e.subgroupStack[o], this.doInnerStack = this.doInnerStack || e.subgroupStack[o]; this.nestedInGroup = null, this.dom = {}, this.props = { label: { width: 0, height: 0 } }, this.className = null, this.items = {}, this.visibleItems = [], this.itemsInRange = [], this.orderedItems = { byStart: [], byEnd: [] }, this.checkRangedItems = !1; const n = this; this.itemSet.body.emitter.on('checkRangedItems', () => { n.checkRangedItems = !0; }), this._create(), this.setData(e); }h.prototype._create = function () { const t = document.createElement('div'); this.itemSet.options.groupEditable.order ? t.className = 'vis-label draggable' : t.className = 'vis-label', this.dom.label = t; const e = document.createElement('div'); e.className = 'vis-inner', t.appendChild(e), this.dom.inner = e; const i = document.createElement('div'); i.className = 'vis-group', i['timeline-group'] = this, this.dom.foreground = i, this.dom.background = document.createElement('div'), this.dom.background.className = 'vis-group', this.dom.axis = document.createElement('div'), this.dom.axis.className = 'vis-group', this.dom.marker = document.createElement('div'), this.dom.marker.style.visibility = 'hidden', this.dom.marker.style.position = 'absolute', this.dom.marker.innerHTML = '', this.dom.background.appendChild(this.dom.marker); }, h.prototype.setData = function (t) { let e; let i; if (this.itemSet.options && this.itemSet.options.groupTemplate ? (i = this.itemSet.options.groupTemplate.bind(this), e = i(t, this.dom.inner)) : e = t && t.content, e instanceof Element) { this.dom.inner.appendChild(e); while (this.dom.inner.firstChild) this.dom.inner.removeChild(this.dom.inner.firstChild); this.dom.inner.appendChild(e); } else e instanceof Object ? i(t, this.dom.inner) : this.dom.inner.innerHTML = void 0 !== e && e !== null ? e : this.groupId || ''; if (this.dom.label.title = t && t.title || '', this.dom.inner.firstChild ? r.removeClassName(this.dom.inner, 'vis-hidden') : r.addClassName(this.dom.inner, 'vis-hidden'), t && t.nestedGroups) { this.nestedGroups && this.nestedGroups == t.nestedGroups || (this.nestedGroups = t.nestedGroups), void 0 === t.showNested && void 0 !== this.showNested || (t.showNested == 0 ? this.showNested = !1 : this.showNested = !0), r.addClassName(this.dom.label, 'vis-nesting-group'); var o = this.itemSet.options.rtl ? 'collapsed-rtl' : 'collapsed'; this.showNested ? (r.removeClassName(this.dom.label, o), r.addClassName(this.dom.label, 'expanded')) : (r.removeClassName(this.dom.label, 'expanded'), r.addClassName(this.dom.label, o)); } else this.nestedGroups && (this.nestedGroups = null, o = this.itemSet.options.rtl ? 'collapsed-rtl' : 'collapsed', r.removeClassName(this.dom.label, o), r.removeClassName(this.dom.label, 'expanded'), r.removeClassName(this.dom.label, 'vis-nesting-group')); t && t.nestedInGroup && (r.addClassName(this.dom.label, 'vis-nested-group'), this.itemSet.options && this.itemSet.options.rtl ? this.dom.inner.style.paddingRight = '30px' : this.dom.inner.style.paddingLeft = '30px'); const n = t && t.className || null; n != this.className && (this.className && (r.removeClassName(this.dom.label, this.className), r.removeClassName(this.dom.foreground, this.className), r.removeClassName(this.dom.background, this.className), r.removeClassName(this.dom.axis, this.className)), r.addClassName(this.dom.label, n), r.addClassName(this.dom.foreground, n), r.addClassName(this.dom.background, n), r.addClassName(this.dom.axis, n), this.className = n), this.style && (r.removeCssText(this.dom.label, this.style), this.style = null), t && t.style && (r.addCssText(this.dom.label, t.style), this.style = t.style); }, h.prototype.getLabelWidth = function () { return this.props.label.width; }, h.prototype._didMarkerHeightChange = function () { const t = this.dom.marker.clientHeight; if (t != this.lastMarkerHeight) { this.lastMarkerHeight = t; const e = {}; let i = 0; r.forEach(this.items, (t, o) => { if (t.dirty = !0, t.displayed) { const n = !0; e[o] = t.redraw(n), i = e[o].length; } }); const o = i > 0; if (o) for (var n = 0; n < i; n++)r.forEach(e, (t) => { t[n](); }); return !0; } }, h.prototype._calculateGroupSizeAndPosition = function () { const t = this.dom.foreground.offsetTop; const e = this.dom.foreground.offsetLeft; const i = this.dom.foreground.offsetWidth; this.top = t, this.right = e, this.width = i; }, h.prototype._redrawItems = function (t, e, i, o) { const n = t || this.stackDirty || this.isVisible && !e; if (n) { const s = {}; let h = null; if (typeof this.itemSet.options.order === 'function') { const d = this; const l = !1; const u = {}; let c = 0; r.forEach(this.items, (t, e) => { if (!t.displayed) { const i = !0; u[e] = t.redraw(i), c = u[e].length, d.visibleItems.push(t); } }); const p = c > 0; if (p) for (var f = 0; f < c; f++)r.forEach(u, (t) => { t[f](); }); if (r.forEach(this.items, (t) => { t.repositionX(l); }), this.doInnerStack && this.itemSet.options.stackSubgroups) { for (h in this.subgroups)s[h] = this.subgroups[h].items.slice().sort((t, e) => d.itemSet.options.order(t.data, e.data)); a.stackSubgroupsWithInnerStack(s, i, this.subgroups); } else { const m = this.orderedItems.byStart.slice().sort((t, e) => d.itemSet.options.order(t.data, e.data)); a.stack(m, i, !0); } this.visibleItems = this._updateItemsInRange(this.orderedItems, this.visibleItems, o); } else if (this.visibleItems = this._updateItemsInRange(this.orderedItems, this.visibleItems, o), this.itemSet.options.stack) if (this.doInnerStack && this.itemSet.options.stackSubgroups) { for (h in this.subgroups)s[h] = this.subgroups[h].items; a.stackSubgroupsWithInnerStack(s, i, this.subgroups); } else a.stack(this.visibleItems, i, !0); else a.nostack(this.visibleItems, i, this.subgroups, this.itemSet.options.stackSubgroups); this.stackDirty = !1; } }, h.prototype._didResize = function (t, e) { t = r.updateProperty(this, 'height', e) || t; const i = this.dom.inner.clientWidth; const o = this.dom.inner.clientHeight; return t = r.updateProperty(this.props.label, 'width', i) || t, t = r.updateProperty(this.props.label, 'height', o) || t, t; }, h.prototype._applyGroupHeight = function (t) { this.dom.background.style.height = `${t}px`, this.dom.foreground.style.height = `${t}px`, this.dom.label.style.height = `${t}px`; }, h.prototype._updateItemsVerticalPosition = function (t) { for (let e = 0, i = this.visibleItems.length; e < i; e++) { const o = this.visibleItems[e]; o.repositionY(t), this.isVisible || this.groupId == '__background__' || o.displayed && o.hide(); } }, h.prototype.redraw = function (t, e, i, o) { let n; let s; let r = !1; const a = this.isVisible; const h = [function () { i = this._didMarkerHeightChange.bind(this); }.bind(this), this._updateSubGroupHeights.bind(this, e), this._calculateGroupSizeAndPosition.bind(this), function () { this.isVisible = this._isGroupVisible.bind(this)(t, e); }.bind(this), function () { this._redrawItems.bind(this)(i, a, e, t); }.bind(this), this._updateSubgroupsSizes.bind(this), function () { n = this._calculateHeight.bind(this)(e); }.bind(this), this._calculateGroupSizeAndPosition.bind(this), function () { r = this._didResize.bind(this)(r, n); }.bind(this), function () { this._applyGroupHeight.bind(this)(n); }.bind(this), function () { this._updateItemsVerticalPosition.bind(this)(e); }.bind(this), function () { return !this.isVisible && this.height && (r = !1), r; }]; return o ? h : (h.forEach((t) => { s = t(); }), s); }, h.prototype._updateSubGroupHeights = function (t) { if ((0, n.default)(this.subgroups).length > 0) { const e = this; this.resetSubgroups(), r.forEach(this.visibleItems, (i) => { void 0 !== i.data.subgroup && (e.subgroups[i.data.subgroup].height = Math.max(e.subgroups[i.data.subgroup].height, i.height + t.item.vertical), e.subgroups[i.data.subgroup].visible = !0); }); } }, h.prototype._isGroupVisible = function (t, e) { return this.top <= t.body.domProps.centerContainer.height - t.body.domProps.scrollTop + e.axis && this.top + this.height + e.axis >= -t.body.domProps.scrollTop; }, h.prototype._calculateHeight = function (t) { let e; const i = this.visibleItems; if (i.length > 0) { let o = i[0].top; let n = i[0].top + i[0].height; if (r.forEach(i, (t) => { o = Math.min(o, t.top), n = Math.max(n, t.top + t.height); }), o > t.axis) { const s = o - t.axis; n -= s, r.forEach(i, (t) => { t.top -= s; }); }e = n + t.item.vertical / 2; } else e = 0; return e = Math.max(e, this.props.label.height), e; }, h.prototype.show = function () { this.dom.label.parentNode || this.itemSet.dom.labelSet.appendChild(this.dom.label), this.dom.foreground.parentNode || this.itemSet.dom.foreground.appendChild(this.dom.foreground), this.dom.background.parentNode || this.itemSet.dom.background.appendChild(this.dom.background), this.dom.axis.parentNode || this.itemSet.dom.axis.appendChild(this.dom.axis); }, h.prototype.hide = function () { const t = this.dom.label; t.parentNode && t.parentNode.removeChild(t); const e = this.dom.foreground; e.parentNode && e.parentNode.removeChild(e); const i = this.dom.background; i.parentNode && i.parentNode.removeChild(i); const o = this.dom.axis; o.parentNode && o.parentNode.removeChild(o); }, h.prototype.add = function (t) { if (this.items[t.id] = t, t.setParent(this), this.stackDirty = !0, void 0 !== t.data.subgroup && (this._addToSubgroup(t), this.orderSubgroups()), this.visibleItems.indexOf(t) == -1) { const e = this.itemSet.body.range; this._checkIfVisible(t, this.visibleItems, e); } }, h.prototype._addToSubgroup = function (t, e) {
        e = e || t.data.subgroup, void 0 != e && void 0 === this.subgroups[e] && (this.subgroups[e] = {
          height: 0, top: 0, start: t.data.start, end: t.data.end || t.data.start, visible: !1, index: this.subgroupIndex, items: [], stack: this.subgroupStackAll || this.subgroupStack[e] || !1,
        }, this.subgroupIndex++), new Date(t.data.start) < new Date(this.subgroups[e].start) && (this.subgroups[e].start = t.data.start); const i = t.data.end || t.data.start; new Date(i) > new Date(this.subgroups[e].end) && (this.subgroups[e].end = i), this.subgroups[e].items.push(t);
      }, h.prototype._updateSubgroupsSizes = function () { const t = this; if (t.subgroups) for (const e in t.subgroups) { const i = t.subgroups[e].items[0].data.end || t.subgroups[e].items[0].data.start; var o = t.subgroups[e].items[0].data.start; var n = i - 1; t.subgroups[e].items.forEach((t) => { new Date(t.data.start) < new Date(o) && (o = t.data.start); const e = t.data.end || t.data.start; new Date(e) > new Date(n) && (n = e); }), t.subgroups[e].start = o, t.subgroups[e].end = new Date(n - 1); } }, h.prototype.orderSubgroups = function () { if (void 0 !== this.subgroupOrderer) { let t; const e = []; if (typeof this.subgroupOrderer === 'string') { for (t in this.subgroups)e.push({ subgroup: t, sortField: this.subgroups[t].items[0].data[this.subgroupOrderer] }); e.sort((t, e) => t.sortField - e.sortField); } else if (typeof this.subgroupOrderer === 'function') { for (t in this.subgroups)e.push(this.subgroups[t].items[0].data); e.sort(this.subgroupOrderer); } if (e.length > 0) for (let i = 0; i < e.length; i++) this.subgroups[e[i].subgroup].index = i; } }, h.prototype.resetSubgroups = function () { for (const t in this.subgroups) this.subgroups.hasOwnProperty(t) && (this.subgroups[t].visible = !1, this.subgroups[t].height = 0); }, h.prototype.remove = function (t) { delete this.items[t.id], t.setParent(null), this.stackDirty = !0; const e = this.visibleItems.indexOf(t); e != -1 && this.visibleItems.splice(e, 1), void 0 !== t.data.subgroup && (this._removeFromSubgroup(t), this.orderSubgroups()); }, h.prototype._removeFromSubgroup = function (t, e) { if (e = e || t.data.subgroup, void 0 != e) { const i = this.subgroups[e]; if (i) { const o = i.items.indexOf(t); o >= 0 && (i.items.splice(o, 1), i.items.length ? this._updateSubgroupsSizes() : delete this.subgroups[e]); } } }, h.prototype.removeFromDataSet = function (t) { this.itemSet.removeItem(t.id); }, h.prototype.order = function () { for (var t = r.toArray(this.items), e = [], i = [], o = 0; o < t.length; o++) void 0 !== t[o].data.end && i.push(t[o]), e.push(t[o]); this.orderedItems = { byStart: e, byEnd: i }, a.orderByStart(this.orderedItems.byStart), a.orderByEnd(this.orderedItems.byEnd); }, h.prototype._updateItemsInRange = function (t, e, i) { const o = []; const n = {}; const s = (i.end - i.start) / 4; const a = i.start - s; const h = i.end + s; const d = function (t) { return t < a ? -1 : t <= h ? 0 : 1; }; if (e.length > 0) for (var l = 0; l < e.length; l++) this._checkIfVisibleWithReference(e[l], o, n, i); const u = r.binarySearchCustom(t.byStart, d, 'data', 'start'); if (this._traceVisible(u, t.byStart, o, n, t => t.data.start < a || t.data.start > h), this.checkRangedItems == 1) for (this.checkRangedItems = !1, l = 0; l < t.byEnd.length; l++) this._checkIfVisibleWithReference(t.byEnd[l], o, n, i); else { const c = r.binarySearchCustom(t.byEnd, d, 'data', 'end'); this._traceVisible(c, t.byEnd, o, n, t => t.data.end < a || t.data.end > h); } const p = {}; let f = 0; for (l = 0; l < o.length; l++) { const m = o[l]; if (!m.displayed) { const v = !0; p[l] = m.redraw(v), f = p[l].length; } } const g = f > 0; if (g) for (var y = 0; y < f; y++)r.forEach(p, (t) => { t[y](); }); for (l = 0; l < o.length; l++)o[l].repositionX(); return o; }, h.prototype._traceVisible = function (t, e, i, o, n) { if (t != -1) { let s; let r; for (s = t; s >= 0; s--) { if (r = e[s], n(r)) break; void 0 === o[r.id] && (o[r.id] = !0, i.push(r)); } for (s = t + 1; s < e.length; s++) { if (r = e[s], n(r)) break; void 0 === o[r.id] && (o[r.id] = !0, i.push(r)); } } }, h.prototype._checkIfVisible = function (t, e, i) { t.isVisible(i) ? (t.displayed || t.show(), t.repositionX(), e.push(t)) : t.displayed && t.hide(); }, h.prototype._checkIfVisibleWithReference = function (t, e, i, o) { t.isVisible(o) ? void 0 === i[t.id] && (i[t.id] = !0, e.push(t)) : t.displayed && t.hide(); }, h.prototype.changeSubgroup = function (t, e, i) { this._removeFromSubgroup(t, e), this._addToSubgroup(t, i), this.orderSubgroups(); }, t.exports = h;
    }, function (t, e, i) { const o = i(29); const n = s(o); function s(t) { return t && t.__esModule ? t : { default: t }; } const r = i(68); function a(t, e, i) { r.call(this, t, e, i), this.width = 0, this.height = 0, this.top = 0, this.left = 0; }a.prototype = (0, n.default)(r.prototype), a.prototype.redraw = function (t, e, i) { const o = !1; this.visibleItems = this._updateItemsInRange(this.orderedItems, this.visibleItems, t), this.width = this.dom.background.offsetWidth, this.dom.background.style.height = '0'; for (let n = 0, s = this.visibleItems.length; n < s; n++) { const r = this.visibleItems[n]; r.repositionY(e); } return o; }, a.prototype.show = function () { this.dom.background.parentNode || this.itemSet.dom.background.appendChild(this.dom.background); }, t.exports = a; }, function (t, e, i) { const o = i(38); function n(t, e, i) { if (this.props = { content: { width: 0 } }, this.overflow = !1, this.options = i, t) { if (void 0 == t.start) throw new Error(`Property "start" missing in item ${t.id}`); if (void 0 == t.end) throw new Error(`Property "end" missing in item ${t.id}`); }o.call(this, t, e, i); }n.prototype = new o(null, null, null), n.prototype.baseClassName = 'vis-item vis-range', n.prototype.isVisible = function (t) { return this.data.start < t.end && this.data.end > t.start; }, n.prototype._createDomElement = function () { this.dom || (this.dom = {}, this.dom.box = document.createElement('div'), this.dom.frame = document.createElement('div'), this.dom.frame.className = 'vis-item-overflow', this.dom.box.appendChild(this.dom.frame), this.dom.visibleFrame = document.createElement('div'), this.dom.visibleFrame.className = 'vis-item-visible-frame', this.dom.box.appendChild(this.dom.visibleFrame), this.dom.content = document.createElement('div'), this.dom.content.className = 'vis-item-content', this.dom.frame.appendChild(this.dom.content), this.dom.box['timeline-item'] = this, this.dirty = !0); }, n.prototype._appendDomElement = function () { if (!this.parent) throw new Error('Cannot redraw item: no parent attached'); if (!this.dom.box.parentNode) { const t = this.parent.dom.foreground; if (!t) throw new Error('Cannot redraw item: parent has no foreground container element'); t.appendChild(this.dom.box); } this.displayed = !0; }, n.prototype._updateDirtyDomComponents = function () { if (this.dirty) { this._updateContents(this.dom.content), this._updateDataAttributes(this.dom.box), this._updateStyle(this.dom.box); const t = this.editable.updateTime || this.editable.updateGroup; const e = (this.data.className ? ` ${this.data.className}` : '') + (this.selected ? ' vis-selected' : '') + (t ? ' vis-editable' : ' vis-readonly'); this.dom.box.className = this.baseClassName + e, this.dom.content.style.maxWidth = 'none'; } }, n.prototype._getDomComponentsSizes = function () { return this.overflow = window.getComputedStyle(this.dom.frame).overflow !== 'hidden', { content: { width: this.dom.content.offsetWidth }, box: { height: this.dom.box.offsetHeight } }; }, n.prototype._updateDomComponentsSizes = function (t) { this.props.content.width = t.content.width, this.height = t.box.height, this.dom.content.style.maxWidth = '', this.dirty = !1; }, n.prototype._repaintDomAdditionals = function () { this._repaintOnItemUpdateTimeTooltip(this.dom.box), this._repaintDeleteButton(this.dom.box), this._repaintDragCenter(), this._repaintDragLeft(), this._repaintDragRight(); }, n.prototype.redraw = function (t) { let e; let i; const o = [this._createDomElement.bind(this), this._appendDomElement.bind(this), this._updateDirtyDomComponents.bind(this), function () { this.dirty && (e = this._getDomComponentsSizes.bind(this)()); }.bind(this), function () { this.dirty && this._updateDomComponentsSizes.bind(this)(e); }.bind(this), this._repaintDomAdditionals.bind(this)]; return t ? o : (o.forEach((t) => { i = t(); }), i); }, n.prototype.show = function () { this.displayed || this.redraw(); }, n.prototype.hide = function () { if (this.displayed) { const t = this.dom.box; t.parentNode && t.parentNode.removeChild(t), this.displayed = !1; } }, n.prototype.repositionX = function (t) { let e; let i; const o = this.parent.width; let n = this.conversion.toScreen(this.data.start); let s = this.conversion.toScreen(this.data.end); const r = void 0 === this.data.align ? this.options.align : this.data.align; !1 === this.data.limitSize || void 0 !== t && !0 !== t || (n < -o && (n = -o), s > 2 * o && (s = 2 * o)); const a = Math.max(s - n + 0.5, 1); switch (this.overflow ? (this.options.rtl ? this.right = n : this.left = n, this.width = a + this.props.content.width, i = this.props.content.width) : (this.options.rtl ? this.right = n : this.left = n, this.width = a, i = Math.min(s - n, this.props.content.width)), this.options.rtl ? this.dom.box.style.right = `${this.right}px` : this.dom.box.style.left = `${this.left}px`, this.dom.box.style.width = `${a}px`, r) { case 'left': this.options.rtl ? this.dom.content.style.right = '0' : this.dom.content.style.left = '0'; break; case 'right': this.options.rtl ? this.dom.content.style.right = `${Math.max(a - i, 0)}px` : this.dom.content.style.left = `${Math.max(a - i, 0)}px`; break; case 'center': this.options.rtl ? this.dom.content.style.right = `${Math.max((a - i) / 2, 0)}px` : this.dom.content.style.left = `${Math.max((a - i) / 2, 0)}px`; break; default: e = this.overflow ? s > 0 ? Math.max(-n, 0) : -i : n < 0 ? -n : 0, this.options.rtl ? this.dom.content.style.right = `${e}px` : (this.dom.content.style.left = `${e}px`, this.dom.content.style.width = `calc(100% - ${e}px)`); } }, n.prototype.repositionY = function () { const t = this.options.orientation.item; const e = this.dom.box; e.style.top = t == 'top' ? `${this.top}px` : `${this.parent.height - this.top - this.height}px`; }, n.prototype._repaintDragLeft = function () { if ((this.selected || this.options.itemsAlwaysDraggable.range) && this.options.editable.updateTime && !this.dom.dragLeft) { const t = document.createElement('div'); t.className = 'vis-drag-left', t.dragLeftItem = this, this.dom.box.appendChild(t), this.dom.dragLeft = t; } else this.selected || this.options.itemsAlwaysDraggable.range || !this.dom.dragLeft || (this.dom.dragLeft.parentNode && this.dom.dragLeft.parentNode.removeChild(this.dom.dragLeft), this.dom.dragLeft = null); }, n.prototype._repaintDragRight = function () { if ((this.selected || this.options.itemsAlwaysDraggable.range) && this.options.editable.updateTime && !this.dom.dragRight) { const t = document.createElement('div'); t.className = 'vis-drag-right', t.dragRightItem = this, this.dom.box.appendChild(t), this.dom.dragRight = t; } else this.selected || this.options.itemsAlwaysDraggable.range || !this.dom.dragRight || (this.dom.dragRight.parentNode && this.dom.dragRight.parentNode.removeChild(this.dom.dragRight), this.dom.dragRight = null); }, t.exports = n; }, function (t, e, i) {
      Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(19); const n = u(o); const s = i(6); const r = u(s); const a = i(0); const h = u(a); const d = i(1); const l = u(d); function u(t) { return t && t.__esModule ? t : { default: t }; } const c = i(2); const p = i(179).default; const f = (function () {
        function t(e, i, o) {
          const n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1; (0, h.default)(this, t), this.parent = e, this.changedOptions = [], this.container = i, this.allowCreation = !1, this.options = {}, this.initialized = !1, this.popupCounter = 0, this.defaultOptions = {
            enabled: !1, filter: !0, container: void 0, showButton: !0,
          }, c.extend(this.options, this.defaultOptions), this.configureOptions = o, this.moduleOptions = {}, this.domElements = [], this.popupDiv = {}, this.popupLimit = 5, this.popupHistory = {}, this.colorPicker = new p(n), this.wrapper = void 0;
        } return (0, l.default)(t, [{ key: 'setOptions', value(t) { if (void 0 !== t) { this.popupHistory = {}, this._removePopup(); let e = !0; typeof t === 'string' ? this.options.filter = t : t instanceof Array ? this.options.filter = t.join() : (typeof t === 'undefined' ? 'undefined' : (0, r.default)(t)) === 'object' ? (void 0 !== t.container && (this.options.container = t.container), void 0 !== t.filter && (this.options.filter = t.filter), void 0 !== t.showButton && (this.options.showButton = t.showButton), void 0 !== t.enabled && (e = t.enabled)) : typeof t === 'boolean' ? (this.options.filter = !0, e = t) : typeof t === 'function' && (this.options.filter = t, e = !0), !1 === this.options.filter && (e = !1), this.options.enabled = e; } this._clean(); } }, { key: 'setModuleOptions', value(t) { this.moduleOptions = t, !0 === this.options.enabled && (this._clean(), void 0 !== this.options.container && (this.container = this.options.container), this._create()); } }, { key: '_create', value() { const t = this; this._clean(), this.changedOptions = []; const e = this.options.filter; let i = 0; let o = !1; for (const n in this.configureOptions) this.configureOptions.hasOwnProperty(n) && (this.allowCreation = !1, o = !1, typeof e === 'function' ? (o = e(n, []), o = o || this._handleObject(this.configureOptions[n], [n], !0)) : !0 !== e && e.indexOf(n) === -1 || (o = !0), !1 !== o && (this.allowCreation = !0, i > 0 && this._makeItem([]), this._makeHeader(n), this._handleObject(this.configureOptions[n], [n])), i++); if (!0 === this.options.showButton) { const s = document.createElement('div'); s.className = 'vis-configuration vis-config-button', s.innerHTML = 'generate options', s.onclick = function () { t._printOptions(); }, s.onmouseover = function () { s.className = 'vis-configuration vis-config-button hover'; }, s.onmouseout = function () { s.className = 'vis-configuration vis-config-button'; }, this.optionsContainer = document.createElement('div'), this.optionsContainer.className = 'vis-configuration vis-config-option-container', this.domElements.push(this.optionsContainer), this.domElements.push(s); } this._push(); } }, { key: '_push', value() { this.wrapper = document.createElement('div'), this.wrapper.className = 'vis-configuration-wrapper', this.container.appendChild(this.wrapper); for (let t = 0; t < this.domElements.length; t++) this.wrapper.appendChild(this.domElements[t]); this._showPopupIfNeeded(); } }, { key: '_clean', value() { for (let t = 0; t < this.domElements.length; t++) this.wrapper.removeChild(this.domElements[t]); void 0 !== this.wrapper && (this.container.removeChild(this.wrapper), this.wrapper = void 0), this.domElements = [], this._removePopup(); } }, { key: '_getValue', value(t) { for (var e = this.moduleOptions, i = 0; i < t.length; i++) { if (void 0 === e[t[i]]) { e = void 0; break; }e = e[t[i]]; } return e; } }, { key: '_makeItem', value(t) { if (!0 === this.allowCreation) { const e = document.createElement('div'); e.className = `vis-configuration vis-config-item vis-config-s${t.length}`; for (var i = arguments.length, o = Array(i > 1 ? i - 1 : 0), n = 1; n < i; n++)o[n - 1] = arguments[n]; return o.forEach((t) => { e.appendChild(t); }), this.domElements.push(e), this.domElements.length; } return 0; } }, { key: '_makeHeader', value(t) { const e = document.createElement('div'); e.className = 'vis-configuration vis-config-header', e.innerHTML = t, this._makeItem([], e); } }, { key: '_makeLabel', value(t, e) { const i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; const o = document.createElement('div'); return o.className = `vis-configuration vis-config-label vis-config-s${e.length}`, o.innerHTML = !0 === i ? `<i><b>${t }:</b></i>` : `${t}:`, o; } }, { key: '_makeDropdown', value(t, e, i) { const o = document.createElement('select'); o.className = 'vis-configuration vis-config-select'; let n = 0; void 0 !== e && t.indexOf(e) !== -1 && (n = t.indexOf(e)); for (let s = 0; s < t.length; s++) { const r = document.createElement('option'); r.value = t[s], s === n && (r.selected = 'selected'), r.innerHTML = t[s], o.appendChild(r); } const a = this; o.onchange = function () { a._update(this.value, i); }; const h = this._makeLabel(i[i.length - 1], i); this._makeItem(i, h, o); } }, { key: '_makeRange', value(t, e, i) { const o = t[0]; const n = t[1]; const s = t[2]; const r = t[3]; const a = document.createElement('input'); a.className = 'vis-configuration vis-config-range'; try { a.type = 'range', a.min = n, a.max = s; } catch (m) {}a.step = r; let h = ''; let d = 0; if (void 0 !== e) { const l = 1.2; e < 0 && e * l < n ? (a.min = Math.ceil(e * l), d = a.min, h = 'range increased') : e / l < n && (a.min = Math.ceil(e / l), d = a.min, h = 'range increased'), e * l > s && s !== 1 && (a.max = Math.ceil(e * l), d = a.max, h = 'range increased'), a.value = e; } else a.value = o; const u = document.createElement('input'); u.className = 'vis-configuration vis-config-rangeinput', u.value = a.value; const c = this; a.onchange = function () { u.value = this.value, c._update(Number(this.value), i); }, a.oninput = function () { u.value = this.value; }; const p = this._makeLabel(i[i.length - 1], i); const f = this._makeItem(i, p, a, u); h !== '' && this.popupHistory[f] !== d && (this.popupHistory[f] = d, this._setupPopup(h, f)); } }, { key: '_setupPopup', value(t, e) { const i = this; if (!0 === this.initialized && !0 === this.allowCreation && this.popupCounter < this.popupLimit) { const o = document.createElement('div'); o.id = 'vis-configuration-popup', o.className = 'vis-configuration-popup', o.innerHTML = t, o.onclick = function () { i._removePopup(); }, this.popupCounter += 1, this.popupDiv = { html: o, index: e }; } } }, { key: '_removePopup', value() { void 0 !== this.popupDiv.html && (this.popupDiv.html.parentNode.removeChild(this.popupDiv.html), clearTimeout(this.popupDiv.hideTimeout), clearTimeout(this.popupDiv.deleteTimeout), this.popupDiv = {}); } }, { key: '_showPopupIfNeeded', value() { const t = this; if (void 0 !== this.popupDiv.html) { const e = this.domElements[this.popupDiv.index]; const i = e.getBoundingClientRect(); this.popupDiv.html.style.left = `${i.left}px`, this.popupDiv.html.style.top = `${i.top - 30}px`, document.body.appendChild(this.popupDiv.html), this.popupDiv.hideTimeout = setTimeout(() => { t.popupDiv.html.style.opacity = 0; }, 1500), this.popupDiv.deleteTimeout = setTimeout(() => { t._removePopup(); }, 1800); } } }, { key: '_makeCheckbox', value(t, e, i) { const o = document.createElement('input'); o.type = 'checkbox', o.className = 'vis-configuration vis-config-checkbox', o.checked = t, void 0 !== e && (o.checked = e, e !== t && ((typeof t === 'undefined' ? 'undefined' : (0, r.default)(t)) === 'object' ? e !== t.enabled && this.changedOptions.push({ path: i, value: e }) : this.changedOptions.push({ path: i, value: e }))); const n = this; o.onchange = function () { n._update(this.checked, i); }; const s = this._makeLabel(i[i.length - 1], i); this._makeItem(i, s, o); } }, { key: '_makeTextInput', value(t, e, i) { const o = document.createElement('input'); o.type = 'text', o.className = 'vis-configuration vis-config-text', o.value = e, e !== t && this.changedOptions.push({ path: i, value: e }); const n = this; o.onchange = function () { n._update(this.value, i); }; const s = this._makeLabel(i[i.length - 1], i); this._makeItem(i, s, o); } }, { key: '_makeColorField', value(t, e, i) { const o = this; const n = t[1]; const s = document.createElement('div'); e = void 0 === e ? n : e, e !== 'none' ? (s.className = 'vis-configuration vis-config-colorBlock', s.style.backgroundColor = e) : s.className = 'vis-configuration vis-config-colorBlock none', e = void 0 === e ? n : e, s.onclick = function () { o._showColorPicker(e, s, i); }; const r = this._makeLabel(i[i.length - 1], i); this._makeItem(i, r, s); } }, { key: '_showColorPicker', value(t, e, i) { const o = this; e.onclick = function () {}, this.colorPicker.insertTo(e), this.colorPicker.show(), this.colorPicker.setColor(t), this.colorPicker.setUpdateCallback((t) => { const n = `rgba(${  t.r  },${  t.g  },${  t.b  },${  t.a  })`; e.style.backgroundColor = n, o._update(n, i); }), this.colorPicker.setCloseCallback(() => { e.onclick = function () { o._showColorPicker(t, e, i); }; }); } }, { key: '_handleObject', value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : []; const i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; let o = !1; const n = this.options.filter; let s = !1; for (const r in t) if (t.hasOwnProperty(r)) { o = !0; const a = t[r]; const h = c.copyAndExtendArray(e, r); if (typeof n === 'function' && (o = n(r, e), !1 === o && !(a instanceof Array) && typeof a !== 'string' && typeof a !== 'boolean' && a instanceof Object && (this.allowCreation = !1, o = this._handleObject(a, h, !0), this.allowCreation = !1 === i)), !1 !== o) { s = !0; const d = this._getValue(h); if (a instanceof Array) this._handleArray(a, d, h); else if (typeof a === 'string') this._makeTextInput(a, d, h); else if (typeof a === 'boolean') this._makeCheckbox(a, d, h); else if (a instanceof Object) { let l = !0; if (e.indexOf('physics') !== -1 && this.moduleOptions.physics.solver !== r && (l = !1), !0 === l) if (void 0 !== a.enabled) { const u = c.copyAndExtendArray(h, 'enabled'); const p = this._getValue(u); if (!0 === p) { const f = this._makeLabel(r, h, !0); this._makeItem(h, f), s = this._handleObject(a, h) || s; } else this._makeCheckbox(a, p, h); } else { const m = this._makeLabel(r, h, !0); this._makeItem(h, m), s = this._handleObject(a, h) || s; } } else console.error('dont know how to handle', a, r, h); } } return s; } }, { key: '_handleArray', value(t, e, i) { typeof t[0] === 'string' && t[0] === 'color' ? (this._makeColorField(t, e, i), t[1] !== e && this.changedOptions.push({ path: i, value: e })) : typeof t[0] === 'string' ? (this._makeDropdown(t, e, i), t[0] !== e && this.changedOptions.push({ path: i, value: e })) : typeof t[0] === 'number' && (this._makeRange(t, e, i), t[0] !== e && this.changedOptions.push({ path: i, value: Number(e) })); } }, { key: '_update', value(t, e) { const i = this._constructOptions(t, e); this.parent.body && this.parent.body.emitter && this.parent.body.emitter.emit && this.parent.body.emitter.emit('configChange', i), this.initialized = !0, this.parent.setOptions(i); } }, { key: '_constructOptions', value(t, e) { const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; let o = i; t = t === 'true' || t, t = t !== 'false' && t; for (let n = 0; n < e.length; n++)e[n] !== 'global' && (void 0 === o[e[n]] && (o[e[n]] = {}), n !== e.length - 1 ? o = o[e[n]] : o[e[n]] = t); return i; } }, { key: '_printOptions', value() { const t = this.getOptions(); this.optionsContainer.innerHTML = `<pre>var options = ${(0, n.default)(t, null, 2) }</pre>`; } }, { key: 'getOptions', value() { for (var t = {}, e = 0; e < this.changedOptions.length; e++) this._constructOptions(this.changedOptions[e].value, this.changedOptions[e].path, t); return t; } }]), t;
      }()); e.default = f;
    }, function (t, e, i) {
      const o = i(6); const n = s(o); function s(t) { return t && t.__esModule ? t : { default: t }; } const r = i(14); function a(t, e) {} function h(t, e) {
        return e = typeof e === 'undefined' ? {} : e, {
          style: e.style || t.options.drawPoints.style, styles: e.styles || t.options.drawPoints.styles, size: e.size || t.options.drawPoints.size, className: e.className || t.className,
        };
      } function d(t, e) { let i = void 0; return t.options && t.options.drawPoints && t.options.drawPoints.onRender && typeof t.options.drawPoints.onRender === 'function' && (i = t.options.drawPoints.onRender), e.group.options && e.group.options.drawPoints && e.group.options.drawPoints.onRender && typeof e.group.options.drawPoints.onRender === 'function' && (i = e.group.options.drawPoints.onRender), i; }a.draw = function (t, e, i, o) { o = o || 0; for (let s = d(i, e), a = 0; a < t.length; a++) if (s) { const l = s(t[a], e); !0 !== l && (typeof l === 'undefined' ? 'undefined' : (0, n.default)(l)) !== 'object' || r.drawPoint(t[a].screen_x + o, t[a].screen_y, h(e, l), i.svgElements, i.svg, t[a].label); } else r.drawPoint(t[a].screen_x + o, t[a].screen_y, h(e), i.svgElements, i.svg, t[a].label); }, a.drawIcon = function (t, e, i, o, n, s) { const a = 0.5 * n; const d = r.getSVGElement('rect', s.svgElements, s.svg); d.setAttributeNS(null, 'x', e), d.setAttributeNS(null, 'y', i - a), d.setAttributeNS(null, 'width', o), d.setAttributeNS(null, 'height', 2 * a), d.setAttributeNS(null, 'class', 'vis-outline'), r.drawPoint(e + 0.5 * o, i, h(t), s.svgElements, s.svg); }, t.exports = a;
    }, function (t, e, i) { Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(3); const n = m(o); const s = i(0); const r = m(s); const a = i(1); const h = m(a); const d = i(4); const l = m(d); const u = i(5); const c = m(u); const p = i(23); const f = m(p); function m(t) { return t && t.__esModule ? t : { default: t }; } const v = (function (t) { function e(t, i, o) { (0, r.default)(this, e); const s = (0, l.default)(this, (e.__proto__ || (0, n.default)(e)).call(this, t, i, o)); return s.labelOffset = 0, s.selected = !1, s; } return (0, c.default)(e, t), (0, h.default)(e, [{ key: 'setOptions', value(t, e, i) { this.options = t, void 0 === e && void 0 === i || this.setImages(e, i); } }, { key: 'setImages', value(t, e) { e && this.selected ? (this.imageObj = e, this.imageObjAlt = t) : (this.imageObj = t, this.imageObjAlt = e); } }, { key: 'switchImages', value(t) { const e = t && !this.selected || !t && this.selected; if (this.selected = t, void 0 !== this.imageObjAlt && e) { const i = this.imageObj; this.imageObj = this.imageObjAlt, this.imageObjAlt = i; } } }, { key: '_resizeImage', value() { let t; let e; if (!1 === this.options.shapeProperties.useImageSize) { let i = 1; let o = 1; this.imageObj.width && this.imageObj.height && (this.imageObj.width > this.imageObj.height ? i = this.imageObj.width / this.imageObj.height : o = this.imageObj.height / this.imageObj.width), t = 2 * this.options.size * i, e = 2 * this.options.size * o; } else t = this.imageObj.width, e = this.imageObj.height; this.width = t, this.height = e, this.radius = 0.5 * this.width; } }, { key: '_drawRawCircle', value(t, e, i, o) { this.initContextForDraw(t, o), t.circle(e, i, o.size), this.performFill(t, o); } }, { key: '_drawImageAtPosition', value(t, e) { if (this.imageObj.width != 0) { t.globalAlpha = 1, this.enableShadow(t, e); let i = 1; !0 === this.options.shapeProperties.interpolation && (i = this.imageObj.width / this.width / this.body.view.scale), this.imageObj.drawImageAtPosition(t, i, this.left, this.top, this.width, this.height), this.disableShadow(t, e); } } }, { key: '_drawImageLabel', value(t, e, i, o, n) { let s; let r = 0; if (void 0 !== this.height) { r = 0.5 * this.height; const a = this.labelModule.getTextSize(t, o, n); a.lineCount >= 1 && (r += a.height / 2); }s = i + r, this.options.label && (this.labelOffset = r), this.labelModule.draw(t, e, s, o, n, 'hanging'); } }]), e; }(f.default)); e.default = v; }, function (t, e, i) {
      Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(19); const n = p(o); const s = i(6); const r = p(s); const a = i(29); const h = p(a); const d = i(0); const l = p(d); const u = i(1); const c = p(u); function p(t) { return t && t.__esModule ? t : { default: t }; } const f = i(2); const m = i(117).default; const v = i(48).default; const g = i(215).default; const y = i(217).default; const b = i(218).default; const _ = i(219).default; const w = (function () {
        function t(e, i, o, n) { if ((0, l.default)(this, t), void 0 === i) throw new Error('No body provided'); this.options = f.bridgeObject(o), this.globalOptions = o, this.defaultOptions = n, this.body = i, this.id = void 0, this.fromId = void 0, this.toId = void 0, this.selected = !1, this.hover = !1, this.labelDirty = !0, this.baseWidth = this.options.width, this.baseFontSize = this.options.font.size, this.from = void 0, this.to = void 0, this.edgeType = void 0, this.connected = !1, this.labelModule = new m(this.body, this.options, !0), this.setOptions(e); } return (0, c.default)(t, [{ key: 'setOptions', value(e) { if (e) { t.parseOptions(this.options, e, !0, this.globalOptions), void 0 !== e.id && (this.id = e.id), void 0 !== e.from && (this.fromId = e.from), void 0 !== e.to && (this.toId = e.to), void 0 !== e.title && (this.title = e.title), void 0 !== e.value && (e.value = parseFloat(e.value)); const i = [e, this.options, this.defaultOptions]; this.chooser = v.choosify('edge', i), this.updateLabelModule(e); let o = this.updateEdgeType(); return this._setInteractionWidths(), this.connect(), void 0 === e.hidden && void 0 === e.physics || (o = !0), o; } } }, {
          key: 'getFormattingValues',
          value() {
            const t = !0 === this.options.arrows.to || !0 === this.options.arrows.to.enabled; const e = !0 === this.options.arrows.from || !0 === this.options.arrows.from.enabled; const i = !0 === this.options.arrows.middle || !0 === this.options.arrows.middle.enabled; const o = this.options.color.inherit; const n = {
              toArrow: t, toArrowScale: this.options.arrows.to.scaleFactor, toArrowType: this.options.arrows.to.type, middleArrow: i, middleArrowScale: this.options.arrows.middle.scaleFactor, middleArrowType: this.options.arrows.middle.type, fromArrow: e, fromArrowScale: this.options.arrows.from.scaleFactor, fromArrowType: this.options.arrows.from.type, arrowStrikethrough: this.options.arrowStrikethrough, color: o ? void 0 : this.options.color.color, inheritsColor: o, opacity: this.options.color.opacity, hidden: this.options.hidden, length: this.options.length, shadow: this.options.shadow.enabled, shadowColor: this.options.shadow.color, shadowSize: this.options.shadow.size, shadowX: this.options.shadow.x, shadowY: this.options.shadow.y, dashes: this.options.dashes, width: this.options.width,
            }; if (this.selected || this.hover) if (!0 === this.chooser) { if (this.selected) { const s = this.options.selectionWidth; typeof s === 'function' ? n.width = s(n.width) : typeof s === 'number' && (n.width += s), n.width = Math.max(n.width, 0.3 / this.body.view.scale), n.color = this.options.color.highlight, n.shadow = this.options.shadow.enabled; } else if (this.hover) { const r = this.options.hoverWidth; typeof r === 'function' ? n.width = r(n.width) : typeof r === 'number' && (n.width += r), n.width = Math.max(n.width, 0.3 / this.body.view.scale), n.color = this.options.color.hover, n.shadow = this.options.shadow.enabled; } } else typeof this.chooser === 'function' && (this.chooser(n, this.options.id, this.selected, this.hover), void 0 !== n.color && (n.inheritsColor = !1), !1 === n.shadow && (n.shadowColor === this.options.shadow.color && n.shadowSize === this.options.shadow.size && n.shadowX === this.options.shadow.x && n.shadowY === this.options.shadow.y || (n.shadow = !0))); else n.shadow = this.options.shadow.enabled, n.width = Math.max(n.width, 0.3 / this.body.view.scale); return n;
          }, 
        }, { key: 'updateLabelModule', value(t) { const e = [t, this.options, this.globalOptions, this.defaultOptions]; this.labelModule.update(this.options, e), void 0 !== this.labelModule.baseSize && (this.baseFontSize = this.labelModule.baseSize); } }, { key: 'updateEdgeType', value() { const t = this.options.smooth; let e = !1; let i = !0; return void 0 !== this.edgeType && ((this.edgeType instanceof y && !0 === t.enabled && t.type === 'dynamic' || this.edgeType instanceof g && !0 === t.enabled && t.type === 'cubicBezier' || this.edgeType instanceof b && !0 === t.enabled && t.type !== 'dynamic' && t.type !== 'cubicBezier' || this.edgeType instanceof _ && !1 === t.type.enabled) && (i = !1), !0 === i && (e = this.cleanup())), !0 === i ? !0 === t.enabled ? t.type === 'dynamic' ? (e = !0, this.edgeType = new y(this.options, this.body, this.labelModule)) : t.type === 'cubicBezier' ? this.edgeType = new g(this.options, this.body, this.labelModule) : this.edgeType = new b(this.options, this.body, this.labelModule) : this.edgeType = new _(this.options, this.body, this.labelModule) : this.edgeType.setOptions(this.options), e; } }, { key: 'connect', value() { this.disconnect(), this.from = this.body.nodes[this.fromId] || void 0, this.to = this.body.nodes[this.toId] || void 0, this.connected = void 0 !== this.from && void 0 !== this.to, !0 === this.connected ? (this.from.attachEdge(this), this.to.attachEdge(this)) : (this.from && this.from.detachEdge(this), this.to && this.to.detachEdge(this)), this.edgeType.connect(); } }, { key: 'disconnect', value() { this.from && (this.from.detachEdge(this), this.from = void 0), this.to && (this.to.detachEdge(this), this.to = void 0), this.connected = !1; } }, { key: 'getTitle', value() { return this.title; } }, { key: 'isSelected', value() { return this.selected; } }, { key: 'getValue', value() { return this.options.value; } }, { key: 'setValueRange', value(t, e, i) { if (void 0 !== this.options.value) { const o = this.options.scaling.customScalingFunction(t, e, i, this.options.value); const n = this.options.scaling.max - this.options.scaling.min; if (!0 === this.options.scaling.label.enabled) { const s = this.options.scaling.label.max - this.options.scaling.label.min; this.options.font.size = this.options.scaling.label.min + o * s; } this.options.width = this.options.scaling.min + o * n; } else this.options.width = this.baseWidth, this.options.font.size = this.baseFontSize; this._setInteractionWidths(), this.updateLabelModule(); } }, { key: '_setInteractionWidths', value() { typeof this.options.hoverWidth === 'function' ? this.edgeType.hoverWidth = this.options.hoverWidth(this.options.width) : this.edgeType.hoverWidth = this.options.hoverWidth + this.options.width, typeof this.options.selectionWidth === 'function' ? this.edgeType.selectionWidth = this.options.selectionWidth(this.options.width) : this.edgeType.selectionWidth = this.options.selectionWidth + this.options.width; } }, { key: 'draw', value(t) { const e = this.getFormattingValues(); if (!e.hidden) { const i = this.edgeType.getViaNode(); const o = {}; this.edgeType.fromPoint = this.edgeType.from, this.edgeType.toPoint = this.edgeType.to, e.fromArrow && (o.from = this.edgeType.getArrowData(t, 'from', i, this.selected, this.hover, e), !1 === e.arrowStrikethrough && (this.edgeType.fromPoint = o.from.core)), e.toArrow && (o.to = this.edgeType.getArrowData(t, 'to', i, this.selected, this.hover, e), !1 === e.arrowStrikethrough && (this.edgeType.toPoint = o.to.core)), e.middleArrow && (o.middle = this.edgeType.getArrowData(t, 'middle', i, this.selected, this.hover, e)), this.edgeType.drawLine(t, e, this.selected, this.hover, i), this.drawArrows(t, o, e), this.drawLabel(t, i); } } }, { key: 'drawArrows', value(t, e, i) { i.fromArrow && this.edgeType.drawArrowHead(t, i, this.selected, this.hover, e.from), i.middleArrow && this.edgeType.drawArrowHead(t, i, this.selected, this.hover, e.middle), i.toArrow && this.edgeType.drawArrowHead(t, i, this.selected, this.hover, e.to); } }, { key: 'drawLabel', value(t, e) { if (void 0 !== this.options.label) { const i = this.from; const o = this.to; if (this.labelModule.differentState(this.selected, this.hover) && this.labelModule.getTextSize(t, this.selected, this.hover), i.id != o.id) { this.labelModule.pointToSelf = !1; var n = this.edgeType.getPoint(0.5, e); t.save(); const s = this._getRotation(t); s.angle != 0 && (t.translate(s.x, s.y), t.rotate(s.angle)), this.labelModule.draw(t, n.x, n.y, this.selected, this.hover), t.restore(); } else { let r; let a; this.labelModule.pointToSelf = !0; const h = this.options.selfReferenceSize; i.shape.width > i.shape.height ? (r = i.x + 0.5 * i.shape.width, a = i.y - h) : (r = i.x + h, a = i.y - 0.5 * i.shape.height), n = this._pointOnCircle(r, a, h, 0.125), this.labelModule.draw(t, n.x, n.y, this.selected, this.hover); } } } }, { key: 'getItemsOnPoint', value(t) { const e = []; if (this.labelModule.visible()) { const i = this._getRotation(); v.pointInRect(this.labelModule.getSize(), t, i) && e.push({ edgeId: this.id, labelId: 0 }); } const o = { left: t.x, top: t.y }; return this.isOverlappingWith(o) && e.push({ edgeId: this.id }), e; } }, { key: 'isOverlappingWith', value(t) { if (this.connected) { const e = 10; const i = this.from.x; const o = this.from.y; const n = this.to.x; const s = this.to.y; const r = t.left; const a = t.top; const h = this.edgeType.getDistanceToEdge(i, o, n, s, r, a); return h < e; } return !1; } }, { key: '_getRotation', value(t) { const e = this.edgeType.getViaNode(); const i = this.edgeType.getPoint(0.5, e); void 0 !== t && this.labelModule.calculateLabelSize(t, this.selected, this.hover, i.x, i.y); const o = { x: i.x, y: this.labelModule.size.yLine, angle: 0 }; if (!this.labelModule.visible()) return o; if (this.options.font.align === 'horizontal') return o; const n = this.from.y - this.to.y; const s = this.from.x - this.to.x; let r = Math.atan2(n, s); return (r < -1 && s < 0 || r > 0 && s < 0) && (r += Math.PI), o.angle = r, o; } }, { key: '_pointOnCircle', value(t, e, i, o) { const n = 2 * o * Math.PI; return { x: t + i * Math.cos(n), y: e - i * Math.sin(n) }; } }, { key: 'select', value() { this.selected = !0; } }, { key: 'unselect', value() { this.selected = !1; } }, { key: 'cleanup', value() { return this.edgeType.cleanup(); } }, { key: 'remove', value() { this.cleanup(), this.disconnect(), delete this.body.edges[this.id]; } }, { key: 'endPointsValid', value() { return void 0 !== this.body.nodes[this.fromId] && void 0 !== this.body.nodes[this.toId]; } }], [{ key: 'parseOptions', value(t, e) { const i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; const o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}; const s = arguments.length > 4 && void 0 !== arguments[4] && arguments[4]; const a = ['arrowStrikethrough', 'id', 'from', 'hidden', 'hoverWidth', 'labelHighlightBold', 'length', 'line', 'opacity', 'physics', 'scaling', 'selectionWidth', 'selfReferenceSize', 'to', 'title', 'value', 'width', 'font', 'chosen', 'widthConstraint']; if (f.selectiveDeepExtend(a, t, e, i), v.isValidLabel(e.label) ? t.label = e.label : t.label = void 0, f.mergeOptions(t, e, 'smooth', o), f.mergeOptions(t, e, 'shadow', o), void 0 !== e.dashes && e.dashes !== null ? t.dashes = e.dashes : !0 === i && e.dashes === null && (t.dashes = (0, h.default)(o.dashes)), void 0 !== e.scaling && e.scaling !== null ? (void 0 !== e.scaling.min && (t.scaling.min = e.scaling.min), void 0 !== e.scaling.max && (t.scaling.max = e.scaling.max), f.mergeOptions(t.scaling, e.scaling, 'label', o.scaling)) : !0 === i && e.scaling === null && (t.scaling = (0, h.default)(o.scaling)), void 0 !== e.arrows && e.arrows !== null) if (typeof e.arrows === 'string') { const d = e.arrows.toLowerCase(); t.arrows.to.enabled = d.indexOf('to') != -1, t.arrows.middle.enabled = d.indexOf('middle') != -1, t.arrows.from.enabled = d.indexOf('from') != -1; } else { if ((0, r.default)(e.arrows) !== 'object') throw new Error(`The arrow newOptions can only be an object or a string. Refer to the documentation. You used:${(0, n.default)(e.arrows)}`); f.mergeOptions(t.arrows, e.arrows, 'to', o.arrows), f.mergeOptions(t.arrows, e.arrows, 'middle', o.arrows), f.mergeOptions(t.arrows, e.arrows, 'from', o.arrows); } else !0 === i && e.arrows === null && (t.arrows = (0, h.default)(o.arrows)); if (void 0 !== e.color && e.color !== null) { const l = e.color; const u = t.color; if (s)f.deepExtend(u, o.color, !1, i); else for (const c in u)u.hasOwnProperty(c) && delete u[c]; if (f.isString(u))u.color = u, u.highlight = u, u.hover = u, u.inherit = !1, void 0 === l.opacity && (u.opacity = 1); else { let p = !1; void 0 !== l.color && (u.color = l.color, p = !0), void 0 !== l.highlight && (u.highlight = l.highlight, p = !0), void 0 !== l.hover && (u.hover = l.hover, p = !0), void 0 !== l.inherit && (u.inherit = l.inherit), void 0 !== l.opacity && (u.opacity = Math.min(1, Math.max(0, l.opacity))), !0 === p ? u.inherit = !1 : void 0 === u.inherit && (u.inherit = 'from'); } } else !0 === i && e.color === null && (t.color = f.bridgeObject(o.color)); !0 === i && e.font === null && (t.font = f.bridgeObject(o.font)); } }]), t;
      }()); e.default = w;
    }, function (t, e, i) { Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(3); const n = m(o); const s = i(0); const r = m(s); const a = i(1); const h = m(a); const d = i(4); const l = m(d); const u = i(5); const c = m(u); const p = i(118); const f = m(p); function m(t) { return t && t.__esModule ? t : { default: t }; } const v = (function (t) { function e(t, i, o) { return (0, r.default)(this, e), (0, l.default)(this, (e.__proto__ || (0, n.default)(e)).call(this, t, i, o)); } return (0, c.default)(e, t), (0, h.default)(e, [{ key: '_findBorderPositionBezier', value(t, e) { let i; let o; let n; let s; let r; const a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this._getViaCoordinates(); const h = 10; let d = 0; let l = 0; let u = 1; const c = 0.2; let p = this.to; let f = !1; t.id === this.from.id && (p = this.from, f = !0); while (l <= u && d < h) { var m = 0.5 * (l + u); if (i = this.getPoint(m, a), o = Math.atan2(p.y - i.y, p.x - i.x), n = p.distanceToBorder(e, o), s = Math.sqrt(Math.pow(i.x - p.x, 2) + Math.pow(i.y - p.y, 2)), r = n - s, Math.abs(r) < c) break; r < 0 ? !1 === f ? l = m : u = m : !1 === f ? u = m : l = m, d++; } return i.t = m, i; } }, { key: '_getDistanceToBezierEdge', value(t, e, i, o, n, s, r) { let a = 1e9; let h = void 0; let d = void 0; let l = void 0; let u = void 0; let c = void 0; let p = t; let f = e; for (d = 1; d < 10; d++)l = 0.1 * d, u = Math.pow(1 - l, 2) * t + 2 * l * (1 - l) * r.x + Math.pow(l, 2) * i, c = Math.pow(1 - l, 2) * e + 2 * l * (1 - l) * r.y + Math.pow(l, 2) * o, d > 0 && (h = this._getDistanceToLine(p, f, u, c, n, s), a = h < a ? h : a), p = u, f = c; return a; } }, { key: '_bezierCurve', value(t, e, i, o) { const n = void 0 !== i && void 0 !== i.x; const s = void 0 !== o && void 0 !== o.x; t.beginPath(), t.moveTo(this.fromPoint.x, this.fromPoint.y), n && s ? t.bezierCurveTo(i.x, i.y, o.x, o.y, this.toPoint.x, this.toPoint.y) : n ? t.quadraticCurveTo(i.x, i.y, this.toPoint.x, this.toPoint.y) : t.lineTo(this.toPoint.x, this.toPoint.y), this.enableShadow(t, e), t.stroke(), this.disableShadow(t, e); } }, { key: 'getViaNode', value() { return this._getViaCoordinates(); } }]), e; }(f.default)); e.default = v; }, function (t, e, i) {
      Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(0); const n = a(o); const s = i(1); const r = a(s); function a(t) { return t && t.__esModule ? t : { default: t }; } const h = i(2); const d = (function () {
        function t() { (0, n.default)(this, t); } return (0, r.default)(t, null, [{
          key: 'getRange',
          value(t) {
            let e; const i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : []; let o = 1e9; let n = -1e9; let s = 1e9; let r = -1e9; if (i.length > 0) for (let a = 0; a < i.length; a++)e = t[i[a]], s > e.shape.boundingBox.left && (s = e.shape.boundingBox.left), r < e.shape.boundingBox.right && (r = e.shape.boundingBox.right), o > e.shape.boundingBox.top && (o = e.shape.boundingBox.top), n < e.shape.boundingBox.bottom && (n = e.shape.boundingBox.bottom); return s === 1e9 && r === -1e9 && o === 1e9 && n === -1e9 && (o = 0, n = 0, s = 0, r = 0), {
              minX: s, maxX: r, minY: o, maxY: n,
            };
          }, 
        }, {
          key: 'getRangeCore',
          value(t) {
            let e; const i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : []; let o = 1e9; let n = -1e9; let s = 1e9; let r = -1e9; if (i.length > 0) for (let a = 0; a < i.length; a++)e = t[i[a]], s > e.x && (s = e.x), r < e.x && (r = e.x), o > e.y && (o = e.y), n < e.y && (n = e.y); return s === 1e9 && r === -1e9 && o === 1e9 && n === -1e9 && (o = 0, n = 0, s = 0, r = 0), {
              minX: s, maxX: r, minY: o, maxY: n,
            };
          }, 
        }, { key: 'findCenter', value(t) { return { x: 0.5 * (t.maxX + t.minX), y: 0.5 * (t.maxY + t.minY) }; } }, { key: 'cloneOptions', value(t, e) { const i = {}; return void 0 === e || e === 'node' ? (h.deepExtend(i, t.options, !0), i.x = t.x, i.y = t.y, i.amountOfConnections = t.edges.length) : h.deepExtend(i, t.options, !0), i; } }]), t;
      }()); e.default = d;
    }, function (t, e, i) { t.exports = { default: i(124), __esModule: !0 }; }, function (t, e, i) { const o = i(50); t.exports = Object('z').propertyIsEnumerable(0) ? Object : function (t) { return o(t) == 'String' ? t.split('') : Object(t); }; }, function (t, e, i) { const o = i(52); const n = i(17); const s = i(83); const r = i(26); const a = i(22); const h = i(31); const d = i(129); const l = i(59); const u = i(85); const c = i(13)('iterator'); const p = !([].keys && 'next' in [].keys()); const f = '@@iterator'; const m = 'keys'; const v = 'values'; const g = function () { return this; }; t.exports = function (t, e, i, y, b, _, w) { d(i, e, y); let x; let k; let D; const S = function (t) { if (!p && t in E) return E[t]; switch (t) { case m: return function () { return new i(this, t); }; case v: return function () { return new i(this, t); }; } return function () { return new i(this, t); }; }; const C = `${e} Iterator`; const M = b == v; let O = !1; var E = t.prototype; const T = E[c] || E[f] || b && E[b]; let P = T || S(b); const I = b ? M ? S('entries') : P : void 0; const N = e == 'Array' && E.entries || T; if (N && (D = u(N.call(new t())), D !== Object.prototype && D.next && (l(D, C, !0), o || a(D, c) || r(D, c, g))), M && T && T.name !== v && (O = !0, P = function () { return T.call(this); }), o && !w || !p && !O && E[c] || r(E, c, P), h[e] = P, h[C] = g, b) if (x = { values: M ? P : S(v), keys: _ ? P : S(m), entries: I }, w) for (k in x)k in E || s(E, k, x[k]); else n(n.P + n.F * (p || O), e, x); return x; }; }, function (t, e, i) { const o = i(128); t.exports = function (t, e, i) { if (o(t), void 0 === e) return t; switch (i) { case 1: return function (i) { return t.call(e, i); }; case 2: return function (i, o) { return t.call(e, i, o); }; case 3: return function (i, o, n) { return t.call(e, i, o, n); }; } return function () { return t.apply(e, arguments); }; }; }, function (t, e, i) { t.exports = !i(21) && !i(28)(() => Object.defineProperty(i(82)('div'), 'a', { get() { return 7; } }).a != 7); }, function (t, e, i) { const o = i(32); const n = i(18).document; const s = o(n) && o(n.createElement); t.exports = function (t) { return s ? n.createElement(t) : {}; }; }, function (t, e, i) { t.exports = i(26); }, function (t, e, i) { const o = i(22); const n = i(25); const s = i(131)(!1); const r = i(56)('IE_PROTO'); t.exports = function (t, e) { let i; const a = n(t); let h = 0; const d = []; for (i in a)i != r && o(a, i) && d.push(i); while (e.length > h)o(a, i = e[h++]) && (~s(d, i) || d.push(i)); return d; }; }, function (t, e, i) { const o = i(22); const n = i(41); const s = i(56)('IE_PROTO'); const r = Object.prototype; t.exports = Object.getPrototypeOf || function (t) { return t = n(t), o(t, s) ? t[s] : typeof t.constructor === 'function' && t instanceof t.constructor ? t.constructor.prototype : t instanceof Object ? r : null; }; }, function (t, e, i) { const o = i(50); const n = i(13)('toStringTag'); const s = o(function () { return arguments; }()) == 'Arguments'; const r = function (t, e) { try { return t[e]; } catch (i) {} }; t.exports = function (t) { let e; let i; let a; return void 0 === t ? 'Undefined' : t === null ? 'Null' : typeof (i = r(e = Object(t), n)) === 'string' ? i : s ? o(e) : (a = o(e)) == 'Object' && typeof e.callee === 'function' ? 'Arguments' : a; }; }, function (t, e, i) { const o = i(17); const n = i(7); const s = i(28); t.exports = function (t, e) { const i = (n.Object || {})[t] || Object[t]; const r = {}; r[t] = e(i), o(o.S + o.F * s(() => { i(1); }), 'Object', r); }; }, function (t, e, i) { const o = i(84); const n = i(58).concat('length', 'prototype'); e.f = Object.getOwnPropertyNames || function (t) { return o(t, n); }; }, function (t, e, i) { const o = i(42); const n = i(39); const s = i(25); const r = i(53); const a = i(22); const h = i(81); const d = Object.getOwnPropertyDescriptor; e.f = i(21) ? d : function (t, e) { if (t = s(t), e = r(e, !0), h) try { return d(t, e); } catch (i) {} if (a(t, e)) return n(!o.f.call(t, e), t[e]); }; }, function (t, e, i) { t.exports = { default: i(162), __esModule: !0 }; }, function (t, e, i) { function o(t, e) { this.x = void 0 !== t ? t : 0, this.y = void 0 !== e ? e : 0; }t.exports = o; }, function (t, e, i) {
      const o = i(2); function n(t, e) { if (void 0 === t) throw new Error('No container element defined'); if (this.container = t, this.visible = !e || void 0 == e.visible || e.visible, this.visible) { this.frame = document.createElement('DIV'), this.frame.style.width = '100%', this.frame.style.position = 'relative', this.container.appendChild(this.frame), this.frame.prev = document.createElement('INPUT'), this.frame.prev.type = 'BUTTON', this.frame.prev.value = 'Prev', this.frame.appendChild(this.frame.prev), this.frame.play = document.createElement('INPUT'), this.frame.play.type = 'BUTTON', this.frame.play.value = 'Play', this.frame.appendChild(this.frame.play), this.frame.next = document.createElement('INPUT'), this.frame.next.type = 'BUTTON', this.frame.next.value = 'Next', this.frame.appendChild(this.frame.next), this.frame.bar = document.createElement('INPUT'), this.frame.bar.type = 'BUTTON', this.frame.bar.style.position = 'absolute', this.frame.bar.style.border = '1px solid red', this.frame.bar.style.width = '100px', this.frame.bar.style.height = '6px', this.frame.bar.style.borderRadius = '2px', this.frame.bar.style.MozBorderRadius = '2px', this.frame.bar.style.border = '1px solid #7F7F7F', this.frame.bar.style.backgroundColor = '#E5E5E5', this.frame.appendChild(this.frame.bar), this.frame.slide = document.createElement('INPUT'), this.frame.slide.type = 'BUTTON', this.frame.slide.style.margin = '0px', this.frame.slide.value = ' ', this.frame.slide.style.position = 'relative', this.frame.slide.style.left = '-100px', this.frame.appendChild(this.frame.slide); const i = this; this.frame.slide.onmousedown = function (t) { i._onMouseDown(t); }, this.frame.prev.onclick = function (t) { i.prev(t); }, this.frame.play.onclick = function (t) { i.togglePlay(t); }, this.frame.next.onclick = function (t) { i.next(t); }; } this.onChangeCallback = void 0, this.values = [], this.index = void 0, this.playTimeout = void 0, this.playInterval = 1e3, this.playLoop = !0; }n.prototype.prev = function () { let t = this.getIndex(); t > 0 && (t--, this.setIndex(t)); }, n.prototype.next = function () { let t = this.getIndex(); t < this.values.length - 1 && (t++, this.setIndex(t)); }, n.prototype.playNext = function () {
        const t = new Date(); let
          e = this.getIndex(); e < this.values.length - 1 ? (e++, this.setIndex(e)) : this.playLoop && (e = 0, this.setIndex(e)); const i = new Date(); const o = i - t; const n = Math.max(this.playInterval - o, 0); const
          s = this; this.playTimeout = setTimeout(() => { s.playNext(); }, n);
      }, n.prototype.togglePlay = function () { void 0 === this.playTimeout ? this.play() : this.stop(); }, n.prototype.play = function () { this.playTimeout || (this.playNext(), this.frame && (this.frame.play.value = 'Stop')); }, n.prototype.stop = function () { clearInterval(this.playTimeout), this.playTimeout = void 0, this.frame && (this.frame.play.value = 'Play'); }, n.prototype.setOnChangeCallback = function (t) { this.onChangeCallback = t; }, n.prototype.setPlayInterval = function (t) { this.playInterval = t; }, n.prototype.getPlayInterval = function () { return this.playInterval; }, n.prototype.setPlayLoop = function (t) { this.playLoop = t; }, n.prototype.onChange = function () { void 0 !== this.onChangeCallback && this.onChangeCallback(); }, n.prototype.redraw = function () { if (this.frame) { this.frame.bar.style.top = `${this.frame.clientHeight / 2 - this.frame.bar.offsetHeight / 2}px`, this.frame.bar.style.width = `${this.frame.clientWidth - this.frame.prev.clientWidth - this.frame.play.clientWidth - this.frame.next.clientWidth - 30}px`; const t = this.indexToLeft(this.index); this.frame.slide.style.left = `${t}px`; } }, n.prototype.setValues = function (t) { this.values = t, this.values.length > 0 ? this.setIndex(0) : this.index = void 0; }, n.prototype.setIndex = function (t) { if (!(t < this.values.length)) throw new Error('Index out of range'); this.index = t, this.redraw(), this.onChange(); }, n.prototype.getIndex = function () { return this.index; }, n.prototype.get = function () { return this.values[this.index]; }, n.prototype._onMouseDown = function (t) { const e = t.which ? t.which === 1 : t.button === 1; if (e) { this.startClientX = t.clientX, this.startSlideX = parseFloat(this.frame.slide.style.left), this.frame.style.cursor = 'move'; const i = this; this.onmousemove = function (t) { i._onMouseMove(t); }, this.onmouseup = function (t) { i._onMouseUp(t); }, o.addEventListener(document, 'mousemove', this.onmousemove), o.addEventListener(document, 'mouseup', this.onmouseup), o.preventDefault(t); } }, n.prototype.leftToIndex = function (t) { const e = parseFloat(this.frame.bar.style.width) - this.frame.slide.clientWidth - 10; const i = t - 3; let o = Math.round(i / e * (this.values.length - 1)); return o < 0 && (o = 0), o > this.values.length - 1 && (o = this.values.length - 1), o; }, n.prototype.indexToLeft = function (t) { const e = parseFloat(this.frame.bar.style.width) - this.frame.slide.clientWidth - 10; const i = t / (this.values.length - 1) * e; const o = i + 3; return o; }, n.prototype._onMouseMove = function (t) { const e = t.clientX - this.startClientX; const i = this.startSlideX + e; const n = this.leftToIndex(i); this.setIndex(n), o.preventDefault(); }, n.prototype._onMouseUp = function (t) { this.frame.style.cursor = 'auto', o.removeEventListener(document, 'mousemove', this.onmousemove), o.removeEventListener(document, 'mouseup', this.onmouseup), o.preventDefault(); }, t.exports = n;
    }, function (t, e, i) { function o(t, e, i, o) { this._start = 0, this._end = 0, this._step = 1, this.prettyStep = !0, this.precision = 5, this._current = 0, this.setRange(t, e, i, o); }o.prototype.isNumeric = function (t) { return !isNaN(parseFloat(t)) && isFinite(t); }, o.prototype.setRange = function (t, e, i, o) { if (!this.isNumeric(t)) throw new Error(`Parameter 'start' is not numeric; value: ${t}`); if (!this.isNumeric(e)) throw new Error(`Parameter 'end' is not numeric; value: ${t}`); if (!this.isNumeric(i)) throw new Error(`Parameter 'step' is not numeric; value: ${t}`); this._start = t || 0, this._end = e || 0, this.setStep(i, o); }, o.prototype.setStep = function (t, e) { void 0 === t || t <= 0 || (void 0 !== e && (this.prettyStep = e), !0 === this.prettyStep ? this._step = o.calculatePrettyStep(t) : this._step = t); }, o.calculatePrettyStep = function (t) { const e = function (t) { return Math.log(t) / Math.LN10; }; const i = Math.pow(10, Math.round(e(t))); const o = 2 * Math.pow(10, Math.round(e(t / 2))); const n = 5 * Math.pow(10, Math.round(e(t / 5))); let s = i; return Math.abs(o - t) <= Math.abs(s - t) && (s = o), Math.abs(n - t) <= Math.abs(s - t) && (s = n), s <= 0 && (s = 1), s; }, o.prototype.getCurrent = function () { return parseFloat(this._current.toPrecision(this.precision)); }, o.prototype.getStep = function () { return this._step; }, o.prototype.start = function (t) { void 0 === t && (t = !1), this._current = this._start - this._start % this._step, t && this.getCurrent() < this._start && this.next(); }, o.prototype.next = function () { this._current += this._step; }, o.prototype.end = function () { return this._current > this._end; }, t.exports = o; }, function (t, e, i) {
      const o = i(6); const n = s(o); function s(t) { return t && t.__esModule ? t : { default: t }; } const r = i(2); const a = i(95); const h = i(34); const d = {
        BAR: 0, BARCOLOR: 1, BARSIZE: 2, DOT: 3, DOTLINE: 4, DOTCOLOR: 5, DOTSIZE: 6, GRID: 7, LINE: 8, SURFACE: 9,
      }; const l = {
        dot: d.DOT, 'dot-line': d.DOTLINE, 'dot-color': d.DOTCOLOR, 'dot-size': d.DOTSIZE, line: d.LINE, grid: d.GRID, surface: d.SURFACE, bar: d.BAR, 'bar-color': d.BARCOLOR, 'bar-size': d.BARSIZE,
      }; const u = ['width', 'height', 'filterLabel', 'legendLabel', 'xLabel', 'yLabel', 'zLabel', 'xValueLabel', 'yValueLabel', 'zValueLabel', 'showXAxis', 'showYAxis', 'showZAxis', 'showGrid', 'showPerspective', 'showShadow', 'keepAspectRatio', 'verticalRatio', 'dotSizeRatio', 'dotSizeMinFraction', 'dotSizeMaxFraction', 'showAnimationControls', 'animationInterval', 'animationPreload', 'animationAutoStart', 'axisColor', 'gridColor', 'xCenter', 'yCenter']; const c = ['xBarWidth', 'yBarWidth', 'valueMin', 'valueMax', 'xMin', 'xMax', 'xStep', 'yMin', 'yMax', 'yStep', 'zMin', 'zMax', 'zStep']; let p = void 0; function f(t) { for (const e in t) if (t.hasOwnProperty(e)) return !1; return !0; } function m(t) { return void 0 === t || t === '' || typeof t !== 'string' ? t : t.charAt(0).toUpperCase() + t.slice(1); } function v(t, e) { return void 0 === t || t === '' ? e : t + m(e); } function g(t, e, i, o) { for (var n, s, r = 0; r < i.length; ++r)n = i[r], s = v(o, n), e[s] = t[n]; } function y(t, e, i, o) { for (var n, s, r = 0; r < i.length; ++r)n = i[r], void 0 !== t[n] && (s = v(o, n), e[s] = t[n]); } function b(t, e) { if (void 0 === t || f(t)) throw new Error('No DEFAULTS passed'); if (void 0 === e) throw new Error('No dst passed'); p = t, g(t, e, u), g(t, e, c, 'default'), w(t, e), e.margin = 10, e.showGrayBottom = !1, e.showTooltip = !1, e.onclick_callback = null, e.eye = new h(0, 0, -1); } function _(t, e) { if (void 0 !== t) { if (void 0 === e) throw new Error('No dst passed'); if (void 0 === p || f(p)) throw new Error('DEFAULTS not set for module Settings'); y(t, e, u), y(t, e, c, 'default'), w(t, e); } } function w(t, e) { void 0 !== t.backgroundColor && C(t.backgroundColor, e), M(t.dataColor, e), S(t.style, e), x(t.showLegend, e), O(t.cameraPosition, e), void 0 !== t.tooltip && (e.showTooltip = t.tooltip), void 0 != t.onclick && (e.onclick_callback = t.onclick), void 0 !== t.tooltipStyle && r.selectiveDeepExtend(['tooltipStyle'], e, t); } function x(t, e) { if (void 0 === t) { const i = void 0 === p.showLegend; if (i) { const o = e.style === d.DOTCOLOR || e.style === d.DOTSIZE; e.showLegend = o; } } else e.showLegend = t; } function k(t) { const e = l[t]; return void 0 === e ? -1 : e; } function D(t) { let e = !1; for (const i in d) if (d[i] === t) { e = !0; break; } return e; } function S(t, e) { if (void 0 !== t) { let i; if (typeof t === 'string') { if (i = k(t), i === -1) throw new Error(`Style '${t}' is invalid`); } else { if (!D(t)) throw new Error(`Style '${t}' is invalid`); i = t; }e.style = i; } } function C(t, e) { let i = 'white'; let o = 'gray'; let s = 1; if (typeof t === 'string')i = t, o = 'none', s = 0; else { if ((typeof t === 'undefined' ? 'undefined' : (0, n.default)(t)) !== 'object') throw new Error('Unsupported type of backgroundColor'); void 0 !== t.fill && (i = t.fill), void 0 !== t.stroke && (o = t.stroke), void 0 !== t.strokeWidth && (s = t.strokeWidth); }e.frame.style.backgroundColor = i, e.frame.style.borderColor = o, e.frame.style.borderWidth = `${s}px`, e.frame.style.borderStyle = 'solid'; } function M(t, e) { void 0 !== t && (void 0 === e.dataColor && (e.dataColor = {}), typeof t === 'string' ? (e.dataColor.fill = t, e.dataColor.stroke = t) : (t.fill && (e.dataColor.fill = t.fill), t.stroke && (e.dataColor.stroke = t.stroke), void 0 !== t.strokeWidth && (e.dataColor.strokeWidth = t.strokeWidth))); } function O(t, e) { const i = t; void 0 !== i && (void 0 === e.camera && (e.camera = new a()), e.camera.setArmRotation(i.horizontal, i.vertical), e.camera.setArmLength(i.distance)); }t.exports.STYLE = d, t.exports.setDefaults = b, t.exports.setOptions = _, t.exports.setCameraPosition = O;
    }, function (t, e, i) { const o = i(165); const n = s(o); function s(t) { return t && t.__esModule ? t : { default: t }; } const r = i(34); function a() { this.armLocation = new r(), this.armRotation = {}, this.armRotation.horizontal = 0, this.armRotation.vertical = 0, this.armLength = 1.7, this.cameraOffset = new r(), this.offsetMultiplier = 0.6, this.cameraLocation = new r(), this.cameraRotation = new r(0.5 * Math.PI, 0, 0), this.calculateCameraOrientation(); }a.prototype.setOffset = function (t, e) { const i = Math.abs; const o = n.default; const s = this.offsetMultiplier; const r = this.armLength * s; i(t) > r && (t = o(t) * r), i(e) > r && (e = o(e) * r), this.cameraOffset.x = t, this.cameraOffset.y = e, this.calculateCameraOrientation(); }, a.prototype.getOffset = function () { return this.cameraOffset; }, a.prototype.setArmLocation = function (t, e, i) { this.armLocation.x = t, this.armLocation.y = e, this.armLocation.z = i, this.calculateCameraOrientation(); }, a.prototype.setArmRotation = function (t, e) { void 0 !== t && (this.armRotation.horizontal = t), void 0 !== e && (this.armRotation.vertical = e, this.armRotation.vertical < 0 && (this.armRotation.vertical = 0), this.armRotation.vertical > 0.5 * Math.PI && (this.armRotation.vertical = 0.5 * Math.PI)), void 0 === t && void 0 === e || this.calculateCameraOrientation(); }, a.prototype.getArmRotation = function () { const t = {}; return t.horizontal = this.armRotation.horizontal, t.vertical = this.armRotation.vertical, t; }, a.prototype.setArmLength = function (t) { void 0 !== t && (this.armLength = t, this.armLength < 0.71 && (this.armLength = 0.71), this.armLength > 5 && (this.armLength = 5), this.setOffset(this.cameraOffset.x, this.cameraOffset.y), this.calculateCameraOrientation()); }, a.prototype.getArmLength = function () { return this.armLength; }, a.prototype.getCameraLocation = function () { return this.cameraLocation; }, a.prototype.getCameraRotation = function () { return this.cameraRotation; }, a.prototype.calculateCameraOrientation = function () { this.cameraLocation.x = this.armLocation.x - this.armLength * Math.sin(this.armRotation.horizontal) * Math.cos(this.armRotation.vertical), this.cameraLocation.y = this.armLocation.y - this.armLength * Math.cos(this.armRotation.horizontal) * Math.cos(this.armRotation.vertical), this.cameraLocation.z = this.armLocation.z + this.armLength * Math.sin(this.armRotation.vertical), this.cameraRotation.x = Math.PI / 2 - this.armRotation.vertical, this.cameraRotation.y = 0, this.cameraRotation.z = -this.armRotation.horizontal; const t = this.cameraRotation.x; const e = this.cameraRotation.z; const i = this.cameraOffset.x; const o = this.cameraOffset.y; const n = Math.sin; const s = Math.cos; this.cameraLocation.x = this.cameraLocation.x + i * s(e) + o * -n(e) * s(t), this.cameraLocation.y = this.cameraLocation.y + i * n(e) + o * s(e) * s(t), this.cameraLocation.z = this.cameraLocation.z + o * n(t); }, t.exports = a; }, function (t, e, i) { const o = i(12); function n(t, e, i) { this.dataGroup = t, this.column = e, this.graph = i, this.index = void 0, this.value = void 0, this.values = t.getDistinctValues(this.column), this.values.length > 0 && this.selectValue(0), this.dataPoints = [], this.loaded = !1, this.onLoadCallback = void 0, i.animationPreload ? (this.loaded = !1, this.loadInBackground()) : this.loaded = !0; }n.prototype.isLoaded = function () { return this.loaded; }, n.prototype.getLoadedProgress = function () { const t = this.values.length; let e = 0; while (this.dataPoints[e])e++; return Math.round(e / t * 100); }, n.prototype.getLabel = function () { return this.graph.filterLabel; }, n.prototype.getColumn = function () { return this.column; }, n.prototype.getSelectedValue = function () { if (void 0 !== this.index) return this.values[this.index]; }, n.prototype.getValues = function () { return this.values; }, n.prototype.getValue = function (t) { if (t >= this.values.length) throw new Error('Index out of range'); return this.values[t]; }, n.prototype._getDataPoints = function (t) { if (void 0 === t && (t = this.index), void 0 === t) return []; let e; if (this.dataPoints[t])e = this.dataPoints[t]; else { const i = {}; i.column = this.column, i.value = this.values[t]; const n = new o(this.dataGroup.getDataSet(), { filter(t) { return t[i.column] == i.value; } }).get(); e = this.dataGroup._getDataPoints(n), this.dataPoints[t] = e; } return e; }, n.prototype.setOnLoadCallback = function (t) { this.onLoadCallback = t; }, n.prototype.selectValue = function (t) { if (t >= this.values.length) throw new Error('Index out of range'); this.index = t, this.value = this.values[t]; }, n.prototype.loadInBackground = function (t) { void 0 === t && (t = 0); const e = this.graph.frame; if (t < this.values.length) { void 0 === e.progress && (e.progress = document.createElement('DIV'), e.progress.style.position = 'absolute', e.progress.style.color = 'gray', e.appendChild(e.progress)); const i = this.getLoadedProgress(); e.progress.innerHTML = `Loading animation... ${i}%`, e.progress.style.bottom = '60px', e.progress.style.left = '10px'; const o = this; setTimeout(() => { o.loadInBackground(t + 1); }, 10), this.loaded = !1; } else this.loaded = !0, void 0 !== e.progress && (e.removeChild(e.progress), e.progress = void 0), this.onLoadCallback && this.onLoadCallback(); }, t.exports = n; }, function (t, e, i) { const o = i(35); const n = i(44); const s = i(10); const r = i(2); function a(t) { this.active = !1, this.dom = { container: t }, this.dom.overlay = document.createElement('div'), this.dom.overlay.className = 'vis-overlay', this.dom.container.appendChild(this.dom.overlay), this.hammer = s(this.dom.overlay), this.hammer.on('tap', this._onTapOverlay.bind(this)); const e = this; const i = ['tap', 'doubletap', 'press', 'pinch', 'pan', 'panstart', 'panmove', 'panend']; i.forEach((t) => { e.hammer.on(t, (t) => { t.stopPropagation(); }); }), document && document.body && (this.onClick = function (i) { h(i.target, t) || e.deactivate(); }, document.body.addEventListener('click', this.onClick)), void 0 !== this.keycharm && this.keycharm.destroy(), this.keycharm = o(), this.escListener = this.deactivate.bind(this); } function h(t, e) { while (t) { if (t === e) return !0; t = t.parentNode; } return !1; }n(a.prototype), a.current = null, a.prototype.destroy = function () { this.deactivate(), this.dom.overlay.parentNode.removeChild(this.dom.overlay), this.onClick && document.body.removeEventListener('click', this.onClick), this.hammer.destroy(), this.hammer = null; }, a.prototype.activate = function () { a.current && a.current.deactivate(), a.current = this, this.active = !0, this.dom.overlay.style.display = 'none', r.addClassName(this.dom.container, 'vis-active'), this.emit('change'), this.emit('activate'), this.keycharm.bind('esc', this.escListener); }, a.prototype.deactivate = function () { this.active = !1, this.dom.overlay.style.display = '', r.removeClassName(this.dom.container, 'vis-active'), this.keycharm.unbind('esc', this.escListener), this.emit('change'), this.emit('deactivate'); }, a.prototype._onTapOverlay = function (t) { this.activate(), t.stopPropagation(); }, t.exports = a; }, function (t, e, i) { e.en = { current: 'current', time: 'time' }, e.en_EN = e.en, e.en_US = e.en, e.it = { current: 'attuale', time: 'tempo' }, e.it_IT = e.it, e.it_CH = e.it, e.nl = { current: 'huidige', time: 'tijd' }, e.nl_NL = e.nl, e.nl_BE = e.nl, e.de = { current: 'Aktuelle', time: 'Zeit' }, e.de_DE = e.de, e.fr = { current: 'actuel', time: 'heure' }, e.fr_FR = e.fr, e.fr_CA = e.fr, e.fr_BE = e.fr, e.es = { current: 'corriente', time: 'hora' }, e.es_ES = e.es; }, function (t, e, i) {
      const o = i(29); const n = a(o); const s = i(6); const r = a(s); function a(t) { return t && t.__esModule ? t : { default: t }; } const h = i(10); const d = i(2); const l = i(11); const u = i(12); const c = i(66); const p = i(16); const f = i(68); const m = i(69); const v = i(101); const g = i(102); const y = i(70); const b = i(103); const _ = i(104).default; const w = '__ungrouped__'; const x = '__background__'; function k(t, e) {
        this.body = t, this.defaultOptions = {
          type: null,
          orientation: { item: 'bottom' },
          align: 'auto',
          stack: !0,
          stackSubgroups: !0,
          groupOrderSwap(t, e, i) { const o = e.order; e.order = t.order, t.order = o; },
          groupOrder: 'order',
          selectable: !0,
          multiselect: !1,
          itemsAlwaysDraggable: { item: !1, range: !1 },
          editable: {
            updateTime: !1, updateGroup: !1, add: !1, remove: !1, overrideItems: !1,
          },
          groupEditable: { order: !1, add: !1, remove: !1 },
          snap: c.snap,
          onDropObjectOnItem(t, e, i) { i(e); },
          onAdd(t, e) { e(t); },
          onUpdate(t, e) { e(t); },
          onMove(t, e) { e(t); },
          onRemove(t, e) { e(t); },
          onMoving(t, e) { e(t); },
          onAddGroup(t, e) { e(t); },
          onMoveGroup(t, e) { e(t); },
          onRemoveGroup(t, e) { e(t); },
          margin: { item: { horizontal: 10, vertical: 10 }, axis: 20 },
          showTooltips: !0,
          tooltip: { followMouse: !1, overflowMethod: 'flip' },
          tooltipOnItemUpdateTime: !1,
        }, this.options = d.extend({}, this.defaultOptions), this.options.rtl = e.rtl, this.itemOptions = { type: { start: 'Date', end: 'Date' } }, this.conversion = { toScreen: t.util.toScreen, toTime: t.util.toTime }, this.dom = {}, this.props = {}, this.hammer = null; const i = this; this.itemsData = null, this.groupsData = null, this.itemListeners = { add(t, e, o) { i._onAdd(e.items); }, update(t, e, o) { i._onUpdate(e.items); }, remove(t, e, o) { i._onRemove(e.items); } }, this.groupListeners = { add(t, e, o) { if (i._onAddGroups(e.items), i.groupsData && i.groupsData.length > 0) { const n = i.groupsData.getDataSet(); n.get().forEach((t) => { if (t.nestedGroups) { t.showNested != 0 && (t.showNested = !0); let e = []; t.nestedGroups.forEach((i) => { const o = n.get(i); o && (o.nestedInGroup = t.id, t.showNested == 0 && (o.visible = !1), e = e.concat(o)); }), n.update(e, o); } }); } }, update(t, e, o) { i._onUpdateGroups(e.items); }, remove(t, e, o) { i._onRemoveGroups(e.items); } }, this.items = {}, this.groups = {}, this.groupIds = [], this.selection = [], this.popup = null, this.touchParams = {}, this.groupTouchParams = {}, this._create(), this.setOptions(e);
      }k.prototype = new p(), k.types = {
        background: b, box: v, range: y, point: g,
      }, k.prototype._create = function () { const t = document.createElement('div'); t.className = 'vis-itemset', t['timeline-itemset'] = this, this.dom.frame = t; const e = document.createElement('div'); e.className = 'vis-background', t.appendChild(e), this.dom.background = e; const i = document.createElement('div'); i.className = 'vis-foreground', t.appendChild(i), this.dom.foreground = i; const o = document.createElement('div'); o.className = 'vis-axis', this.dom.axis = o; const n = document.createElement('div'); n.className = 'vis-labelset', this.dom.labelSet = n, this._updateUngrouped(); const s = new m(x, null, this); s.show(), this.groups[x] = s, this.hammer = new h(this.body.dom.centerContainer), this.hammer.on('hammer.input', (t) => { t.isFirst && this._onTouch(t); }), this.hammer.on('panstart', this._onDragStart.bind(this)), this.hammer.on('panmove', this._onDrag.bind(this)), this.hammer.on('panend', this._onDragEnd.bind(this)), this.hammer.get('pan').set({ threshold: 5, direction: h.DIRECTION_HORIZONTAL }), this.hammer.on('tap', this._onSelectItem.bind(this)), this.hammer.on('press', this._onMultiSelectItem.bind(this)), this.hammer.on('doubletap', this._onAddItem.bind(this)), this.options.rtl ? this.groupHammer = new h(this.body.dom.rightContainer) : this.groupHammer = new h(this.body.dom.leftContainer), this.groupHammer.on('tap', this._onGroupClick.bind(this)), this.groupHammer.on('panstart', this._onGroupDragStart.bind(this)), this.groupHammer.on('panmove', this._onGroupDrag.bind(this)), this.groupHammer.on('panend', this._onGroupDragEnd.bind(this)), this.groupHammer.get('pan').set({ threshold: 5, direction: h.DIRECTION_VERTICAL }), this.body.dom.centerContainer.addEventListener('mouseover', this._onMouseOver.bind(this)), this.body.dom.centerContainer.addEventListener('mouseout', this._onMouseOut.bind(this)), this.body.dom.centerContainer.addEventListener('mousemove', this._onMouseMove.bind(this)), this.body.dom.centerContainer.addEventListener('contextmenu', this._onDragEnd.bind(this)), this.body.dom.centerContainer.addEventListener('mousewheel', this._onMouseWheel.bind(this)), this.show(); }, k.prototype.setOptions = function (t) { if (t) { const e = ['type', 'rtl', 'align', 'order', 'stack', 'stackSubgroups', 'selectable', 'multiselect', 'multiselectPerGroup', 'groupOrder', 'dataAttributes', 'template', 'groupTemplate', 'visibleFrameTemplate', 'hide', 'snap', 'groupOrderSwap', 'showTooltips', 'tooltip', 'tooltipOnItemUpdateTime']; d.selectiveExtend(e, this.options, t), 'itemsAlwaysDraggable' in t && (typeof t.itemsAlwaysDraggable === 'boolean' ? (this.options.itemsAlwaysDraggable.item = t.itemsAlwaysDraggable, this.options.itemsAlwaysDraggable.range = !1) : (0, r.default)(t.itemsAlwaysDraggable) === 'object' && (d.selectiveExtend(['item', 'range'], this.options.itemsAlwaysDraggable, t.itemsAlwaysDraggable), this.options.itemsAlwaysDraggable.item || (this.options.itemsAlwaysDraggable.range = !1))), 'orientation' in t && (typeof t.orientation === 'string' ? this.options.orientation.item = t.orientation === 'top' ? 'top' : 'bottom' : (0, r.default)(t.orientation) === 'object' && 'item' in t.orientation && (this.options.orientation.item = t.orientation.item)), 'margin' in t && (typeof t.margin === 'number' ? (this.options.margin.axis = t.margin, this.options.margin.item.horizontal = t.margin, this.options.margin.item.vertical = t.margin) : (0, r.default)(t.margin) === 'object' && (d.selectiveExtend(['axis'], this.options.margin, t.margin), 'item' in t.margin && (typeof t.margin.item === 'number' ? (this.options.margin.item.horizontal = t.margin.item, this.options.margin.item.vertical = t.margin.item) : (0, r.default)(t.margin.item) === 'object' && d.selectiveExtend(['horizontal', 'vertical'], this.options.margin.item, t.margin.item)))), 'editable' in t && (typeof t.editable === 'boolean' ? (this.options.editable.updateTime = t.editable, this.options.editable.updateGroup = t.editable, this.options.editable.add = t.editable, this.options.editable.remove = t.editable, this.options.editable.overrideItems = !1) : (0, r.default)(t.editable) === 'object' && d.selectiveExtend(['updateTime', 'updateGroup', 'add', 'remove', 'overrideItems'], this.options.editable, t.editable)), 'groupEditable' in t && (typeof t.groupEditable === 'boolean' ? (this.options.groupEditable.order = t.groupEditable, this.options.groupEditable.add = t.groupEditable, this.options.groupEditable.remove = t.groupEditable) : (0, r.default)(t.groupEditable) === 'object' && d.selectiveExtend(['order', 'add', 'remove'], this.options.groupEditable, t.groupEditable)); const i = function (e) { const i = t[e]; if (i) { if (!(i instanceof Function)) throw new Error(`option ${e} must be a function ${e}(item, callback)`); this.options[e] = i; } }.bind(this); ['onDropObjectOnItem', 'onAdd', 'onUpdate', 'onRemove', 'onMove', 'onMoving', 'onAddGroup', 'onMoveGroup', 'onRemoveGroup'].forEach(i), this.markDirty(); } }, k.prototype.markDirty = function (t) { this.groupIds = [], t && t.refreshItems && d.forEach(this.items, (t) => { t.dirty = !0, t.displayed && t.redraw(); }); }, k.prototype.destroy = function () { this.hide(), this.setItems(null), this.setGroups(null), this.hammer = null, this.body = null, this.conversion = null; }, k.prototype.hide = function () { this.dom.frame.parentNode && this.dom.frame.parentNode.removeChild(this.dom.frame), this.dom.axis.parentNode && this.dom.axis.parentNode.removeChild(this.dom.axis), this.dom.labelSet.parentNode && this.dom.labelSet.parentNode.removeChild(this.dom.labelSet); }, k.prototype.show = function () { this.dom.frame.parentNode || this.body.dom.center.appendChild(this.dom.frame), this.dom.axis.parentNode || this.body.dom.backgroundVertical.appendChild(this.dom.axis), this.dom.labelSet.parentNode || (this.options.rtl ? this.body.dom.right.appendChild(this.dom.labelSet) : this.body.dom.left.appendChild(this.dom.labelSet)); }, k.prototype.setSelection = function (t) { let e; let i; let o; let n; for (void 0 == t && (t = []), Array.isArray(t) || (t = [t]), e = 0, i = this.selection.length; e < i; e++)o = this.selection[e], n = this.items[o], n && n.unselect(); for (this.selection = [], e = 0, i = t.length; e < i; e++)o = t[e], n = this.items[o], n && (this.selection.push(o), n.select()); }, k.prototype.getSelection = function () { return this.selection.concat([]); }, k.prototype.getVisibleItems = function () { let t; let e; const i = this.body.range.getRange(); this.options.rtl ? (t = this.body.util.toScreen(i.start), e = this.body.util.toScreen(i.end)) : (e = this.body.util.toScreen(i.start), t = this.body.util.toScreen(i.end)); const o = []; for (const n in this.groups) if (this.groups.hasOwnProperty(n)) for (let s = this.groups[n], r = s.isVisible ? s.visibleItems : [], a = 0; a < r.length; a++) { const h = r[a]; this.options.rtl ? h.right < e && h.right + h.width > t && o.push(h.id) : h.left < t && h.left + h.width > e && o.push(h.id); } return o; }, k.prototype._deselect = function (t) { for (let e = this.selection, i = 0, o = e.length; i < o; i++) if (e[i] == t) { e.splice(i, 1); break; } }, k.prototype.redraw = function () { const t = this.options.margin; const e = this.body.range; const i = d.option.asSize; const o = this.options; const n = o.orientation.item; let s = !1; const r = this.dom.frame; this.props.top = this.body.domProps.top.height + this.body.domProps.border.top, this.options.rtl ? this.props.right = this.body.domProps.right.width + this.body.domProps.border.right : this.props.left = this.body.domProps.left.width + this.body.domProps.border.left, r.className = 'vis-itemset', s = this._orderGroups() || s; const a = e.end - e.start; const h = a != this.lastVisibleInterval || this.props.width != this.props.lastWidth; const l = e.start != this.lastRangeStart; const u = o.stack != this.lastStack; const c = o.stackSubgroups != this.lastStackSubgroups; const p = h || l || u || c; this.lastVisibleInterval = a, this.lastRangeStart = e.start, this.lastStack = o.stack, this.lastStackSubgroups = o.stackSubgroups, this.props.lastWidth = this.props.width; const f = this._firstGroup(); const m = { item: t.item, axis: t.axis }; const v = { item: t.item, axis: t.item.vertical / 2 }; let g = 0; const y = t.axis + t.item.vertical; this.groups[x].redraw(e, v, p); const b = {}; let _ = 0; d.forEach(this.groups, (t, i) => { if (i !== x) { const o = t == f ? m : v; const n = !0; b[i] = t.redraw(e, o, p, n), _ = b[i].length; } }); const w = _ > 0; if (w) { for (var k = {}, D = 0; D < _; D++)d.forEach(b, (t, e) => { k[e] = t[D](); }); d.forEach(this.groups, (t, e) => { if (e !== x) { const i = k[e]; s = i || s, g += t.height; } }), g = Math.max(g, y); } return g = Math.max(g, y), r.style.height = i(g), this.props.width = r.offsetWidth, this.props.height = g, this.dom.axis.style.top = i(n == 'top' ? this.body.domProps.top.height + this.body.domProps.border.top : this.body.domProps.top.height + this.body.domProps.centerContainer.height), this.options.rtl ? this.dom.axis.style.right = '0' : this.dom.axis.style.left = '0', this.initialItemSetDrawn = !0, s = this._isResized() || s, s; }, k.prototype._firstGroup = function () { const t = this.options.orientation.item == 'top' ? 0 : this.groupIds.length - 1; const e = this.groupIds[t]; const i = this.groups[e] || this.groups[w]; return i || null; }, k.prototype._updateUngrouped = function () { let t; let e; let i = this.groups[w]; if (this.groupsData) { if (i) for (e in i.hide(), delete this.groups[w], this.items) if (this.items.hasOwnProperty(e)) { t = this.items[e], t.parent && t.parent.remove(t); const o = this._getGroupId(t.data); const n = this.groups[o]; n && n.add(t) || t.hide(); } } else if (!i) { const s = null; const r = null; for (e in i = new f(s, r, this), this.groups[w] = i, this.items) this.items.hasOwnProperty(e) && (t = this.items[e], i.add(t)); i.show(); } }, k.prototype.getLabelSet = function () { return this.dom.labelSet; }, k.prototype.setItems = function (t) { let e; const i = this; const o = this.itemsData; if (t) { if (!(t instanceof l || t instanceof u)) throw new TypeError('Data must be an instance of DataSet or DataView'); this.itemsData = t; } else this.itemsData = null; if (o && (d.forEach(this.itemListeners, (t, e) => { o.off(e, t); }), e = o.getIds(), this._onRemove(e)), this.itemsData) { const n = this.id; d.forEach(this.itemListeners, (t, e) => { i.itemsData.on(e, t, n); }), e = this.itemsData.getIds(), this._onAdd(e), this._updateUngrouped(); } this.body.emitter.emit('_change', { queue: !0 }); }, k.prototype.getItems = function () { return this.itemsData; }, k.prototype.setGroups = function (t) { let e; const i = this; if (this.groupsData && (d.forEach(this.groupListeners, (t, e) => { i.groupsData.off(e, t); }), e = this.groupsData.getIds(), this.groupsData = null, this._onRemoveGroups(e)), t) { if (!(t instanceof l || t instanceof u)) throw new TypeError('Data must be an instance of DataSet or DataView'); this.groupsData = t; } else this.groupsData = null; if (this.groupsData) { let o = this.groupsData; this.groupsData instanceof u && (o = this.groupsData.getDataSet()), o.get().forEach((t) => { t.nestedGroups && t.nestedGroups.forEach((e) => { const i = o.get(e); i.nestedInGroup = t.id, t.showNested == 0 && (i.visible = !1), o.update(i); }); }); const n = this.id; d.forEach(this.groupListeners, (t, e) => { i.groupsData.on(e, t, n); }), e = this.groupsData.getIds(), this._onAddGroups(e); } this._updateUngrouped(), this._order(), this.body.emitter.emit('_change', { queue: !0 }); }, k.prototype.getGroups = function () { return this.groupsData; }, k.prototype.removeItem = function (t) { const e = this.itemsData.get(t); const i = this.itemsData.getDataSet(); e && this.options.onRemove(e, (e) => { e && i.remove(t); }); }, k.prototype._getType = function (t) { return t.type || this.options.type || (t.end ? 'range' : 'box'); }, k.prototype._getGroupId = function (t) { const e = this._getType(t); return e == 'background' && void 0 == t.group ? x : this.groupsData ? t.group : w; }, k.prototype._onUpdate = function (t) { const e = this; t.forEach((t) => { let i; const o = e.itemsData.get(t, e.itemOptions); let n = e.items[t]; const s = o ? e._getType(o) : null; const r = k.types[s]; if (n && (r && n instanceof r ? e._updateItem(n, o) : (i = n.selected, e._removeItem(n), n = null)), !n && o) { if (!r) throw s == 'rangeoverflow' ? new TypeError('Item type "rangeoverflow" is deprecated. Use css styling instead: .vis-item.vis-range .vis-item-content {overflow: visible;}') : new TypeError(`Unknown item type "${s}"`); n = new r(o, e.conversion, e.options), n.id = t, e._addItem(n), i && (this.selection.push(t), n.select()); } }), this._order(), this.body.emitter.emit('_change', { queue: !0 }); }, k.prototype._onAdd = k.prototype._onUpdate, k.prototype._onRemove = function (t) { let e = 0; const i = this; t.forEach((t) => { const o = i.items[t]; o && (e++, i._removeItem(o)); }), e && (this._order(), this.body.emitter.emit('_change', { queue: !0 })); }, k.prototype._order = function () { d.forEach(this.groups, (t) => { t.order(); }); }, k.prototype._onUpdateGroups = function (t) { this._onAddGroups(t); }, k.prototype._onAddGroups = function (t) { const e = this; t.forEach((t) => { const i = e.groupsData.get(t); let o = e.groups[t]; if (o)o.setData(i); else { if (t == w || t == x) throw new Error(`Illegal group id. ${t} is a reserved id.`); const s = (0, n.default)(e.options); for (const r in d.extend(s, { height: null }), o = new f(t, i, e), e.groups[t] = o, e.items) if (e.items.hasOwnProperty(r)) { const a = e.items[r]; a.data.group == t && o.add(a); }o.order(), o.show(); } }), this.body.emitter.emit('_change', { queue: !0 }); }, k.prototype._onRemoveGroups = function (t) { const e = this.groups; t.forEach((t) => { const i = e[t]; i && (i.hide(), delete e[t]); }), this.markDirty(), this.body.emitter.emit('_change', { queue: !0 }); }, k.prototype._orderGroups = function () { if (this.groupsData) { let t = this.groupsData.getIds({ order: this.options.groupOrder }); t = this._orderNestedGroups(t); const e = !d.equalArray(t, this.groupIds); if (e) { const i = this.groups; t.forEach((t) => { i[t].hide(); }), t.forEach((t) => { i[t].show(); }), this.groupIds = t; } return e; } return !1; }, k.prototype._orderNestedGroups = function (t) { let e = []; return t.forEach(function (t) { const i = this.groupsData.get(t); if (i.nestedInGroup || e.push(t), i.nestedGroups) { const o = this.groupsData.get({ filter(e) { return e.nestedInGroup == t; }, order: this.options.groupOrder }); const n = o.map(t => t.id); e = e.concat(n); } }, this), e; }, k.prototype._addItem = function (t) { this.items[t.id] = t; const e = this._getGroupId(t.data); const i = this.groups[e]; i ? i && i.data && i.data.showNested && (t.groupShowing = !0) : t.groupShowing = !1, i && i.add(t); }, k.prototype._updateItem = function (t, e) { t.setData(e); const i = this._getGroupId(t.data); const o = this.groups[i]; o ? o && o.data && o.data.showNested && (t.groupShowing = !0) : t.groupShowing = !1; }, k.prototype._removeItem = function (t) { t.hide(), delete this.items[t.id]; const e = this.selection.indexOf(t.id); e != -1 && this.selection.splice(e, 1), t.parent && t.parent.remove(t); }, k.prototype._constructByEndArray = function (t) { for (var e = [], i = 0; i < t.length; i++)t[i] instanceof y && e.push(t[i]); return e; }, k.prototype._onTouch = function (t) { this.touchParams.item = this.itemFromTarget(t), this.touchParams.dragLeftItem = t.target.dragLeftItem || !1, this.touchParams.dragRightItem = t.target.dragRightItem || !1, this.touchParams.itemProps = null; }, k.prototype._getGroupIndex = function (t) { for (let e = 0; e < this.groupIds.length; e++) if (t == this.groupIds[e]) return e; }, k.prototype._onDragStart = function (t) {
        if (!this.touchParams.itemIsDragging) {
          let e; const i = this.touchParams.item || null; const o = this; if (i && (i.selected || this.options.itemsAlwaysDraggable.item)) {
            if (this.options.editable.overrideItems && !this.options.editable.updateTime && !this.options.editable.updateGroup) return; if (i.editable != null && !i.editable.updateTime && !i.editable.updateGroup && !this.options.editable.overrideItems) return; const n = this.touchParams.dragLeftItem; const s = this.touchParams.dragRightItem; if (this.touchParams.itemIsDragging = !0, this.touchParams.selectedItem = i, n) {
              e = {
                item: n, initialX: t.center.x, dragLeft: !0, data: this._cloneItemData(i.data),
              }, this.touchParams.itemProps = [e];
            } else if (s) {
              e = {
                item: s, initialX: t.center.x, dragRight: !0, data: this._cloneItemData(i.data),
              }, this.touchParams.itemProps = [e];
            } else if (this.options.editable.add && (t.srcEvent.ctrlKey || t.srcEvent.metaKey)) this._onDragStartAddItem(t); else {
              this.groupIds.length < 1 && this.redraw(); const r = this._getGroupIndex(i.data.group); const a = this.options.itemsAlwaysDraggable.item && !i.selected ? [i.id] : this.getSelection(); this.touchParams.itemProps = a.map((e) => {
                const i = o.items[e]; const n = o._getGroupIndex(i.data.group); return {
                  item: i, initialX: t.center.x, groupOffset: r - n, data: this._cloneItemData(i.data),
                };
              });
            }t.stopPropagation();
          } else this.options.editable.add && (t.srcEvent.ctrlKey || t.srcEvent.metaKey) && this._onDragStartAddItem(t);
        }
      }, k.prototype._onDragStartAddItem = function (t) {
        let e; let i; const o = this.options.snap || null; this.options.rtl ? (e = d.getAbsoluteRight(this.dom.frame), i = e - t.center.x + 10) : (e = d.getAbsoluteLeft(this.dom.frame), i = t.center.x - e - 10); const n = this.body.util.toTime(i); const s = this.body.util.getScale(); const r = this.body.util.getStep(); const a = o ? o(n, s, r) : n; const h = a; const l = {
          type: 'range', start: a, end: h, content: 'new item',
        }; const u = d.randomUUID(); l[this.itemsData._fieldId] = u; const c = this.groupFromTarget(t); c && (l.group = c.groupId); const p = new y(l, this.conversion, this.options); p.id = u, p.data = this._cloneItemData(l), this._addItem(p), this.touchParams.selectedItem = p; const f = { item: p, initialX: t.center.x, data: p.data }; this.options.rtl ? f.dragLeft = !0 : f.dragRight = !0, this.touchParams.itemProps = [f], t.stopPropagation();
      }, k.prototype._onDrag = function (t) { if (this.touchParams.itemProps) { t.stopPropagation(); let e; const i = this; const o = this.options.snap || null; e = this.options.rtl ? this.body.dom.root.offsetLeft + this.body.domProps.right.width : this.body.dom.root.offsetLeft + this.body.domProps.left.width; const n = this.body.util.getScale(); const s = this.body.util.getStep(); const r = this.touchParams.selectedItem; const a = (this.options.editable.overrideItems || r.editable == null) && this.options.editable.updateGroup || !this.options.editable.overrideItems && r.editable != null && r.editable.updateGroup; let h = null; if (a && r && void 0 != r.data.group) { const l = i.groupFromTarget(t); l && (h = this._getGroupIndex(l.groupId)); } this.touchParams.itemProps.forEach((l) => { let u; let c; let p; let f; let m; const v = i.body.util.toTime(t.center.x - e); const g = i.body.util.toTime(l.initialX - e); u = this.options.rtl ? -(v - g) : v - g; let y = this._cloneItemData(l.item.data); if (l.item.editable == null || l.item.editable.updateTime || l.item.editable.updateGroup || i.options.editable.overrideItems) { const b = (this.options.editable.overrideItems || r.editable == null) && this.options.editable.updateTime || !this.options.editable.overrideItems && r.editable != null && r.editable.updateTime; if (b) if (l.dragLeft) this.options.rtl ? void 0 != y.end && (p = d.convert(l.data.end, 'Date'), m = new Date(p.valueOf() + u), y.end = o ? o(m, n, s) : m) : void 0 != y.start && (c = d.convert(l.data.start, 'Date'), f = new Date(c.valueOf() + u), y.start = o ? o(f, n, s) : f); else if (l.dragRight) this.options.rtl ? void 0 != y.start && (c = d.convert(l.data.start, 'Date'), f = new Date(c.valueOf() + u), y.start = o ? o(f, n, s) : f) : void 0 != y.end && (p = d.convert(l.data.end, 'Date'), m = new Date(p.valueOf() + u), y.end = o ? o(m, n, s) : m); else if (void 0 != y.start) if (c = d.convert(l.data.start, 'Date').valueOf(), f = new Date(c + u), void 0 != y.end) { p = d.convert(l.data.end, 'Date'); const _ = p.valueOf() - c.valueOf(); y.start = o ? o(f, n, s) : f, y.end = new Date(y.start.valueOf() + _); } else y.start = o ? o(f, n, s) : f; if (a && !l.dragLeft && !l.dragRight && h != null && void 0 != y.group) { let w = h - l.groupOffset; w = Math.max(0, w), w = Math.min(i.groupIds.length - 1, w), y.group = i.groupIds[w]; }y = this._cloneItemData(y), i.options.onMoving(y, (t) => { t && l.item.setData(this._cloneItemData(t, 'Date')); }); } }), this.body.emitter.emit('_change'); } }, k.prototype._moveToGroup = function (t, e) { const i = this.groups[e]; if (i && i.groupId != t.data.group) { const o = t.parent; o.remove(t), o.order(), t.data.group = i.groupId, i.add(t), i.order(); } }, k.prototype._onDragEnd = function (t) { if (this.touchParams.itemIsDragging = !1, this.touchParams.itemProps) { t.stopPropagation(); const e = this; const i = this.itemsData.getDataSet(); const o = this.touchParams.itemProps; this.touchParams.itemProps = null, o.forEach((t) => { const o = t.item.id; const n = e.itemsData.get(o, e.itemOptions) != null; if (n) { const s = this._cloneItemData(t.item.data); e.options.onMove(s, (n) => { n ? (n[i._fieldId] = o, i.update(n)) : (t.item.setData(t.data), e.body.emitter.emit('_change')); }); } else e.options.onAdd(t.item.data, (i) => { e._removeItem(t.item), i && e.itemsData.getDataSet().add(i), e.body.emitter.emit('_change'); }); }); } }, k.prototype._onGroupClick = function (t) { const e = this.groupFromTarget(t); if (e && e.nestedGroups) { const i = this.groupsData.getDataSet(); const o = i.get(e.groupId); void 0 == o.showNested && (o.showNested = !0), o.showNested = !o.showNested; const n = i.get(e.nestedGroups).map(t => t.visible = o.showNested, t); if (i.update(n.concat(o)), o.showNested)d.removeClassName(e.dom.label, 'collapsed'), d.addClassName(e.dom.label, 'expanded'); else { d.removeClassName(e.dom.label, 'expanded'); const s = this.options.rtl ? 'collapsed-rtl' : 'collapsed'; d.addClassName(e.dom.label, s); } } }, k.prototype._onGroupDragStart = function (t) { this.options.groupEditable.order && (this.groupTouchParams.group = this.groupFromTarget(t), this.groupTouchParams.group && (t.stopPropagation(), this.groupTouchParams.originalOrder = this.groupsData.getIds({ order: this.options.groupOrder }))); }, k.prototype._onGroupDrag = function (t) { if (this.options.groupEditable.order && this.groupTouchParams.group) { t.stopPropagation(); let e = this.groupsData; this.groupsData instanceof u && (e = this.groupsData.getDataSet()); const i = this.groupFromTarget(t); if (i && i.height != this.groupTouchParams.group.height) { const o = i.top < this.groupTouchParams.group.top; const n = t.center ? t.center.y : t.clientY; const s = d.getAbsoluteTop(i.dom.foreground); const r = this.groupTouchParams.group.height; if (o) { if (s + r < n) return; } else { const a = i.height; if (s + a - r > n) return; } } if (i && i != this.groupTouchParams.group) { const h = e.get(i.groupId); const l = e.get(this.groupTouchParams.group.groupId); l && h && (this.options.groupOrderSwap(l, h, e), e.update(l), e.update(h)); const c = e.getIds({ order: this.options.groupOrder }); if (!d.equalArray(c, this.groupTouchParams.originalOrder)) { const p = this.groupTouchParams.originalOrder; const f = this.groupTouchParams.group.groupId; const m = Math.min(p.length, c.length); let v = 0; let g = 0; let y = 0; while (v < m) { while (v + g < m && v + y < m && c[v + g] == p[v + y])v++; if (v + g >= m) break; if (c[v + g] == f)g = 1; else if (p[v + y] == f)y = 1; else { const b = c.indexOf(p[v + y]); const _ = e.get(c[v + g]); const w = e.get(p[v + y]); this.options.groupOrderSwap(_, w, e), e.update(_), e.update(w); const x = c[v + g]; c[v + g] = p[v + y], c[b] = x, v++; } } } } } }, k.prototype._onGroupDragEnd = function (t) { if (this.options.groupEditable.order && this.groupTouchParams.group) { t.stopPropagation(); const e = this; const i = e.groupTouchParams.group.groupId; const o = e.groupsData.getDataSet(); const n = d.extend({}, o.get(i)); e.options.onMoveGroup(n, (t) => { if (t)t[o._fieldId] = i, o.update(t); else { const n = o.getIds({ order: e.options.groupOrder }); if (!d.equalArray(n, e.groupTouchParams.originalOrder)) { const s = e.groupTouchParams.originalOrder; const r = Math.min(s.length, n.length); let a = 0; while (a < r) { while (a < r && n[a] == s[a])a++; if (a >= r) break; const h = n.indexOf(s[a]); const l = o.get(n[a]); const u = o.get(s[a]); e.options.groupOrderSwap(l, u, o), o.update(l), o.update(u); const c = n[a]; n[a] = s[a], n[h] = c, a++; } } } }), e.body.emitter.emit('groupDragged', { groupId: i }); } }, k.prototype._onSelectItem = function (t) { if (this.options.selectable) { const e = t.srcEvent && (t.srcEvent.ctrlKey || t.srcEvent.metaKey); const i = t.srcEvent && t.srcEvent.shiftKey; if (e || i) this._onMultiSelectItem(t); else { const o = this.getSelection(); const n = this.itemFromTarget(t); const s = n ? [n.id] : []; this.setSelection(s); const r = this.getSelection(); (r.length > 0 || o.length > 0) && this.body.emitter.emit('select', { items: r, event: t }); } } }, k.prototype._onMouseOver = function (t) { const e = this.itemFromTarget(t); if (e) { const i = this.itemFromRelatedTarget(t); if (e !== i) { const o = e.getTitle(); if (this.options.showTooltips && o) { this.popup == null && (this.popup = new _(this.body.dom.root, this.options.tooltip.overflowMethod || 'flip')), this.popup.setText(o); const n = this.body.dom.centerContainer; this.popup.setPosition(t.clientX - d.getAbsoluteLeft(n) + n.offsetLeft, t.clientY - d.getAbsoluteTop(n) + n.offsetTop), this.popup.show(); } else this.popup != null && this.popup.hide(); this.body.emitter.emit('itemover', { item: e.id, event: t }); } } }, k.prototype._onMouseOut = function (t) { const e = this.itemFromTarget(t); if (e) { const i = this.itemFromRelatedTarget(t); e !== i && (this.popup != null && this.popup.hide(), this.body.emitter.emit('itemout', { item: e.id, event: t })); } }, k.prototype._onMouseMove = function (t) { const e = this.itemFromTarget(t); if (e && this.options.showTooltips && this.options.tooltip.followMouse && this.popup && !this.popup.hidden) { const i = this.body.dom.centerContainer; this.popup.setPosition(t.clientX - d.getAbsoluteLeft(i) + i.offsetLeft, t.clientY - d.getAbsoluteTop(i) + i.offsetTop), this.popup.show(); } }, k.prototype._onMouseWheel = function (t) { this.touchParams.itemIsDragging && this._onDragEnd(t); }, k.prototype._onUpdateItem = function (t) { if (this.options.selectable && this.options.editable.add) { const e = this; if (t) { const i = e.itemsData.get(t.id); this.options.onUpdate(i, (t) => { t && e.itemsData.getDataSet().update(t); }); } } }, k.prototype._onDropObjectOnItem = function (t) { const e = this.itemFromTarget(t); const i = JSON.parse(t.dataTransfer.getData('text')); this.options.onDropObjectOnItem(i, e); }, k.prototype._onAddItem = function (t) { if (this.options.selectable && this.options.editable.add) { let e; let i; const o = this; const n = this.options.snap || null; this.options.rtl ? (e = d.getAbsoluteRight(this.dom.frame), i = e - t.center.x) : (e = d.getAbsoluteLeft(this.dom.frame), i = t.center.x - e); let s; let r; const a = this.body.util.toTime(i); const h = this.body.util.getScale(); const l = this.body.util.getStep(); t.type == 'drop' ? (r = JSON.parse(t.dataTransfer.getData('text')), r.content = r.content ? r.content : 'new item', r.start = r.start ? r.start : n ? n(a, h, l) : a, r.type = r.type || 'box', r[this.itemsData._fieldId] = r.id || d.randomUUID(), r.type != 'range' || r.end || (s = this.body.util.toTime(i + this.props.width / 5), r.end = n ? n(s, h, l) : s)) : (r = { start: n ? n(a, h, l) : a, content: 'new item' }, r[this.itemsData._fieldId] = d.randomUUID(), this.options.type === 'range' && (s = this.body.util.toTime(i + this.props.width / 5), r.end = n ? n(s, h, l) : s)); const u = this.groupFromTarget(t); u && (r.group = u.groupId), r = this._cloneItemData(r), this.options.onAdd(r, (e) => { e && (o.itemsData.getDataSet().add(e), t.type == 'drop' && o.setSelection([e.id])); }); } }, k.prototype._onMultiSelectItem = function (t) { if (this.options.selectable) { const e = this.itemFromTarget(t); if (e) { let i = this.options.multiselect ? this.getSelection() : []; const o = t.srcEvent && t.srcEvent.shiftKey || !1; if (o && this.options.multiselect) { const n = this.itemsData.get(e.id).group; let s = void 0; this.options.multiselectPerGroup && i.length > 0 && (s = this.itemsData.get(i[0]).group), this.options.multiselectPerGroup && void 0 != s && s != n || i.push(e.id); const r = k._getItemRange(this.itemsData.get(i, this.itemOptions)); if (!this.options.multiselectPerGroup || s == n) for (const a in i = [], this.items) if (this.items.hasOwnProperty(a)) { const h = this.items[a]; const d = h.data.start; const l = void 0 !== h.data.end ? h.data.end : d; !(d >= r.min && l <= r.max) || this.options.multiselectPerGroup && s != this.itemsData.get(h.id).group || h instanceof b || i.push(h.id); } } else { const u = i.indexOf(e.id); u == -1 ? i.push(e.id) : i.splice(u, 1); } this.setSelection(i), this.body.emitter.emit('select', { items: this.getSelection(), event: t }); } } }, k._getItemRange = function (t) { let e = null; let i = null; return t.forEach((t) => { (i == null || t.start < i) && (i = t.start), void 0 != t.end ? (e == null || t.end > e) && (e = t.end) : (e == null || t.start > e) && (e = t.start); }), { min: i, max: e }; }, k.prototype.itemFromElement = function (t) { let e = t; while (e) { if (e.hasOwnProperty('timeline-item')) return e['timeline-item']; e = e.parentNode; } return null; }, k.prototype.itemFromTarget = function (t) { return this.itemFromElement(t.target); }, k.prototype.itemFromRelatedTarget = function (t) { return this.itemFromElement(t.relatedTarget); }, k.prototype.groupFromTarget = function (t) { const e = t.center ? t.center.y : t.clientY; let i = this.groupIds; i.length <= 0 && this.groupsData && (i = this.groupsData.getIds({ order: this.options.groupOrder })); for (let o = 0; o < i.length; o++) { const n = i[o]; const s = this.groups[n]; const r = s.dom.foreground; const a = d.getAbsoluteTop(r); if (e > a && e < a + r.offsetHeight) return s; if (this.options.orientation.item === 'top') { if (o === this.groupIds.length - 1 && e > a) return s; } else if (o === 0 && e < a + r.offset) return s; } return null; }, k.itemSetFromTarget = function (t) { let e = t.target; while (e) { if (e.hasOwnProperty('timeline-itemset')) return e['timeline-itemset']; e = e.parentNode; } return null; }, k.prototype._cloneItemData = function (t, e) { const i = d.extend({}, t); return e || (e = this.itemsData.getDataSet()._options.type), void 0 != i.start && (i.start = d.convert(i.start, e && e.start || 'Date')), void 0 != i.end && (i.end = d.convert(i.end, e && e.end || 'Date')), i; }, t.exports = k;
    }, function (t, e, i) { const o = 0.001; e.orderByStart = function (t) { t.sort((t, e) => t.data.start - e.data.start); }, e.orderByEnd = function (t) { t.sort((t, e) => { const i = 'end' in t.data ? t.data.end : t.data.start; const o = 'end' in e.data ? e.data.end : e.data.start; return i - o; }); }, e.stack = function (t, i, o) { if (o) for (var n = 0; n < t.length; n++)t[n].top = null; for (n = 0; n < t.length; n++) { const s = t[n]; if (s.stack && s.top === null) { s.top = i.axis; do { for (var r = null, a = 0, h = t.length; a < h; a++) { const d = t[a]; if (d.top !== null && d !== s && d.stack && e.collision(s, d, i.item, d.options.rtl)) { r = d; break; } }r != null && (s.top = r.top + r.height + i.item.vertical); } while (r); } } }, e.substack = function (t, i, o) { for (var n = 0; n < t.length; n++)t[n].top = null; let s = o.height; for (n = 0; n < t.length; n++) { const r = t[n]; if (r.stack && r.top === null) { r.top = r.baseTop; do { for (var a = null, h = 0, d = t.length; h < d; h++) { const l = t[h]; if (l.top !== null && l !== r && e.collision(r, l, i.item, l.options.rtl)) { a = l; break; } }a != null && (r.top = a.top + a.height + i.item.vertical), r.top + r.height > s && (s = r.top + r.height); } while (a); } }o.height = s - o.top + 0.5 * i.item.vertical; }, e.nostack = function (t, i, o, n) { for (let s = 0; s < t.length; s++) if (void 0 == t[s].data.subgroup)t[s].top = i.item.vertical; else if (void 0 !== t[s].data.subgroup && n) { let r = 0; for (const a in o)o.hasOwnProperty(a) && o[a].visible == 1 && o[a].index < o[t[s].data.subgroup].index && (r += o[a].height, o[t[s].data.subgroup].top = r); t[s].top = r + 0.5 * i.item.vertical; }n || e.stackSubgroups(t, i, o); }, e.stackSubgroups = function (t, i, o) { for (const n in o) if (o.hasOwnProperty(n)) { o[n].top = 0; do { var s = null; for (const r in o) if (o[r].top !== null && r !== n && o[n].index > o[r].index && e.collisionByTimes(o[n], o[r])) { s = o[r]; break; }s != null && (o[n].top = s.top + s.height); } while (s); } for (let a = 0; a < t.length; a++) void 0 !== t[a].data.subgroup && (t[a].top = o[t[a].data.subgroup].top + 0.5 * i.item.vertical); }, e.stackSubgroupsWithInnerStack = function (t, i, o) { let n = !1; const s = []; for (var r in o)o[r].hasOwnProperty('index') ? s[o[r].index] = r : s.push(r); for (let a = 0; a < s.length; a++) if (r = s[a], o.hasOwnProperty(r)) { for (const h in n = n || o[r].stack, o[r].top = 0, o)o[h].visible && o[r].index > o[h].index && (o[r].top += o[h].height); for (let d = t[r], l = 0; l < d.length; l++) void 0 !== d[l].data.subgroup && (d[l].top = o[d[l].data.subgroup].top + 0.5 * i.item.vertical, o[r].stack && (d[l].baseTop = d[l].top)); n && o[r].stack && e.substack(t[r], i, o[r]); } }, e.collision = function (t, e, i, n) { return n ? t.right - i.horizontal + o < e.right + e.width && t.right + t.width + i.horizontal - o > e.right && t.top - i.vertical + o < e.top + e.height && t.top + t.height + i.vertical - o > e.top : t.left - i.horizontal + o < e.left + e.width && t.left + t.width + i.horizontal - o > e.left && t.top - i.vertical + o < e.top + e.height && t.top + t.height + i.vertical - o > e.top; }, e.collisionByTimes = function (t, e) { return t.start <= e.start && t.end >= e.start && t.top < e.top + e.height && t.top + t.height > e.top || e.start <= t.start && e.end >= t.start && e.top < t.top + t.height && e.top + e.height > t.top; }; }, function (t, e, i) {
      const o = i(38); function n(t, e, i) { if (this.props = { dot: { width: 0, height: 0 }, line: { width: 0, height: 0 } }, this.options = i, t && void 0 == t.start) throw new Error(`Property "start" missing in item ${t}`); o.call(this, t, e, i); }n.prototype = new o(null, null, null), n.prototype.isVisible = function (t) { let e; const i = this.options.align; const o = this.width * t.getMillisecondsPerPixel(); return e = i == 'right' ? this.data.start.getTime() > t.start && this.data.start.getTime() - o < t.end : i == 'left' ? this.data.start.getTime() + o > t.start && this.data.start.getTime() < t.end : this.data.start.getTime() + o / 2 > t.start && this.data.start.getTime() - o / 2 < t.end, e; }, n.prototype._createDomElement = function () { this.dom || (this.dom = {}, this.dom.box = document.createElement('DIV'), this.dom.content = document.createElement('DIV'), this.dom.content.className = 'vis-item-content', this.dom.box.appendChild(this.dom.content), this.dom.line = document.createElement('DIV'), this.dom.line.className = 'vis-line', this.dom.dot = document.createElement('DIV'), this.dom.dot.className = 'vis-dot', this.dom.box['timeline-item'] = this, this.dirty = !0); }, n.prototype._appendDomElement = function () { if (!this.parent) throw new Error('Cannot redraw item: no parent attached'); if (!this.dom.box.parentNode) { const t = this.parent.dom.foreground; if (!t) throw new Error('Cannot redraw item: parent has no foreground container element'); t.appendChild(this.dom.box); } if (!this.dom.line.parentNode) { var e = this.parent.dom.background; if (!e) throw new Error('Cannot redraw item: parent has no background container element'); e.appendChild(this.dom.line); } if (!this.dom.dot.parentNode) { const i = this.parent.dom.axis; if (!e) throw new Error('Cannot redraw item: parent has no axis container element'); i.appendChild(this.dom.dot); } this.displayed = !0; }, n.prototype._updateDirtyDomComponents = function () { if (this.dirty) { this._updateContents(this.dom.content), this._updateDataAttributes(this.dom.box), this._updateStyle(this.dom.box); const t = this.editable.updateTime || this.editable.updateGroup; const e = (this.data.className ? ` ${this.data.className}` : '') + (this.selected ? ' vis-selected' : '') + (t ? ' vis-editable' : ' vis-readonly'); this.dom.box.className = `vis-item vis-box${e}`, this.dom.line.className = `vis-item vis-line${e}`, this.dom.dot.className = `vis-item vis-dot${e}`; } }, n.prototype._getDomComponentsSizes = function () {
        return {
          previous: { right: this.dom.box.style.right, left: this.dom.box.style.left }, dot: { height: this.dom.dot.offsetHeight, width: this.dom.dot.offsetWidth }, line: { width: this.dom.line.offsetWidth }, box: { width: this.dom.box.offsetWidth, height: this.dom.box.offsetHeight },
        };
      }, n.prototype._updateDomComponentsSizes = function (t) { this.options.rtl ? this.dom.box.style.right = '0px' : this.dom.box.style.left = '0px', this.props.dot.height = t.dot.height, this.props.dot.width = t.dot.width, this.props.line.width = t.line.width, this.width = t.box.width, this.height = t.box.height, this.options.rtl ? this.dom.box.style.right = t.previous.right : this.dom.box.style.left = t.previous.left, this.dirty = !1; }, n.prototype._repaintDomAdditionals = function () { this._repaintOnItemUpdateTimeTooltip(this.dom.box), this._repaintDragCenter(), this._repaintDeleteButton(this.dom.box); }, n.prototype.redraw = function (t) { let e; let i; const o = [this._createDomElement.bind(this), this._appendDomElement.bind(this), this._updateDirtyDomComponents.bind(this), function () { this.dirty && (e = this._getDomComponentsSizes()); }.bind(this), function () { this.dirty && this._updateDomComponentsSizes.bind(this)(e); }.bind(this), this._repaintDomAdditionals.bind(this)]; return t ? o : (o.forEach((t) => { i = t(); }), i); }, n.prototype.show = function () { this.displayed || this.redraw(); }, n.prototype.hide = function () { if (this.displayed) { const t = this.dom; t.box.parentNode && t.box.parentNode.removeChild(t.box), t.line.parentNode && t.line.parentNode.removeChild(t.line), t.dot.parentNode && t.dot.parentNode.removeChild(t.dot), this.displayed = !1; } }, n.prototype.repositionX = function () { const t = this.conversion.toScreen(this.data.start); const e = this.options.align; e == 'right' ? this.options.rtl ? (this.right = t - this.width, this.dom.box.style.right = `${this.right}px`, this.dom.line.style.right = `${t - this.props.line.width}px`, this.dom.dot.style.right = `${t - this.props.line.width / 2 - this.props.dot.width / 2}px`) : (this.left = t - this.width, this.dom.box.style.left = `${this.left}px`, this.dom.line.style.left = `${t - this.props.line.width}px`, this.dom.dot.style.left = `${t - this.props.line.width / 2 - this.props.dot.width / 2}px`) : e == 'left' ? this.options.rtl ? (this.right = t, this.dom.box.style.right = `${this.right}px`, this.dom.line.style.right = `${t}px`, this.dom.dot.style.right = `${t + this.props.line.width / 2 - this.props.dot.width / 2}px`) : (this.left = t, this.dom.box.style.left = `${this.left}px`, this.dom.line.style.left = `${t}px`, this.dom.dot.style.left = `${t + this.props.line.width / 2 - this.props.dot.width / 2}px`) : this.options.rtl ? (this.right = t - this.width / 2, this.dom.box.style.right = `${this.right}px`, this.dom.line.style.right = `${t - this.props.line.width}px`, this.dom.dot.style.right = `${t - this.props.dot.width / 2}px`) : (this.left = t - this.width / 2, this.dom.box.style.left = `${this.left}px`, this.dom.line.style.left = `${t - this.props.line.width / 2}px`, this.dom.dot.style.left = `${t - this.props.dot.width / 2}px`); }, n.prototype.repositionY = function () { const t = this.options.orientation.item; const e = this.dom.box; const i = this.dom.line; const o = this.dom.dot; if (t == 'top')e.style.top = `${this.top || 0}px`, i.style.top = '0', i.style.height = `${this.parent.top + this.top + 1}px`, i.style.bottom = ''; else { const n = this.parent.itemSet.props.height; const s = n - this.parent.top - this.parent.height + this.top; e.style.top = `${this.parent.height - this.top - this.height || 0}px`, i.style.top = `${n - s}px`, i.style.bottom = '0'; }o.style.top = `${-this.props.dot.height / 2}px`; }, n.prototype.getWidthLeft = function () { return this.width / 2; }, n.prototype.getWidthRight = function () { return this.width / 2; }, t.exports = n;
    }, function (t, e, i) { const o = i(38); function n(t, e, i) { if (this.props = { dot: { top: 0, width: 0, height: 0 }, content: { height: 0, marginLeft: 0, marginRight: 0 } }, this.options = i, t && void 0 == t.start) throw new Error(`Property "start" missing in item ${t}`); o.call(this, t, e, i); }n.prototype = new o(null, null, null), n.prototype.isVisible = function (t) { const e = this.width * t.getMillisecondsPerPixel(); return this.data.start.getTime() + e > t.start && this.data.start < t.end; }, n.prototype._createDomElement = function () { this.dom || (this.dom = {}, this.dom.point = document.createElement('div'), this.dom.content = document.createElement('div'), this.dom.content.className = 'vis-item-content', this.dom.point.appendChild(this.dom.content), this.dom.dot = document.createElement('div'), this.dom.point.appendChild(this.dom.dot), this.dom.point['timeline-item'] = this, this.dirty = !0); }, n.prototype._appendDomElement = function () { if (!this.parent) throw new Error('Cannot redraw item: no parent attached'); if (!this.dom.point.parentNode) { const t = this.parent.dom.foreground; if (!t) throw new Error('Cannot redraw item: parent has no foreground container element'); t.appendChild(this.dom.point); } this.displayed = !0; }, n.prototype._updateDirtyDomComponents = function () { if (this.dirty) { this._updateContents(this.dom.content), this._updateDataAttributes(this.dom.point), this._updateStyle(this.dom.point); const t = this.editable.updateTime || this.editable.updateGroup; const e = (this.data.className ? ` ${this.data.className}` : '') + (this.selected ? ' vis-selected' : '') + (t ? ' vis-editable' : ' vis-readonly'); this.dom.point.className = `vis-item vis-point${e}`, this.dom.dot.className = `vis-item vis-dot${e}`; } }, n.prototype._getDomComponentsSizes = function () { return { dot: { width: this.dom.dot.offsetWidth, height: this.dom.dot.offsetHeight }, content: { width: this.dom.content.offsetWidth, height: this.dom.content.offsetHeight }, point: { width: this.dom.point.offsetWidth, height: this.dom.point.offsetHeight } }; }, n.prototype._updateDomComponentsSizes = function (t) { this.props.dot.width = t.dot.width, this.props.dot.height = t.dot.height, this.props.content.height = t.content.height, this.options.rtl ? this.dom.content.style.marginRight = `${2 * this.props.dot.width}px` : this.dom.content.style.marginLeft = `${2 * this.props.dot.width}px`, this.width = t.point.width, this.height = t.point.height, this.dom.dot.style.top = `${(this.height - this.props.dot.height) / 2}px`, this.options.rtl ? this.dom.dot.style.right = `${this.props.dot.width / 2}px` : this.dom.dot.style.left = `${this.props.dot.width / 2}px`, this.dirty = !1; }, n.prototype._repaintDomAdditionals = function () { this._repaintOnItemUpdateTimeTooltip(this.dom.point), this._repaintDragCenter(), this._repaintDeleteButton(this.dom.point); }, n.prototype.redraw = function (t) { let e; let i; const o = [this._createDomElement.bind(this), this._appendDomElement.bind(this), this._updateDirtyDomComponents.bind(this), function () { this.dirty && (e = this._getDomComponentsSizes()); }.bind(this), function () { this.dirty && this._updateDomComponentsSizes.bind(this)(e); }.bind(this), this._repaintDomAdditionals.bind(this)]; return t ? o : (o.forEach((t) => { i = t(); }), i); }, n.prototype.show = function () { this.displayed || this.redraw(); }, n.prototype.hide = function () { this.displayed && (this.dom.point.parentNode && this.dom.point.parentNode.removeChild(this.dom.point), this.displayed = !1); }, n.prototype.repositionX = function () { const t = this.conversion.toScreen(this.data.start); this.options.rtl ? (this.right = t - this.props.dot.width, this.dom.point.style.right = `${this.right}px`) : (this.left = t - this.props.dot.width, this.dom.point.style.left = `${this.left}px`); }, n.prototype.repositionY = function () { const t = this.options.orientation.item; const e = this.dom.point; e.style.top = t == 'top' ? `${this.top}px` : `${this.parent.height - this.top - this.height}px`; }, n.prototype.getWidthLeft = function () { return this.props.dot.width; }, n.prototype.getWidthRight = function () { return this.props.dot.width; }, t.exports = n; }, function (t, e, i) { const o = i(38); const n = i(69); const s = i(70); function r(t, e, i) { if (this.props = { content: { width: 0 } }, this.overflow = !1, t) { if (void 0 == t.start) throw new Error(`Property "start" missing in item ${t.id}`); if (void 0 == t.end) throw new Error(`Property "end" missing in item ${t.id}`); }o.call(this, t, e, i); }r.prototype = new o(null, null, null), r.prototype.baseClassName = 'vis-item vis-background', r.prototype.stack = !1, r.prototype.isVisible = function (t) { return this.data.start < t.end && this.data.end > t.start; }, r.prototype._createDomElement = function () { this.dom || (this.dom = {}, this.dom.box = document.createElement('div'), this.dom.frame = document.createElement('div'), this.dom.frame.className = 'vis-item-overflow', this.dom.box.appendChild(this.dom.frame), this.dom.content = document.createElement('div'), this.dom.content.className = 'vis-item-content', this.dom.frame.appendChild(this.dom.content), this.dirty = !0); }, r.prototype._appendDomElement = function () { if (!this.parent) throw new Error('Cannot redraw item: no parent attached'); if (!this.dom.box.parentNode) { const t = this.parent.dom.background; if (!t) throw new Error('Cannot redraw item: parent has no background container element'); t.appendChild(this.dom.box); } this.displayed = !0; }, r.prototype._updateDirtyDomComponents = function () { if (this.dirty) { this._updateContents(this.dom.content), this._updateDataAttributes(this.dom.content), this._updateStyle(this.dom.box); const t = (this.data.className ? ` ${this.data.className}` : '') + (this.selected ? ' vis-selected' : ''); this.dom.box.className = this.baseClassName + t; } }, r.prototype._getDomComponentsSizes = function () { return this.overflow = window.getComputedStyle(this.dom.content).overflow !== 'hidden', { content: { width: this.dom.content.offsetWidth } }; }, r.prototype._updateDomComponentsSizes = function (t) { this.props.content.width = t.content.width, this.height = 0, this.dirty = !1; }, r.prototype._repaintDomAdditionals = function () {}, r.prototype.redraw = function (t) { let e; let i; const o = [this._createDomElement.bind(this), this._appendDomElement.bind(this), this._updateDirtyDomComponents.bind(this), function () { this.dirty && (e = this._getDomComponentsSizes.bind(this)()); }.bind(this), function () { this.dirty && this._updateDomComponentsSizes.bind(this)(e); }.bind(this), this._repaintDomAdditionals.bind(this)]; return t ? o : (o.forEach((t) => { i = t(); }), i); }, r.prototype.show = s.prototype.show, r.prototype.hide = s.prototype.hide, r.prototype.repositionX = s.prototype.repositionX, r.prototype.repositionY = function (t) { let e; const i = this.options.orientation.item; if (void 0 !== this.data.subgroup) { const o = this.data.subgroup; this.dom.box.style.height = `${this.parent.subgroups[o].height}px`, this.dom.box.style.top = i == 'top' ? `${this.parent.top + this.parent.subgroups[o].top}px` : `${this.parent.top + this.parent.height - this.parent.subgroups[o].top - this.parent.subgroups[o].height}px`, this.dom.box.style.bottom = ''; } else this.parent instanceof n ? (e = Math.max(this.parent.height, this.parent.itemSet.body.domProps.center.height, this.parent.itemSet.body.domProps.centerContainer.height), this.dom.box.style.bottom = i == 'bottom' ? '0' : '', this.dom.box.style.top = i == 'top' ? '0' : '') : (e = this.parent.height, this.dom.box.style.top = `${this.parent.top}px`, this.dom.box.style.bottom = ''); this.dom.box.style.height = `${e}px`; }, t.exports = r; }, function (t, e, i) { Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(0); const n = a(o); const s = i(1); const r = a(s); function a(t) { return t && t.__esModule ? t : { default: t }; } const h = (function () { function t(e, i) { (0, n.default)(this, t), this.container = e, this.overflowMethod = i || 'cap', this.x = 0, this.y = 0, this.padding = 5, this.hidden = !1, this.frame = document.createElement('div'), this.frame.className = 'vis-tooltip', this.container.appendChild(this.frame); } return (0, r.default)(t, [{ key: 'setPosition', value(t, e) { this.x = parseInt(t), this.y = parseInt(e); } }, { key: 'setText', value(t) { t instanceof Element ? (this.frame.innerHTML = '', this.frame.appendChild(t)) : this.frame.innerHTML = t; } }, { key: 'show', value(t) { if (void 0 === t && (t = !0), !0 === t) { const e = this.frame.clientHeight; const i = this.frame.clientWidth; const o = this.frame.parentNode.clientHeight; const n = this.frame.parentNode.clientWidth; let s = 0; let r = 0; if (this.overflowMethod == 'flip') { let a = !1; let h = !0; this.y - e < this.padding && (h = !1), this.x + i > n - this.padding && (a = !0), s = a ? this.x - i : this.x, r = h ? this.y - e : this.y; } else r = this.y - e, r + e + this.padding > o && (r = o - e - this.padding), r < this.padding && (r = this.padding), s = this.x, s + i + this.padding > n && (s = n - i - this.padding), s < this.padding && (s = this.padding); this.frame.style.left = `${s}px`, this.frame.style.top = `${r}px`, this.frame.style.visibility = 'visible', this.hidden = !1; } else this.hide(); } }, { key: 'hide', value() { this.hidden = !0, this.frame.style.left = '0', this.frame.style.top = '0', this.frame.style.visibility = 'hidden'; } }, { key: 'destroy', value() { this.frame.parentNode.removeChild(this.frame); } }]), t; }()); e.default = h; }, function (t, e, i) {
      Object.defineProperty(e, '__esModule', { value: !0 }); const o = 'string'; const n = 'boolean'; const s = 'number'; const r = 'array'; const a = 'date'; const h = 'object'; const d = 'dom'; const l = 'moment'; const u = 'any'; const c = {
        configure: {
          enabled: { boolean: n }, filter: { boolean: n, function: 'function' }, container: { dom: d }, __type__: { object: h, boolean: n, function: 'function' },
        },
        align: { string: o },
        rtl: { boolean: n, undefined: 'undefined' },
        rollingMode: { follow: { boolean: n }, offset: { number: s, undefined: 'undefined' }, __type__: { object: h } },
        verticalScroll: { boolean: n, undefined: 'undefined' },
        horizontalScroll: { boolean: n, undefined: 'undefined' },
        autoResize: { boolean: n },
        throttleRedraw: { number: s },
        clickToUse: { boolean: n },
        dataAttributes: { string: o, array: r },
        editable: {
          add: { boolean: n, undefined: 'undefined' }, remove: { boolean: n, undefined: 'undefined' }, updateGroup: { boolean: n, undefined: 'undefined' }, updateTime: { boolean: n, undefined: 'undefined' }, overrideItems: { boolean: n, undefined: 'undefined' }, __type__: { boolean: n, object: h },
        },
        end: {
          number: s, date: a, string: o, moment: l,
        },
        format: {
          minorLabels: {
            millisecond: { string: o, undefined: 'undefined' }, second: { string: o, undefined: 'undefined' }, minute: { string: o, undefined: 'undefined' }, hour: { string: o, undefined: 'undefined' }, weekday: { string: o, undefined: 'undefined' }, day: { string: o, undefined: 'undefined' }, week: { string: o, undefined: 'undefined' }, month: { string: o, undefined: 'undefined' }, year: { string: o, undefined: 'undefined' }, __type__: { object: h, function: 'function' },
          },
          majorLabels: {
            millisecond: { string: o, undefined: 'undefined' }, second: { string: o, undefined: 'undefined' }, minute: { string: o, undefined: 'undefined' }, hour: { string: o, undefined: 'undefined' }, weekday: { string: o, undefined: 'undefined' }, day: { string: o, undefined: 'undefined' }, week: { string: o, undefined: 'undefined' }, month: { string: o, undefined: 'undefined' }, year: { string: o, undefined: 'undefined' }, __type__: { object: h, function: 'function' },
          },
          __type__: { object: h },
        },
        moment: { function: 'function' },
        groupOrder: { string: o, function: 'function' },
        groupEditable: {
          add: { boolean: n, undefined: 'undefined' }, remove: { boolean: n, undefined: 'undefined' }, order: { boolean: n, undefined: 'undefined' }, __type__: { boolean: n, object: h },
        },
        groupOrderSwap: { function: 'function' },
        height: { string: o, number: s },
        hiddenDates: {
          start: {
            date: a, number: s, string: o, moment: l,
          },
          end: {
            date: a, number: s, string: o, moment: l,
          },
          repeat: { string: o },
          __type__: { object: h, array: r },
        },
        itemsAlwaysDraggable: { item: { boolean: n, undefined: 'undefined' }, range: { boolean: n, undefined: 'undefined' }, __type__: { boolean: n, object: h } },
        limitSize: { boolean: n },
        locale: { string: o },
        locales: { __any__: { any: u }, __type__: { object: h } },
        margin: { axis: { number: s }, item: { horizontal: { number: s, undefined: 'undefined' }, vertical: { number: s, undefined: 'undefined' }, __type__: { object: h, number: s } }, __type__: { object: h, number: s } },
        max: {
          date: a, number: s, string: o, moment: l,
        },
        maxHeight: { number: s, string: o },
        maxMinorChars: { number: s },
        min: {
          date: a, number: s, string: o, moment: l,
        },
        minHeight: { number: s, string: o },
        moveable: { boolean: n },
        multiselect: { boolean: n },
        multiselectPerGroup: { boolean: n },
        onAdd: { function: 'function' },
        onDropObjectOnItem: { function: 'function' },
        onUpdate: { function: 'function' },
        onMove: { function: 'function' },
        onMoving: { function: 'function' },
        onRemove: { function: 'function' },
        onAddGroup: { function: 'function' },
        onMoveGroup: { function: 'function' },
        onRemoveGroup: { function: 'function' },
        onInitialDrawComplete: { function: 'function' },
        order: { function: 'function' },
        orientation: { axis: { string: o, undefined: 'undefined' }, item: { string: o, undefined: 'undefined' }, __type__: { string: o, object: h } },
        selectable: { boolean: n },
        showCurrentTime: { boolean: n },
        showMajorLabels: { boolean: n },
        showMinorLabels: { boolean: n },
        stack: { boolean: n },
        stackSubgroups: { boolean: n },
        snap: { function: 'function', null: 'null' },
        start: {
          date: a, number: s, string: o, moment: l,
        },
        template: { function: 'function' },
        groupTemplate: { function: 'function' },
        visibleFrameTemplate: { string: o, function: 'function' },
        showTooltips: { boolean: n },
        tooltip: { followMouse: { boolean: n }, overflowMethod: { string: ['cap', 'flip'] }, __type__: { object: h } },
        tooltipOnItemUpdateTime: { template: { function: 'function' }, __type__: { boolean: n, object: h } },
        timeAxis: { scale: { string: o, undefined: 'undefined' }, step: { number: s, undefined: 'undefined' }, __type__: { object: h } },
        type: { string: o },
        width: { string: o, number: s },
        zoomable: { boolean: n },
        zoomKey: { string: ['ctrlKey', 'altKey', 'metaKey', ''] },
        zoomMax: { number: s },
        zoomMin: { number: s },
        __type__: { object: h },
      }; const p = {
        global: {
          align: ['center', 'left', 'right'],
          direction: !1,
          autoResize: !0,
          clickToUse: !1,
          editable: {
            add: !1, remove: !1, updateGroup: !1, updateTime: !1,
          },
          end: '',
          format: {
            minorLabels: {
              millisecond: 'SSS', second: 's', minute: 'HH:mm', hour: 'HH:mm', weekday: 'ddd D', day: 'D', week: 'w', month: 'MMM', year: 'YYYY',
            },
            majorLabels: {
              millisecond: 'HH:mm:ss', second: 'D MMMM HH:mm', minute: 'ddd D MMMM', hour: 'ddd D MMMM', weekday: 'MMMM YYYY', day: 'MMMM YYYY', week: 'MMMM YYYY', month: 'YYYY', year: '',
            },
          },
          groupsDraggable: !1,
          height: '',
          locale: '',
          margin: { axis: [20, 0, 100, 1], item: { horizontal: [10, 0, 100, 1], vertical: [10, 0, 100, 1] } },
          max: '',
          maxHeight: '',
          maxMinorChars: [7, 0, 20, 1],
          min: '',
          minHeight: '',
          moveable: !1,
          multiselect: !1,
          multiselectPerGroup: !1,
          orientation: { axis: ['both', 'bottom', 'top'], item: ['bottom', 'top'] },
          selectable: !0,
          showCurrentTime: !1,
          showMajorLabels: !0,
          showMinorLabels: !0,
          stack: !0,
          stackSubgroups: !0,
          start: '',
          showTooltips: !0,
          tooltip: { followMouse: !1, overflowMethod: 'flip' },
          tooltipOnItemUpdateTime: !1,
          type: ['box', 'point', 'range', 'background'],
          width: '100%',
          zoomable: !0,
          zoomKey: ['ctrlKey', 'altKey', 'metaKey', ''],
          zoomMax: [31536e10, 10, 31536e10, 1],
          zoomMin: [10, 10, 31536e10, 1],
        },
      }; e.allOptions = c, e.configureOptions = p;
    }, function (t, e, i) {
      const o = i(6); const n = s(o); function s(t) { return t && t.__esModule ? t : { default: t }; } const r = i(2); const a = i(14); const h = i(11); const d = i(12); const l = i(16); const u = i(107); const c = i(109); const p = i(112); const f = i(110); const m = i(111); const v = i(72); const g = '__ungrouped__'; function y(t, e) {
        this.id = r.randomUUID(), this.body = t, this.defaultOptions = {
          yAxisOrientation: 'left', defaultGroup: 'default', sort: !0, sampling: !0, stack: !1, graphHeight: '400px', shaded: { enabled: !1, orientation: 'bottom' }, style: 'line', barChart: { width: 50, sideBySide: !1, align: 'center' }, interpolation: { enabled: !0, parametrization: 'centripetal', alpha: 0.5 }, drawPoints: { enabled: !0, size: 6, style: 'square' }, dataAxis: {}, legend: {}, groups: { visibility: {} },
        }, this.options = r.extend({}, this.defaultOptions), this.dom = {}, this.props = {}, this.hammer = null, this.groups = {}, this.abortedGraphUpdate = !1, this.updateSVGheight = !1, this.updateSVGheightOnResize = !1, this.forceGraphUpdate = !0; const i = this; this.itemsData = null, this.groupsData = null, this.itemListeners = { add(t, e, o) { i._onAdd(e.items); }, update(t, e, o) { i._onUpdate(e.items); }, remove(t, e, o) { i._onRemove(e.items); } }, this.groupListeners = { add(t, e, o) { i._onAddGroups(e.items); }, update(t, e, o) { i._onUpdateGroups(e.items); }, remove(t, e, o) { i._onRemoveGroups(e.items); } }, this.items = {}, this.selection = [], this.lastStart = this.body.range.start, this.touchParams = {}, this.svgElements = {}, this.setOptions(e), this.groupsUsingDefaultStyles = [0], this.body.emitter.on('rangechanged', () => { i.lastStart = i.body.range.start, i.svg.style.left = r.option.asSize(-i.props.width), i.forceGraphUpdate = !0, i.redraw.call(i); }), this._create(), this.framework = {
          svg: this.svg, svgElements: this.svgElements, options: this.options, groups: this.groups,
        };
      }y.prototype = new l(), y.prototype._create = function () { const t = document.createElement('div'); t.className = 'vis-line-graph', this.dom.frame = t, this.svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg'), this.svg.style.position = 'relative', this.svg.style.height = `${(`${this.options.graphHeight}`).replace('px', '')}px`, this.svg.style.display = 'block', t.appendChild(this.svg), this.options.dataAxis.orientation = 'left', this.yAxisLeft = new u(this.body, this.options.dataAxis, this.svg, this.options.groups), this.options.dataAxis.orientation = 'right', this.yAxisRight = new u(this.body, this.options.dataAxis, this.svg, this.options.groups), delete this.options.dataAxis.orientation, this.legendLeft = new p(this.body, this.options.legend, 'left', this.options.groups), this.legendRight = new p(this.body, this.options.legend, 'right', this.options.groups), this.show(); }, y.prototype.setOptions = function (t) { if (t) { const e = ['sampling', 'defaultGroup', 'stack', 'height', 'graphHeight', 'yAxisOrientation', 'style', 'barChart', 'dataAxis', 'sort', 'groups']; void 0 === t.graphHeight && void 0 !== t.height ? (this.updateSVGheight = !0, this.updateSVGheightOnResize = !0) : void 0 !== this.body.domProps.centerContainer.height && void 0 !== t.graphHeight && parseInt((`${t.graphHeight}`).replace('px', '')) < this.body.domProps.centerContainer.height && (this.updateSVGheight = !0), r.selectiveDeepExtend(e, this.options, t), r.mergeOptions(this.options, t, 'interpolation'), r.mergeOptions(this.options, t, 'drawPoints'), r.mergeOptions(this.options, t, 'shaded'), r.mergeOptions(this.options, t, 'legend'), t.interpolation && (0, n.default)(t.interpolation) == 'object' && t.interpolation.parametrization && (t.interpolation.parametrization == 'uniform' ? this.options.interpolation.alpha = 0 : t.interpolation.parametrization == 'chordal' ? this.options.interpolation.alpha = 1 : (this.options.interpolation.parametrization = 'centripetal', this.options.interpolation.alpha = 0.5)), this.yAxisLeft && void 0 !== t.dataAxis && (this.yAxisLeft.setOptions(this.options.dataAxis), this.yAxisRight.setOptions(this.options.dataAxis)), this.legendLeft && void 0 !== t.legend && (this.legendLeft.setOptions(this.options.legend), this.legendRight.setOptions(this.options.legend)), this.groups.hasOwnProperty(g) && this.groups[g].setOptions(t); } this.dom.frame && (this.forceGraphUpdate = !0, this.body.emitter.emit('_change', { queue: !0 })); }, y.prototype.hide = function () { this.dom.frame.parentNode && this.dom.frame.parentNode.removeChild(this.dom.frame); }, y.prototype.show = function () { this.dom.frame.parentNode || this.body.dom.center.appendChild(this.dom.frame); }, y.prototype.setItems = function (t) { let e; const i = this; const o = this.itemsData; if (t) { if (!(t instanceof h || t instanceof d)) throw new TypeError('Data must be an instance of DataSet or DataView'); this.itemsData = t; } else this.itemsData = null; if (o && (r.forEach(this.itemListeners, (t, e) => { o.off(e, t); }), e = o.getIds(), this._onRemove(e)), this.itemsData) { const n = this.id; r.forEach(this.itemListeners, (t, e) => { i.itemsData.on(e, t, n); }), e = this.itemsData.getIds(), this._onAdd(e); } }, y.prototype.setGroups = function (t) { let e; const i = this; if (this.groupsData) { r.forEach(this.groupListeners, (t, e) => { i.groupsData.off(e, t); }), e = this.groupsData.getIds(), this.groupsData = null; for (let o = 0; o < e.length; o++) this._removeGroup(e[o]); } if (t) { if (!(t instanceof h || t instanceof d)) throw new TypeError('Data must be an instance of DataSet or DataView'); this.groupsData = t; } else this.groupsData = null; if (this.groupsData) { const n = this.id; r.forEach(this.groupListeners, (t, e) => { i.groupsData.on(e, t, n); }), e = this.groupsData.getIds(), this._onAddGroups(e); } }, y.prototype._onUpdate = function (t) { this._updateAllGroupData(t); }, y.prototype._onAdd = function (t) { this._onUpdate(t); }, y.prototype._onRemove = function (t) { this._onUpdate(t); }, y.prototype._onUpdateGroups = function (t) { this._updateAllGroupData(null, t); }, y.prototype._onAddGroups = function (t) { this._onUpdateGroups(t); }, y.prototype._onRemoveGroups = function (t) { for (let e = 0; e < t.length; e++) this._removeGroup(t[e]); this.forceGraphUpdate = !0, this.body.emitter.emit('_change', { queue: !0 }); }, y.prototype._removeGroup = function (t) { this.groups.hasOwnProperty(t) && (this.groups[t].options.yAxisOrientation == 'right' ? (this.yAxisRight.removeGroup(t), this.legendRight.removeGroup(t), this.legendRight.redraw()) : (this.yAxisLeft.removeGroup(t), this.legendLeft.removeGroup(t), this.legendLeft.redraw()), delete this.groups[t]); }, y.prototype._updateGroup = function (t, e) { this.groups.hasOwnProperty(e) ? (this.groups[e].update(t), this.groups[e].options.yAxisOrientation == 'right' ? (this.yAxisRight.updateGroup(e, this.groups[e]), this.legendRight.updateGroup(e, this.groups[e]), this.yAxisLeft.removeGroup(e), this.legendLeft.removeGroup(e)) : (this.yAxisLeft.updateGroup(e, this.groups[e]), this.legendLeft.updateGroup(e, this.groups[e]), this.yAxisRight.removeGroup(e), this.legendRight.removeGroup(e))) : (this.groups[e] = new c(t, e, this.options, this.groupsUsingDefaultStyles), this.groups[e].options.yAxisOrientation == 'right' ? (this.yAxisRight.addGroup(e, this.groups[e]), this.legendRight.addGroup(e, this.groups[e])) : (this.yAxisLeft.addGroup(e, this.groups[e]), this.legendLeft.addGroup(e, this.groups[e]))), this.legendLeft.redraw(), this.legendRight.redraw(); }, y.prototype._updateAllGroupData = function (t, e) { if (this.itemsData != null) { const i = {}; const o = this.itemsData.get(); const n = this.itemsData._fieldId; const s = {}; t && t.map((t) => { s[t] = t; }); for (var a = {}, h = 0; h < o.length; h++) { var d = o[h]; var l = d.group; l !== null && void 0 !== l || (l = g), a.hasOwnProperty(l) ? a[l]++ : a[l] = 1; } const u = {}; if (!e && t) for (l in this.groups) if (this.groups.hasOwnProperty(l)) { v = this.groups[l]; const c = v.getItems(); i[l] = c.filter(t => u[t[n]] = t[n], t[n] !== s[t[n]]); const p = a[l]; a[l] -= i[l].length, i[l].length < p && (i[l][p - 1] = {}); } for (h = 0; h < o.length; h++) if (d = o[h], l = d.group, l !== null && void 0 !== l || (l = g), e || !t || d[n] === s[d[n]] || !u.hasOwnProperty(d[n])) { i.hasOwnProperty(l) || (i[l] = new Array(a[l])); const f = r.bridgeObject(d); f.x = r.convert(d.x, 'Date'), f.end = r.convert(d.end, 'Date'), f.orginalY = d.y, f.y = Number(d.y), f[n] = d[n]; const m = i[l].length - a[l]--; i[l][m] = f; } for (l in this.groups) this.groups.hasOwnProperty(l) && (i.hasOwnProperty(l) || (i[l] = new Array(0))); for (l in i) if (i.hasOwnProperty(l)) if (i[l].length == 0) this.groups.hasOwnProperty(l) && this._removeGroup(l); else { var v = void 0; void 0 != this.groupsData && (v = this.groupsData.get(l)), void 0 == v && (v = { id: l, content: this.options.defaultGroup + l }), this._updateGroup(v, l), this.groups[l].setItems(i[l]); } this.forceGraphUpdate = !0, this.body.emitter.emit('_change', { queue: !0 }); } }, y.prototype.redraw = function () { let t = !1; this.props.width = this.dom.frame.offsetWidth, this.props.height = this.body.domProps.centerContainer.height - this.body.domProps.border.top - this.body.domProps.border.bottom, t = this._isResized() || t; const e = this.body.range.end - this.body.range.start; const i = e != this.lastVisibleInterval; if (this.lastVisibleInterval = e, t == 1 && (this.svg.style.width = r.option.asSize(3 * this.props.width), this.svg.style.left = r.option.asSize(-this.props.width), (`${this.options.height}`).indexOf('%') == -1 && this.updateSVGheightOnResize != 1 || (this.updateSVGheight = !0)), this.updateSVGheight == 1 ? (this.options.graphHeight != `${this.props.height}px` && (this.options.graphHeight = `${this.props.height}px`, this.svg.style.height = `${this.props.height}px`), this.updateSVGheight = !1) : this.svg.style.height = `${(`${this.options.graphHeight}`).replace('px', '')}px`, t == 1 || i == 1 || this.abortedGraphUpdate == 1 || this.forceGraphUpdate == 1)t = this._updateGraph() || t, this.forceGraphUpdate = !1; else if (this.lastStart != 0) { const o = this.body.range.start - this.lastStart; const n = this.body.range.end - this.body.range.start; if (this.props.width != 0) { const s = this.props.width / n; const a = o * s; this.svg.style.left = `${-this.props.width - a}px`; } } return this.legendLeft.redraw(), this.legendRight.redraw(), t; }, y.prototype._getSortedGroupIds = function () { const t = []; for (const e in this.groups) if (this.groups.hasOwnProperty(e)) { const i = this.groups[e]; i.visible != 1 || void 0 !== this.options.groups.visibility[e] && this.options.groups.visibility[e] != 1 || t.push({ id: e, zIndex: i.options.zIndex }); }r.insertSort(t, (t, e) => { let i = t.zIndex; let o = e.zIndex; return void 0 === i && (i = 0), void 0 === o && (o = 0), i == o ? 0 : i < o ? -1 : 1; }); for (var o = new Array(t.length), n = 0; n < t.length; n++)o[n] = t[n].id; return o; }, y.prototype._updateGraph = function () { if (a.prepareElements(this.svgElements), this.props.width != 0 && this.itemsData != null) { let t; let e; const i = {}; let o = !1; const n = this.body.util.toGlobalTime(-this.body.domProps.root.width); const s = this.body.util.toGlobalTime(2 * this.body.domProps.root.width); const r = this._getSortedGroupIds(); if (r.length > 0) { const h = {}; for (this._getRelevantData(r, h, n, s), this._applySampling(r, h), e = 0; e < r.length; e++) this._convertXcoordinates(h[r[e]]); if (this._getYRanges(r, h, i), o = this._updateYAxis(r, i), o == 1) return a.cleanupElements(this.svgElements), this.abortedGraphUpdate = !0, !0; this.abortedGraphUpdate = !1; let d = void 0; for (e = 0; e < r.length; e++)t = this.groups[r[e]], !0 === this.options.stack && this.options.style === 'line' && (void 0 != t.options.excludeFromStacking && t.options.excludeFromStacking || (void 0 != d && (this._stack(h[t.id], h[d.id]), t.options.shaded.enabled == 1 && t.options.shaded.orientation !== 'group' && (t.options.shaded.orientation == 'top' && d.options.shaded.orientation !== 'group' ? (d.options.shaded.orientation = 'group', d.options.shaded.groupId = t.id) : (t.options.shaded.orientation = 'group', t.options.shaded.groupId = d.id))), d = t)), this._convertYcoordinates(h[r[e]], t); const l = {}; for (e = 0; e < r.length; e++) if (t = this.groups[r[e]], t.options.style === 'line' && t.options.shaded.enabled == 1) { const u = h[r[e]]; if (u == null || u.length == 0) continue; if (l.hasOwnProperty(r[e]) || (l[r[e]] = m.calcPath(u, t)), t.options.shaded.orientation === 'group') { const c = t.options.shaded.groupId; if (r.indexOf(c) === -1) { console.log(`${t.id}: Unknown shading group target given:${c}`); continue; }l.hasOwnProperty(c) || (l[c] = m.calcPath(h[c], this.groups[c])), m.drawShading(l[r[e]], t, l[c], this.framework); } else m.drawShading(l[r[e]], t, void 0, this.framework); } for (f.draw(r, h, this.framework), e = 0; e < r.length; e++) if (t = this.groups[r[e]], h[r[e]].length > 0) switch (t.options.style) { case 'line': l.hasOwnProperty(r[e]) || (l[r[e]] = m.calcPath(h[r[e]], t)), m.draw(l[r[e]], t, this.framework); case 'point': case 'points': t.options.style != 'point' && t.options.style != 'points' && t.options.drawPoints.enabled != 1 || v.draw(h[r[e]], t, this.framework); break; case 'bar': default: } } } return a.cleanupElements(this.svgElements), !1; }, y.prototype._stack = function (t, e) { let i; let o; let n; let s; let r; i = 0; for (let a = 0; a < t.length; a++) { s = void 0, r = void 0; for (let h = i; h < e.length; h++) { if (e[h].x === t[a].x) { s = e[h], r = e[h], i = h; break; } if (e[h].x > t[a].x) { r = e[h], s = h == 0 ? r : e[h - 1], i = h; break; } } void 0 === r && (s = e[e.length - 1], r = e[e.length - 1]), o = r.x - s.x, n = r.y - s.y, t[a].y = o == 0 ? t[a].orginalY + r.y : t[a].orginalY + n / o * (t[a].x - s.x) + s.y; } }, y.prototype._getRelevantData = function (t, e, i, o) { let n; let s; let a; let h; if (t.length > 0) for (s = 0; s < t.length; s++) { n = this.groups[t[s]]; const d = n.getItems(); if (n.options.sort == 1) { const l = function (t, e) { return t.getTime() == e.getTime() ? 0 : t < e ? -1 : 1; }; const u = Math.max(0, r.binarySearchValue(d, i, 'x', 'before', l)); let c = Math.min(d.length, r.binarySearchValue(d, o, 'x', 'after', l) + 1); c <= 0 && (c = d.length); const p = new Array(c - u); for (a = u; a < c; a++)h = n.itemsData[a], p[a - u] = h; e[t[s]] = p; } else e[t[s]] = n.itemsData; } }, y.prototype._applySampling = function (t, e) { let i; if (t.length > 0) for (let o = 0; o < t.length; o++) if (i = this.groups[t[o]], i.options.sampling == 1) { const n = e[t[o]]; if (n.length > 0) { let s = 1; const r = n.length; const a = this.body.util.toGlobalScreen(n[n.length - 1].x) - this.body.util.toGlobalScreen(n[0].x); const h = r / a; s = Math.min(Math.ceil(0.2 * r), Math.max(1, Math.round(h))); for (var d = new Array(r), l = 0; l < r; l += s) { const u = Math.round(l / s); d[u] = n[l]; }e[t[o]] = d.splice(0, Math.round(r / s)); } } }, y.prototype._getYRanges = function (t, e, i) { let o; let n; let s; let r; let a = []; let h = []; if (t.length > 0) { for (s = 0; s < t.length; s++)o = e[t[s]], r = this.groups[t[s]].options, o.length > 0 && (n = this.groups[t[s]], !0 === r.stack && r.style === 'bar' ? r.yAxisOrientation === 'left' ? a = a.concat(o) : h = h.concat(o) : i[t[s]] = n.getYRange(o, t[s])); f.getStackedYRange(a, i, t, '__barStackLeft', 'left'), f.getStackedYRange(h, i, t, '__barStackRight', 'right'); } }, y.prototype._updateYAxis = function (t, e) { let i; let o; let n = !1; let s = !1; let r = !1; let a = 1e9; let h = 1e9; let d = -1e9; let l = -1e9; if (t.length > 0) { for (var u = 0; u < t.length; u++) { const c = this.groups[t[u]]; c && c.options.yAxisOrientation != 'right' ? (s = !0, a = 1e9, d = -1e9) : c && c.options.yAxisOrientation && (r = !0, h = 1e9, l = -1e9); } for (u = 0; u < t.length; u++)e.hasOwnProperty(t[u]) && !0 !== e[t[u]].ignore && (i = e[t[u]].min, o = e[t[u]].max, e[t[u]].yAxisOrientation != 'right' ? (s = !0, a = a > i ? i : a, d = d < o ? o : d) : (r = !0, h = h > i ? i : h, l = l < o ? o : l)); s == 1 && this.yAxisLeft.setRange(a, d), r == 1 && this.yAxisRight.setRange(h, l); }n = this._toggleAxisVisiblity(s, this.yAxisLeft) || n, n = this._toggleAxisVisiblity(r, this.yAxisRight) || n, r == 1 && s == 1 ? (this.yAxisLeft.drawIcons = !0, this.yAxisRight.drawIcons = !0) : (this.yAxisLeft.drawIcons = !1, this.yAxisRight.drawIcons = !1), this.yAxisRight.master = !s, this.yAxisRight.masterAxis = this.yAxisLeft, this.yAxisRight.master == 0 ? (this.yAxisLeft.lineOffset = r == 1 ? this.yAxisRight.width : 0, n = this.yAxisLeft.redraw() || n, n = this.yAxisRight.redraw() || n) : n = this.yAxisRight.redraw() || n; const p = ['__barStackLeft', '__barStackRight', '__lineStackLeft', '__lineStackRight']; for (u = 0; u < p.length; u++)t.indexOf(p[u]) != -1 && t.splice(t.indexOf(p[u]), 1); return n; }, y.prototype._toggleAxisVisiblity = function (t, e) { let i = !1; return t == 0 ? e.dom.frame.parentNode && e.hidden == 0 && (e.hide(), i = !0) : e.dom.frame.parentNode || e.hidden != 1 || (e.show(), i = !0), i; }, y.prototype._convertXcoordinates = function (t) { for (let e = this.body.util.toScreen, i = 0; i < t.length; i++)t[i].screen_x = e(t[i].x) + this.props.width, t[i].screen_y = t[i].y, void 0 != t[i].end ? t[i].screen_end = e(t[i].end) + this.props.width : t[i].screen_end = void 0; }, y.prototype._convertYcoordinates = function (t, e) { let i = this.yAxisLeft; const o = Number(this.svg.style.height.replace('px', '')); e.options.yAxisOrientation == 'right' && (i = this.yAxisRight); for (let n = 0; n < t.length; n++)t[n].screen_y = Math.round(i.convertValue(t[n].y)); e.setZeroPosition(Math.min(o, i.convertValue(0))); }, t.exports = y;
    }, function (t, e, i) {
      const o = i(8); const n = s(o); function s(t) { return t && t.__esModule ? t : { default: t }; } const r = i(2); const a = i(14); const h = i(16); const d = i(108); function l(t, e, i, o) {
        this.id = r.randomUUID(), this.body = t, this.defaultOptions = {
          orientation: 'left', showMinorLabels: !0, showMajorLabels: !0, icons: !1, majorLinesOffset: 7, minorLinesOffset: 4, labelOffsetX: 10, labelOffsetY: 2, iconWidth: 20, width: '40px', visible: !0, alignZeros: !0, left: { range: { min: void 0, max: void 0 }, format(t) { return `${parseFloat(t.toPrecision(3))}`; }, title: { text: void 0, style: void 0 } }, right: { range: { min: void 0, max: void 0 }, format(t) { return `${parseFloat(t.toPrecision(3))}`; }, title: { text: void 0, style: void 0 } },
        }, this.linegraphOptions = o, this.linegraphSVG = i, this.props = {}, this.DOMelements = { lines: {}, labels: {}, title: {} }, this.dom = {}, this.scale = void 0, this.range = { start: 0, end: 0 }, this.options = r.extend({}, this.defaultOptions), this.conversionFactor = 1, this.setOptions(e), this.width = Number((`${this.options.width}`).replace('px', '')), this.minWidth = this.width, this.height = this.linegraphSVG.getBoundingClientRect().height, this.hidden = !1, this.stepPixels = 25, this.zeroCrossing = -1, this.amountOfSteps = -1, this.lineOffset = 0, this.master = !0, this.masterAxis = null, this.svgElements = {}, this.iconsRemoved = !1, this.groups = {}, this.amountOfGroups = 0, this._create(), this.framework = {
          svg: this.svg, svgElements: this.svgElements, options: this.options, groups: this.groups,
        }; const n = this; this.body.emitter.on('verticalDrag', () => { n.dom.lineContainer.style.top = `${n.body.domProps.scrollTop}px`; });
      }l.prototype = new h(), l.prototype.addGroup = function (t, e) { this.groups.hasOwnProperty(t) || (this.groups[t] = e), this.amountOfGroups += 1; }, l.prototype.updateGroup = function (t, e) { this.groups.hasOwnProperty(t) || (this.amountOfGroups += 1), this.groups[t] = e; }, l.prototype.removeGroup = function (t) { this.groups.hasOwnProperty(t) && (delete this.groups[t], this.amountOfGroups -= 1); }, l.prototype.setOptions = function (t) { if (t) { let e = !1; this.options.orientation != t.orientation && void 0 !== t.orientation && (e = !0); const i = ['orientation', 'showMinorLabels', 'showMajorLabels', 'icons', 'majorLinesOffset', 'minorLinesOffset', 'labelOffsetX', 'labelOffsetY', 'iconWidth', 'width', 'visible', 'left', 'right', 'alignZeros']; r.selectiveDeepExtend(i, this.options, t), this.minWidth = Number((`${this.options.width}`).replace('px', '')), !0 === e && this.dom.frame && (this.hide(), this.show()); } }, l.prototype._create = function () { this.dom.frame = document.createElement('div'), this.dom.frame.style.width = this.options.width, this.dom.frame.style.height = this.height, this.dom.lineContainer = document.createElement('div'), this.dom.lineContainer.style.width = '100%', this.dom.lineContainer.style.height = this.height, this.dom.lineContainer.style.position = 'relative', this.svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg'), this.svg.style.position = 'absolute', this.svg.style.top = '0px', this.svg.style.height = '100%', this.svg.style.width = '100%', this.svg.style.display = 'block', this.dom.frame.appendChild(this.svg); }, l.prototype._redrawGroupIcons = function () { let t; a.prepareElements(this.svgElements); const e = this.options.iconWidth; const i = 15; const o = 4; let s = o + 0.5 * i; t = this.options.orientation === 'left' ? o : this.width - e - o; const r = (0, n.default)(this.groups); r.sort((t, e) => (t < e ? -1 : 1)); for (let h = 0; h < r.length; h++) { const d = r[h]; !0 !== this.groups[d].visible || void 0 !== this.linegraphOptions.visibility[d] && !0 !== this.linegraphOptions.visibility[d] || (this.groups[d].getLegend(e, i, this.framework, t, s), s += i + o); }a.cleanupElements(this.svgElements), this.iconsRemoved = !1; }, l.prototype._cleanupIcons = function () { !1 === this.iconsRemoved && (a.prepareElements(this.svgElements), a.cleanupElements(this.svgElements), this.iconsRemoved = !0); }, l.prototype.show = function () { this.hidden = !1, this.dom.frame.parentNode || (this.options.orientation === 'left' ? this.body.dom.left.appendChild(this.dom.frame) : this.body.dom.right.appendChild(this.dom.frame)), this.dom.lineContainer.parentNode || this.body.dom.backgroundHorizontal.appendChild(this.dom.lineContainer); }, l.prototype.hide = function () { this.hidden = !0, this.dom.frame.parentNode && this.dom.frame.parentNode.removeChild(this.dom.frame), this.dom.lineContainer.parentNode && this.dom.lineContainer.parentNode.removeChild(this.dom.lineContainer); }, l.prototype.setRange = function (t, e) { this.range.start = t, this.range.end = e; }, l.prototype.redraw = function () { let t = !1; let e = 0; for (const i in this.dom.lineContainer.style.top = `${this.body.domProps.scrollTop}px`, this.groups) this.groups.hasOwnProperty(i) && (!0 !== this.groups[i].visible || void 0 !== this.linegraphOptions.visibility[i] && !0 !== this.linegraphOptions.visibility[i] || e++); if (this.amountOfGroups === 0 || e === 0) this.hide(); else { this.show(), this.height = Number(this.linegraphSVG.style.height.replace('px', '')), this.dom.lineContainer.style.height = `${this.height}px`, this.width = !0 === this.options.visible ? Number((`${this.options.width}`).replace('px', '')) : 0; const o = this.props; const n = this.dom.frame; n.className = 'vis-data-axis', this._calculateCharSize(); const s = this.options.orientation; const r = this.options.showMinorLabels; const a = this.options.showMajorLabels; o.minorLabelHeight = r ? o.minorCharHeight : 0, o.majorLabelHeight = a ? o.majorCharHeight : 0, o.minorLineWidth = this.body.dom.backgroundHorizontal.offsetWidth - this.lineOffset - this.width + 2 * this.options.minorLinesOffset, o.minorLineHeight = 1, o.majorLineWidth = this.body.dom.backgroundHorizontal.offsetWidth - this.lineOffset - this.width + 2 * this.options.majorLinesOffset, o.majorLineHeight = 1, s === 'left' ? (n.style.top = '0', n.style.left = '0', n.style.bottom = '', n.style.width = `${this.width}px`, n.style.height = `${this.height}px`, this.props.width = this.body.domProps.left.width, this.props.height = this.body.domProps.left.height) : (n.style.top = '', n.style.bottom = '0', n.style.left = '0', n.style.width = `${this.width}px`, n.style.height = `${this.height}px`, this.props.width = this.body.domProps.right.width, this.props.height = this.body.domProps.right.height), t = this._redrawLabels(), t = this._isResized() || t, !0 === this.options.icons ? this._redrawGroupIcons() : this._cleanupIcons(), this._redrawTitle(s); } return t; }, l.prototype._redrawLabels = function () {
        const t = this; let e = !1; a.prepareElements(this.DOMelements.lines), a.prepareElements(this.DOMelements.labels); const i = this.options.orientation; const o = void 0 != this.options[i].range ? this.options[i].range : {}; let
          n = !0; void 0 != o.max && (this.range.end = o.max, n = !1); let s = !0; void 0 != o.min && (this.range.start = o.min, s = !1), this.scale = new d(this.range.start, this.range.end, s, n, this.dom.frame.offsetHeight, this.props.majorCharHeight, this.options.alignZeros, this.options[i].format), !1 === this.master && void 0 != this.masterAxis && this.scale.followScale(this.masterAxis.scale), this.maxLabelSize = 0; const r = this.scale.getLines(); r.forEach((e) => { const o = e.y; const n = e.major; t.options.showMinorLabels && !1 === n && t._redrawLabel(o - 2, e.val, i, 'vis-y-axis vis-minor', t.props.minorCharHeight), n && o >= 0 && t._redrawLabel(o - 2, e.val, i, 'vis-y-axis vis-major', t.props.majorCharHeight), !0 === t.master && (n ? t._redrawLine(o, i, 'vis-grid vis-horizontal vis-major', t.options.majorLinesOffset, t.props.majorLineWidth) : t._redrawLine(o, i, 'vis-grid vis-horizontal vis-minor', t.options.minorLinesOffset, t.props.minorLineWidth)); }); let h = 0; void 0 !== this.options[i].title && void 0 !== this.options[i].title.text && (h = this.props.titleCharHeight); const l = !0 === this.options.icons ? Math.max(this.options.iconWidth, h) + this.options.labelOffsetX + 15 : h + this.options.labelOffsetX + 15; return this.maxLabelSize > this.width - l && !0 === this.options.visible ? (this.width = this.maxLabelSize + l, this.options.width = `${this.width}px`, a.cleanupElements(this.DOMelements.lines), a.cleanupElements(this.DOMelements.labels), this.redraw(), e = !0) : this.maxLabelSize < this.width - l && !0 === this.options.visible && this.width > this.minWidth ? (this.width = Math.max(this.minWidth, this.maxLabelSize + l), this.options.width = `${this.width}px`, a.cleanupElements(this.DOMelements.lines), a.cleanupElements(this.DOMelements.labels), this.redraw(), e = !0) : (a.cleanupElements(this.DOMelements.lines), a.cleanupElements(this.DOMelements.labels), e = !1), e;
      }, l.prototype.convertValue = function (t) { return this.scale.convertValue(t); }, l.prototype.screenToValue = function (t) { return this.scale.screenToValue(t); }, l.prototype._redrawLabel = function (t, e, i, o, n) { const s = a.getDOMElement('div', this.DOMelements.labels, this.dom.frame); s.className = o, s.innerHTML = e, i === 'left' ? (s.style.left = `-${this.options.labelOffsetX}px`, s.style.textAlign = 'right') : (s.style.right = `-${this.options.labelOffsetX}px`, s.style.textAlign = 'left'), s.style.top = `${t - 0.5 * n + this.options.labelOffsetY}px`, e += ''; const r = Math.max(this.props.majorCharWidth, this.props.minorCharWidth); this.maxLabelSize < e.length * r && (this.maxLabelSize = e.length * r); }, l.prototype._redrawLine = function (t, e, i, o, n) { if (!0 === this.master) { const s = a.getDOMElement('div', this.DOMelements.lines, this.dom.lineContainer); s.className = i, s.innerHTML = '', e === 'left' ? s.style.left = `${this.width - o}px` : s.style.right = `${this.width - o}px`, s.style.width = `${n}px`, s.style.top = `${t}px`; } }, l.prototype._redrawTitle = function (t) { if (a.prepareElements(this.DOMelements.title), void 0 !== this.options[t].title && void 0 !== this.options[t].title.text) { const e = a.getDOMElement('div', this.DOMelements.title, this.dom.frame); e.className = `vis-y-axis vis-title vis-${t}`, e.innerHTML = this.options[t].title.text, void 0 !== this.options[t].title.style && r.addCssText(e, this.options[t].title.style), t === 'left' ? e.style.left = `${this.props.titleCharHeight}px` : e.style.right = `${this.props.titleCharHeight}px`, e.style.width = `${this.height}px`; }a.cleanupElements(this.DOMelements.title); }, l.prototype._calculateCharSize = function () { if (!('minorCharHeight' in this.props)) { const t = document.createTextNode('0'); const e = document.createElement('div'); e.className = 'vis-y-axis vis-minor vis-measure', e.appendChild(t), this.dom.frame.appendChild(e), this.props.minorCharHeight = e.clientHeight, this.props.minorCharWidth = e.clientWidth, this.dom.frame.removeChild(e); } if (!('majorCharHeight' in this.props)) { const i = document.createTextNode('0'); const o = document.createElement('div'); o.className = 'vis-y-axis vis-major vis-measure', o.appendChild(i), this.dom.frame.appendChild(o), this.props.majorCharHeight = o.clientHeight, this.props.majorCharWidth = o.clientWidth, this.dom.frame.removeChild(o); } if (!('titleCharHeight' in this.props)) { const n = document.createTextNode('0'); const s = document.createElement('div'); s.className = 'vis-y-axis vis-title vis-measure', s.appendChild(n), this.dom.frame.appendChild(s), this.props.titleCharHeight = s.clientHeight, this.props.titleCharWidth = s.clientWidth, this.dom.frame.removeChild(s); } }, t.exports = l;
    }, function (t, e, i) { function o(t, e, i, o, n, s) { const r = arguments.length > 6 && void 0 !== arguments[6] && arguments[6]; const a = arguments.length > 7 && void 0 !== arguments[7] && arguments[7]; if (this.majorSteps = [1, 2, 5, 10], this.minorSteps = [0.25, 0.5, 1, 2], this.customLines = null, this.containerHeight = n, this.majorCharHeight = s, this._start = t, this._end = e, this.scale = 1, this.minorStepIdx = -1, this.magnitudefactor = 1, this.determineScale(), this.zeroAlign = r, this.autoScaleStart = i, this.autoScaleEnd = o, this.formattingFunction = a, i || o) { const h = this; const d = function (t) { const e = t - t % (h.magnitudefactor * h.minorSteps[h.minorStepIdx]); return t % (h.magnitudefactor * h.minorSteps[h.minorStepIdx]) > h.magnitudefactor * h.minorSteps[h.minorStepIdx] * 0.5 ? e + h.magnitudefactor * h.minorSteps[h.minorStepIdx] : e; }; i && (this._start -= 2 * this.magnitudefactor * this.minorSteps[this.minorStepIdx], this._start = d(this._start)), o && (this._end += this.magnitudefactor * this.minorSteps[this.minorStepIdx], this._end = d(this._end)), this.determineScale(); } }o.prototype.setCharHeight = function (t) { this.majorCharHeight = t; }, o.prototype.setHeight = function (t) { this.containerHeight = t; }, o.prototype.determineScale = function () { const t = this._end - this._start; this.scale = this.containerHeight / t; const e = this.majorCharHeight / this.scale; const i = t > 0 ? Math.round(Math.log(t) / Math.LN10) : 0; this.minorStepIdx = -1, this.magnitudefactor = Math.pow(10, i); let o = 0; i < 0 && (o = i); for (let n = !1, s = o; Math.abs(s) <= Math.abs(i); s++) { this.magnitudefactor = Math.pow(10, s); for (let r = 0; r < this.minorSteps.length; r++) { const a = this.magnitudefactor * this.minorSteps[r]; if (a >= e) { n = !0, this.minorStepIdx = r; break; } } if (!0 === n) break; } }, o.prototype.is_major = function (t) { return t % (this.magnitudefactor * this.majorSteps[this.minorStepIdx]) === 0; }, o.prototype.getStep = function () { return this.magnitudefactor * this.minorSteps[this.minorStepIdx]; }, o.prototype.getFirstMajor = function () { const t = this.magnitudefactor * this.majorSteps[this.minorStepIdx]; return this.convertValue(this._start + (t - this._start % t) % t); }, o.prototype.formatValue = function (t) { let e = t.toPrecision(5); return typeof this.formattingFunction === 'function' && (e = this.formattingFunction(t)), typeof e === 'number' ? `${e}` : typeof e === 'string' ? e : t.toPrecision(5); }, o.prototype.getLines = function () { for (var t = [], e = this.getStep(), i = (e - this._start % e) % e, o = this._start + i; this._end - o > 1e-5; o += e)o != this._start && t.push({ major: this.is_major(o), y: this.convertValue(o), val: this.formatValue(o) }); return t; }, o.prototype.followScale = function (t) { const e = this.minorStepIdx; const i = this._start; const o = this._end; const n = this; const s = function () { n.magnitudefactor *= 2; }; const r = function () { n.magnitudefactor /= 2; }; t.minorStepIdx <= 1 && this.minorStepIdx <= 1 || t.minorStepIdx > 1 && this.minorStepIdx > 1 || (t.minorStepIdx < this.minorStepIdx ? (this.minorStepIdx = 1, e == 2 ? s() : (s(), s())) : (this.minorStepIdx = 2, e == 1 ? r() : (r(), r()))); const a = t.convertValue(0); const h = t.getStep() * t.scale; let d = !1; let l = 0; while (!d && l++ < 5) { this.scale = h / (this.minorSteps[this.minorStepIdx] * this.magnitudefactor); const u = this.containerHeight / this.scale; this._start = i, this._end = this._start + u; const c = this._end * this.scale; const p = this.magnitudefactor * this.majorSteps[this.minorStepIdx]; const f = this.getFirstMajor() - t.getFirstMajor(); if (this.zeroAlign) { const m = a - c; this._end += m / this.scale, this._start = this._end - u; } else this.autoScaleStart ? (this._start -= f / this.scale, this._end = this._start + u) : (this._start += p - f / this.scale, this._end = this._start + u); if (!this.autoScaleEnd && this._end > o + 1e-5)r(), d = !1; else { if (!this.autoScaleStart && this._start < i - 1e-5) { if (!(this.zeroAlign && i >= 0)) { r(), d = !1; continue; }console.warn("Can't adhere to given 'min' range, due to zeroalign"); } this.autoScaleStart && this.autoScaleEnd && u < o - i ? (s(), d = !1) : d = !0; } } }, o.prototype.convertValue = function (t) { return this.containerHeight - (t - this._start) * this.scale; }, o.prototype.screenToValue = function (t) { return (this.containerHeight - t) / this.scale + this._start; }, t.exports = o; }, function (t, e, i) {
      const o = i(6); const n = s(o); function s(t) { return t && t.__esModule ? t : { default: t }; } const r = i(2); const a = i(110); const h = i(111); const d = i(72); function l(t, e, i, o) { this.id = e; const n = ['sampling', 'style', 'sort', 'yAxisOrientation', 'barChart', 'drawPoints', 'shaded', 'interpolation', 'zIndex', 'excludeFromStacking', 'excludeFromLegend']; this.options = r.selectiveBridgeObject(n, i), this.usingDefaultStyle = void 0 === t.className, this.groupsUsingDefaultStyles = o, this.zeroPosition = 0, this.update(t), this.usingDefaultStyle == 1 && (this.groupsUsingDefaultStyles[0] += 1), this.itemsData = [], this.visible = void 0 === t.visible || t.visible; }l.prototype.setItems = function (t) { t != null ? (this.itemsData = t, this.options.sort == 1 && r.insertSort(this.itemsData, (t, e) => (t.x > e.x ? 1 : -1))) : this.itemsData = []; }, l.prototype.getItems = function () { return this.itemsData; }, l.prototype.setZeroPosition = function (t) { this.zeroPosition = t; }, l.prototype.setOptions = function (t) { if (void 0 !== t) { const e = ['sampling', 'style', 'sort', 'yAxisOrientation', 'barChart', 'zIndex', 'excludeFromStacking', 'excludeFromLegend']; r.selectiveDeepExtend(e, this.options, t), typeof t.drawPoints === 'function' && (t.drawPoints = { onRender: t.drawPoints }), r.mergeOptions(this.options, t, 'interpolation'), r.mergeOptions(this.options, t, 'drawPoints'), r.mergeOptions(this.options, t, 'shaded'), t.interpolation && (0, n.default)(t.interpolation) == 'object' && t.interpolation.parametrization && (t.interpolation.parametrization == 'uniform' ? this.options.interpolation.alpha = 0 : t.interpolation.parametrization == 'chordal' ? this.options.interpolation.alpha = 1 : (this.options.interpolation.parametrization = 'centripetal', this.options.interpolation.alpha = 0.5)); } }, l.prototype.update = function (t) { this.group = t, this.content = t.content || 'graph', this.className = t.className || this.className || `vis-graph-group${this.groupsUsingDefaultStyles[0] % 10}`, this.visible = void 0 === t.visible || t.visible, this.style = t.style, this.setOptions(t.options); }, l.prototype.getLegend = function (t, e, i, o, n) {
        if (void 0 == i || i == null) {
          const s = document.createElementNS('http://www.w3.org/2000/svg', 'svg'); i = {
            svg: s, svgElements: {}, options: this.options, groups: [this],
          };
        } switch (void 0 != o && o != null || (o = 0), void 0 != n && n != null || (n = 0.5 * e), this.options.style) { case 'line': h.drawIcon(this, o, n, t, e, i); break; case 'points': case 'point': d.drawIcon(this, o, n, t, e, i); break; case 'bar': a.drawIcon(this, o, n, t, e, i); break; } return { icon: i.svg, label: this.content, orientation: this.options.yAxisOrientation };
      }, l.prototype.getYRange = function (t) { for (var e = t[0].y, i = t[0].y, o = 0; o < t.length; o++)e = e > t[o].y ? t[o].y : e, i = i < t[o].y ? t[o].y : i; return { min: e, max: i, yAxisOrientation: this.options.yAxisOrientation }; }, t.exports = l;
    }, function (t, e, i) {
      const o = i(14); const n = i(72); function s(t, e) {}s.drawIcon = function (t, e, i, n, s, r) {
        const a = 0.5 * s; const h = o.getSVGElement('rect', r.svgElements, r.svg); h.setAttributeNS(null, 'x', e), h.setAttributeNS(null, 'y', i - a), h.setAttributeNS(null, 'width', n), h.setAttributeNS(null, 'height', 2 * a), h.setAttributeNS(null, 'class', 'vis-outline'); const d = Math.round(0.3 * n); const l = t.options.barChart.width; const u = l / d; const c = Math.round(0.4 * s); const p = Math.round(0.75 * s); const f = Math.round((n - 2 * d) / 3); if (o.drawBar(e + 0.5 * d + f, i + a - c - 1, d, c, `${t.className} vis-bar`, r.svgElements, r.svg, t.style), o.drawBar(e + 1.5 * d + f + 2, i + a - p - 1, d, p, `${t.className} vis-bar`, r.svgElements, r.svg, t.style), t.options.drawPoints.enabled == 1) {
          const m = {
            style: t.options.drawPoints.style, styles: t.options.drawPoints.styles, size: t.options.drawPoints.size / u, className: t.className,
          }; o.drawPoint(e + 0.5 * d + f, i + a - c - 1, m, r.svgElements, r.svg), o.drawPoint(e + 1.5 * d + f + 2, i + a - p - 1, m, r.svgElements, r.svg);
        }
      }, s.draw = function (t, e, i) {
        let r; let a; let h; let d; let l; let u; const c = []; const p = {}; let f = 0; for (l = 0; l < t.length; l++) {
          if (d = i.groups[t[l]], d.options.style === 'bar' && !0 === d.visible && (void 0 === i.options.groups.visibility[t[l]] || !0 === i.options.groups.visibility[t[l]])) {
 for (u = 0; u < e[t[l]].length; u++) { c.push({
            screen_x: e[t[l]][u].screen_x, screen_end: e[t[l]][u].screen_end, screen_y: e[t[l]][u].screen_y, x: e[t[l]][u].x, end: e[t[l]][u].end, y: e[t[l]][u].y, groupId: t[l], label: e[t[l]][u].label, 
          }), f += 1; } } 
} if (f !== 0) {
          for (c.sort((t, e) => (t.screen_x === e.screen_x ? t.groupId < e.groupId ? -1 : 1 : t.screen_x - e.screen_x)), s._getDataIntersections(p, c), l = 0; l < c.length; l++) {
            d = i.groups[c[l].groupId]; const m = void 0 != d.options.barChart.minWidth ? d.options.barChart.minWidth : 0.1 * d.options.barChart.width; a = c[l].screen_x; let v = 0; if (void 0 === p[a])l + 1 < c.length && (r = Math.abs(c[l + 1].screen_x - a)), h = s._getSafeDrawData(r, d, m); else { const g = l + (p[a].amount - p[a].resolved); g < c.length && (r = Math.abs(c[g].screen_x - a)), h = s._getSafeDrawData(r, d, m), p[a].resolved += 1, !0 === d.options.stack && !0 !== d.options.excludeFromStacking ? c[l].screen_y < d.zeroPosition ? (v = p[a].accumulatedNegative, p[a].accumulatedNegative += d.zeroPosition - c[l].screen_y) : (v = p[a].accumulatedPositive, p[a].accumulatedPositive += d.zeroPosition - c[l].screen_y) : !0 === d.options.barChart.sideBySide && (h.width /= p[a].amount, h.offset += p[a].resolved * h.width - 0.5 * h.width * (p[a].amount + 1)); } let y = h.width; let b = c[l].screen_x; if (void 0 != c[l].screen_end ? (y = c[l].screen_end - c[l].screen_x, b += 0.5 * y) : b += h.offset, o.drawBar(b, c[l].screen_y - v, y, d.zeroPosition - c[l].screen_y, `${d.className} vis-bar`, i.svgElements, i.svg, d.style), !0 === d.options.drawPoints.enabled) {
              const _ = {
                screen_x: c[l].screen_x, screen_y: c[l].screen_y - v, x: c[l].x, y: c[l].y, groupId: c[l].groupId, label: c[l].label,
              }; n.draw([_], d, i, h.offset);
            }
          }
        }
      }, s._getDataIntersections = function (t, e) {
        for (var i, o = 0; o < e.length; o++) {
          o + 1 < e.length && (i = Math.abs(e[o + 1].screen_x - e[o].screen_x)), o > 0 && (i = Math.min(i, Math.abs(e[o - 1].screen_x - e[o].screen_x))), i === 0 && (void 0 === t[e[o].screen_x] && (t[e[o].screen_x] = {
            amount: 0, resolved: 0, accumulatedPositive: 0, accumulatedNegative: 0,
          }), t[e[o].screen_x].amount += 1);
        }
      }, s._getSafeDrawData = function (t, e, i) { let o; let n; return t < e.options.barChart.width && t > 0 ? (o = t < i ? i : t, n = 0, e.options.barChart.align === 'left' ? n -= 0.5 * t : e.options.barChart.align === 'right' && (n += 0.5 * t)) : (o = e.options.barChart.width, n = 0, e.options.barChart.align === 'left' ? n -= 0.5 * e.options.barChart.width : e.options.barChart.align === 'right' && (n += 0.5 * e.options.barChart.width)), { width: o, offset: n }; }, s.getStackedYRange = function (t, e, i, o, n) { if (t.length > 0) { t.sort((t, e) => (t.screen_x === e.screen_x ? t.groupId < e.groupId ? -1 : 1 : t.screen_x - e.screen_x)); const r = {}; s._getDataIntersections(r, t), e[o] = s._getStackedYRange(r, t), e[o].yAxisOrientation = n, i.push(o); } }, s._getStackedYRange = function (t, e) { for (var i, o = e[0].screen_y, n = e[0].screen_y, s = 0; s < e.length; s++)i = e[s].screen_x, void 0 === t[i] ? (o = o > e[s].screen_y ? e[s].screen_y : o, n = n < e[s].screen_y ? e[s].screen_y : n) : e[s].screen_y < 0 ? t[i].accumulatedNegative += e[s].screen_y : t[i].accumulatedPositive += e[s].screen_y; for (const r in t)t.hasOwnProperty(r) && (o = o > t[r].accumulatedNegative ? t[r].accumulatedNegative : o, o = o > t[r].accumulatedPositive ? t[r].accumulatedPositive : o, n = n < t[r].accumulatedNegative ? t[r].accumulatedNegative : n, n = n < t[r].accumulatedPositive ? t[r].accumulatedPositive : n); return { min: o, max: n }; }, t.exports = s;
    }, function (t, e, i) {
      const o = i(14); function n(t, e) {}n.calcPath = function (t, e) { if (t != null && t.length > 0) { let i = []; return i = e.options.interpolation.enabled == 1 ? n._catmullRom(t, e) : n._linear(t), i; } }, n.drawIcon = function (t, e, i, n, s, r) {
        let a; let h; const d = 0.5 * s; const l = o.getSVGElement('rect', r.svgElements, r.svg); if (l.setAttributeNS(null, 'x', e), l.setAttributeNS(null, 'y', i - d), l.setAttributeNS(null, 'width', n), l.setAttributeNS(null, 'height', 2 * d), l.setAttributeNS(null, 'class', 'vis-outline'), a = o.getSVGElement('path', r.svgElements, r.svg), a.setAttributeNS(null, 'class', t.className), void 0 !== t.style && a.setAttributeNS(null, 'style', t.style), a.setAttributeNS(null, 'd', `M${e},${i} L${e + n},${i}`), t.options.shaded.enabled == 1 && (h = o.getSVGElement('path', r.svgElements, r.svg), t.options.shaded.orientation == 'top' ? h.setAttributeNS(null, 'd', `M${e}, ${i - d}L${e},${i} L${e + n},${i} L${e + n},${i - d}`) : h.setAttributeNS(null, 'd', `M${e},${i} L${e},${i + d} L${e + n},${i + d}L${e + n},${i}`), h.setAttributeNS(null, 'class', `${t.className} vis-icon-fill`), void 0 !== t.options.shaded.style && t.options.shaded.style !== '' && h.setAttributeNS(null, 'style', t.options.shaded.style)), t.options.drawPoints.enabled == 1) {
          const u = {
            style: t.options.drawPoints.style, styles: t.options.drawPoints.styles, size: t.options.drawPoints.size, className: t.className,
          }; o.drawPoint(e + 0.5 * n, i, u, r.svgElements, r.svg);
        }
      }, n.drawShading = function (t, e, i, n) { if (e.options.shaded.enabled == 1) { let s; const r = Number(n.svg.style.height.replace('px', '')); const a = o.getSVGElement('path', n.svgElements, n.svg); let h = 'L'; e.options.interpolation.enabled == 1 && (h = 'C'); let d = 0; d = e.options.shaded.orientation == 'top' ? 0 : e.options.shaded.orientation == 'bottom' ? r : Math.min(Math.max(0, e.zeroPosition), r), s = e.options.shaded.orientation == 'group' && i != null && void 0 != i ? `M${t[0][0]},${t[0][1]} ${this.serializePath(t, h, !1)} L${i[i.length - 1][0]},${i[i.length - 1][1]} ${this.serializePath(i, h, !0)}${i[0][0]},${i[0][1]} Z` : `M${t[0][0]},${t[0][1]} ${this.serializePath(t, h, !1)} V${d} H${t[0][0]} Z`, a.setAttributeNS(null, 'class', `${e.className} vis-fill`), void 0 !== e.options.shaded.style && a.setAttributeNS(null, 'style', e.options.shaded.style), a.setAttributeNS(null, 'd', s); } }, n.draw = function (t, e, i) { if (t != null && void 0 != t) { const n = o.getSVGElement('path', i.svgElements, i.svg); n.setAttributeNS(null, 'class', e.className), void 0 !== e.style && n.setAttributeNS(null, 'style', e.style); let s = 'L'; e.options.interpolation.enabled == 1 && (s = 'C'), n.setAttributeNS(null, 'd', `M${t[0][0]},${t[0][1]} ${this.serializePath(t, s, !1)}`); } }, n.serializePath = function (t, e, i) { if (t.length < 2) return ''; let o; let n = e; if (i) for (o = t.length - 2; o > 0; o--)n += `${t[o][0]},${t[o][1]} `; else for (o = 1; o < t.length; o++)n += `${t[o][0]},${t[o][1]} `; return n; }, n._catmullRomUniform = function (t) { let e; let i; let o; let n; let s; let r; const a = []; a.push([Math.round(t[0].screen_x), Math.round(t[0].screen_y)]); for (let h = 1 / 6, d = t.length, l = 0; l < d - 1; l++)e = l == 0 ? t[0] : t[l - 1], i = t[l], o = t[l + 1], n = l + 2 < d ? t[l + 2] : o, s = { screen_x: (-e.screen_x + 6 * i.screen_x + o.screen_x) * h, screen_y: (-e.screen_y + 6 * i.screen_y + o.screen_y) * h }, r = { screen_x: (i.screen_x + 6 * o.screen_x - n.screen_x) * h, screen_y: (i.screen_y + 6 * o.screen_y - n.screen_y) * h }, a.push([s.screen_x, s.screen_y]), a.push([r.screen_x, r.screen_y]), a.push([o.screen_x, o.screen_y]); return a; }, n._catmullRom = function (t, e) { const i = e.options.interpolation.alpha; if (i == 0 || void 0 === i) return this._catmullRomUniform(t); let o; let n; let s; let r; let a; let h; let d; let l; let u; let c; let p; let f; let m; let v; let g; let y; let b; let _; let w; const x = []; x.push([Math.round(t[0].screen_x), Math.round(t[0].screen_y)]); for (let k = t.length, D = 0; D < k - 1; D++)o = D == 0 ? t[0] : t[D - 1], n = t[D], s = t[D + 1], r = D + 2 < k ? t[D + 2] : s, d = Math.sqrt(Math.pow(o.screen_x - n.screen_x, 2) + Math.pow(o.screen_y - n.screen_y, 2)), l = Math.sqrt(Math.pow(n.screen_x - s.screen_x, 2) + Math.pow(n.screen_y - s.screen_y, 2)), u = Math.sqrt(Math.pow(s.screen_x - r.screen_x, 2) + Math.pow(s.screen_y - r.screen_y, 2)), v = Math.pow(u, i), y = Math.pow(u, 2 * i), g = Math.pow(l, i), b = Math.pow(l, 2 * i), w = Math.pow(d, i), _ = Math.pow(d, 2 * i), c = 2 * _ + 3 * w * g + b, p = 2 * y + 3 * v * g + b, f = 3 * w * (w + g), f > 0 && (f = 1 / f), m = 3 * v * (v + g), m > 0 && (m = 1 / m), a = { screen_x: (-b * o.screen_x + c * n.screen_x + _ * s.screen_x) * f, screen_y: (-b * o.screen_y + c * n.screen_y + _ * s.screen_y) * f }, h = { screen_x: (y * n.screen_x + p * s.screen_x - b * r.screen_x) * m, screen_y: (y * n.screen_y + p * s.screen_y - b * r.screen_y) * m }, a.screen_x == 0 && a.screen_y == 0 && (a = n), h.screen_x == 0 && h.screen_y == 0 && (h = s), x.push([a.screen_x, a.screen_y]), x.push([h.screen_x, h.screen_y]), x.push([s.screen_x, s.screen_y]); return x; }, n._linear = function (t) { for (var e = [], i = 0; i < t.length; i++)e.push([t[i].screen_x, t[i].screen_y]); return e; }, t.exports = n;
    }, function (t, e, i) {
      const o = i(8); const n = s(o); function s(t) { return t && t.__esModule ? t : { default: t }; } const r = i(2); const a = i(14); const h = i(16); function d(t, e, i, o) {
        this.body = t, this.defaultOptions = {
          enabled: !1, icons: !0, iconSize: 20, iconSpacing: 6, left: { visible: !0, position: 'top-left' }, right: { visible: !0, position: 'top-right' },
        }, this.side = i, this.options = r.extend({}, this.defaultOptions), this.linegraphOptions = o, this.svgElements = {}, this.dom = {}, this.groups = {}, this.amountOfGroups = 0, this._create(), this.framework = {
          svg: this.svg, svgElements: this.svgElements, options: this.options, groups: this.groups,
        }, this.setOptions(e);
      }d.prototype = new h(), d.prototype.clear = function () { this.groups = {}, this.amountOfGroups = 0; }, d.prototype.addGroup = function (t, e) { e.options.excludeFromLegend != 1 && (this.groups.hasOwnProperty(t) || (this.groups[t] = e), this.amountOfGroups += 1); }, d.prototype.updateGroup = function (t, e) { this.groups[t] = e; }, d.prototype.removeGroup = function (t) { this.groups.hasOwnProperty(t) && (delete this.groups[t], this.amountOfGroups -= 1); }, d.prototype._create = function () { this.dom.frame = document.createElement('div'), this.dom.frame.className = 'vis-legend', this.dom.frame.style.position = 'absolute', this.dom.frame.style.top = '10px', this.dom.frame.style.display = 'block', this.dom.textArea = document.createElement('div'), this.dom.textArea.className = 'vis-legend-text', this.dom.textArea.style.position = 'relative', this.dom.textArea.style.top = '0px', this.svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg'), this.svg.style.position = 'absolute', this.svg.style.top = '0px', this.svg.style.width = `${this.options.iconSize + 5}px`, this.svg.style.height = '100%', this.dom.frame.appendChild(this.svg), this.dom.frame.appendChild(this.dom.textArea); }, d.prototype.hide = function () { this.dom.frame.parentNode && this.dom.frame.parentNode.removeChild(this.dom.frame); }, d.prototype.show = function () { this.dom.frame.parentNode || this.body.dom.center.appendChild(this.dom.frame); }, d.prototype.setOptions = function (t) { const e = ['enabled', 'orientation', 'icons', 'left', 'right']; r.selectiveDeepExtend(e, this.options, t); }, d.prototype.redraw = function () { let t = 0; const e = (0, n.default)(this.groups); e.sort((t, e) => (t < e ? -1 : 1)); for (var i = 0; i < e.length; i++) { var o = e[i]; this.groups[o].visible != 1 || void 0 !== this.linegraphOptions.visibility[o] && this.linegraphOptions.visibility[o] != 1 || t++; } if (this.options[this.side].visible == 0 || this.amountOfGroups == 0 || this.options.enabled == 0 || t == 0) this.hide(); else { if (this.show(), this.options[this.side].position == 'top-left' || this.options[this.side].position == 'bottom-left' ? (this.dom.frame.style.left = '4px', this.dom.frame.style.textAlign = 'left', this.dom.textArea.style.textAlign = 'left', this.dom.textArea.style.left = `${this.options.iconSize + 15}px`, this.dom.textArea.style.right = '', this.svg.style.left = '0px', this.svg.style.right = '') : (this.dom.frame.style.right = '4px', this.dom.frame.style.textAlign = 'right', this.dom.textArea.style.textAlign = 'right', this.dom.textArea.style.right = `${this.options.iconSize + 15}px`, this.dom.textArea.style.left = '', this.svg.style.right = '0px', this.svg.style.left = ''), this.options[this.side].position == 'top-left' || this.options[this.side].position == 'top-right') this.dom.frame.style.top = `${4 - Number(this.body.dom.center.style.top.replace('px', ''))}px`, this.dom.frame.style.bottom = ''; else { const s = this.body.domProps.center.height - this.body.domProps.centerContainer.height; this.dom.frame.style.bottom = `${4 + s + Number(this.body.dom.center.style.top.replace('px', ''))}px`, this.dom.frame.style.top = ''; } this.options.icons == 0 ? (this.dom.frame.style.width = `${this.dom.textArea.offsetWidth + 10}px`, this.dom.textArea.style.right = '', this.dom.textArea.style.left = '', this.svg.style.width = '0px') : (this.dom.frame.style.width = `${this.options.iconSize + 15 + this.dom.textArea.offsetWidth + 10}px`, this.drawLegendIcons()); let r = ''; for (i = 0; i < e.length; i++)o = e[i], this.groups[o].visible != 1 || void 0 !== this.linegraphOptions.visibility[o] && this.linegraphOptions.visibility[o] != 1 || (r += `${this.groups[o].content}<br />`); this.dom.textArea.innerHTML = r, this.dom.textArea.style.lineHeight = `${0.75 * this.options.iconSize + this.options.iconSpacing}px`; } }, d.prototype.drawLegendIcons = function () { if (this.dom.frame.parentNode) { const t = (0, n.default)(this.groups); t.sort((t, e) => (t < e ? -1 : 1)), a.resetElements(this.svgElements); const e = window.getComputedStyle(this.dom.frame).paddingTop; const i = Number(e.replace('px', '')); const o = i; const s = this.options.iconSize; const r = 0.75 * this.options.iconSize; let h = i + 0.5 * r + 3; this.svg.style.width = `${s + 5 + i}px`; for (let d = 0; d < t.length; d++) { const l = t[d]; this.groups[l].visible != 1 || void 0 !== this.linegraphOptions.visibility[l] && this.linegraphOptions.visibility[l] != 1 || (this.groups[l].getLegend(s, r, this.framework, o, h), h += r + this.options.iconSpacing); } } }, t.exports = d;
    }, function (t, e, i) {
      Object.defineProperty(e, '__esModule', { value: !0 }); const o = 'string'; const n = 'boolean'; const s = 'number'; const r = 'array'; const a = 'date'; const h = 'object'; const d = 'dom'; const l = 'moment'; const u = 'any'; const c = {
        configure: {
          enabled: { boolean: n }, filter: { boolean: n, function: 'function' }, container: { dom: d }, __type__: { object: h, boolean: n, function: 'function' },
        },
        yAxisOrientation: { string: ['left', 'right'] },
        defaultGroup: { string: o },
        sort: { boolean: n },
        sampling: { boolean: n },
        stack: { boolean: n },
        graphHeight: { string: o, number: s },
        shaded: {
          enabled: { boolean: n }, orientation: { string: ['bottom', 'top', 'zero', 'group'] }, groupId: { object: h }, __type__: { boolean: n, object: h },
        },
        style: { string: ['line', 'bar', 'points'] },
        barChart: {
          width: { number: s }, minWidth: { number: s }, sideBySide: { boolean: n }, align: { string: ['left', 'center', 'right'] }, __type__: { object: h },
        },
        interpolation: {
          enabled: { boolean: n }, parametrization: { string: ['centripetal', 'chordal', 'uniform'] }, alpha: { number: s }, __type__: { object: h, boolean: n },
        },
        drawPoints: {
          enabled: { boolean: n }, onRender: { function: 'function' }, size: { number: s }, style: { string: ['square', 'circle'] }, __type__: { object: h, boolean: n, function: 'function' },
        },
        dataAxis: {
          showMinorLabels: { boolean: n },
          showMajorLabels: { boolean: n },
          icons: { boolean: n },
          width: { string: o, number: s },
          visible: { boolean: n },
          alignZeros: { boolean: n },
          left: {
            range: { min: { number: s, undefined: 'undefined' }, max: { number: s, undefined: 'undefined' }, __type__: { object: h } }, format: { function: 'function' }, title: { text: { string: o, number: s, undefined: 'undefined' }, style: { string: o, undefined: 'undefined' }, __type__: { object: h } }, __type__: { object: h },
          },
          right: {
            range: { min: { number: s, undefined: 'undefined' }, max: { number: s, undefined: 'undefined' }, __type__: { object: h } }, format: { function: 'function' }, title: { text: { string: o, number: s, undefined: 'undefined' }, style: { string: o, undefined: 'undefined' }, __type__: { object: h } }, __type__: { object: h },
          },
          __type__: { object: h },
        },
        legend: {
          enabled: { boolean: n }, icons: { boolean: n }, left: { visible: { boolean: n }, position: { string: ['top-right', 'bottom-right', 'top-left', 'bottom-left'] }, __type__: { object: h } }, right: { visible: { boolean: n }, position: { string: ['top-right', 'bottom-right', 'top-left', 'bottom-left'] }, __type__: { object: h } }, __type__: { object: h, boolean: n },
        },
        groups: { visibility: { any: u }, __type__: { object: h } },
        autoResize: { boolean: n },
        throttleRedraw: { number: s },
        clickToUse: { boolean: n },
        end: {
          number: s, date: a, string: o, moment: l,
        },
        format: {
          minorLabels: {
            millisecond: { string: o, undefined: 'undefined' }, second: { string: o, undefined: 'undefined' }, minute: { string: o, undefined: 'undefined' }, hour: { string: o, undefined: 'undefined' }, weekday: { string: o, undefined: 'undefined' }, day: { string: o, undefined: 'undefined' }, month: { string: o, undefined: 'undefined' }, year: { string: o, undefined: 'undefined' }, __type__: { object: h },
          },
          majorLabels: {
            millisecond: { string: o, undefined: 'undefined' }, second: { string: o, undefined: 'undefined' }, minute: { string: o, undefined: 'undefined' }, hour: { string: o, undefined: 'undefined' }, weekday: { string: o, undefined: 'undefined' }, day: { string: o, undefined: 'undefined' }, month: { string: o, undefined: 'undefined' }, year: { string: o, undefined: 'undefined' }, __type__: { object: h },
          },
          __type__: { object: h },
        },
        moment: { function: 'function' },
        height: { string: o, number: s },
        hiddenDates: {
          start: {
            date: a, number: s, string: o, moment: l,
          },
          end: {
            date: a, number: s, string: o, moment: l,
          },
          repeat: { string: o },
          __type__: { object: h, array: r },
        },
        locale: { string: o },
        locales: { __any__: { any: u }, __type__: { object: h } },
        max: {
          date: a, number: s, string: o, moment: l,
        },
        maxHeight: { number: s, string: o },
        maxMinorChars: { number: s },
        min: {
          date: a, number: s, string: o, moment: l,
        },
        minHeight: { number: s, string: o },
        moveable: { boolean: n },
        multiselect: { boolean: n },
        orientation: { string: o },
        showCurrentTime: { boolean: n },
        showMajorLabels: { boolean: n },
        showMinorLabels: { boolean: n },
        start: {
          date: a, number: s, string: o, moment: l,
        },
        timeAxis: { scale: { string: o, undefined: 'undefined' }, step: { number: s, undefined: 'undefined' }, __type__: { object: h } },
        width: { string: o, number: s },
        zoomable: { boolean: n },
        zoomKey: { string: ['ctrlKey', 'altKey', 'metaKey', ''] },
        zoomMax: { number: s },
        zoomMin: { number: s },
        zIndex: { number: s },
        __type__: { object: h },
      }; const p = {
        global: {
          sort: !0,
          sampling: !0,
          stack: !1,
          shaded: { enabled: !1, orientation: ['zero', 'top', 'bottom', 'group'] },
          style: ['line', 'bar', 'points'],
          barChart: {
            width: [50, 5, 100, 5], minWidth: [50, 5, 100, 5], sideBySide: !1, align: ['left', 'center', 'right'],
          },
          interpolation: { enabled: !0, parametrization: ['centripetal', 'chordal', 'uniform'] },
          drawPoints: { enabled: !0, size: [6, 2, 30, 1], style: ['square', 'circle'] },
          dataAxis: {
            showMinorLabels: !0, showMajorLabels: !0, icons: !1, width: [40, 0, 200, 1], visible: !0, alignZeros: !0, left: { title: { text: '', style: '' } }, right: { title: { text: '', style: '' } },
          },
          legend: {
            enabled: !1, icons: !0, left: { visible: !0, position: ['top-right', 'bottom-right', 'top-left', 'bottom-left'] }, right: { visible: !0, position: ['top-right', 'bottom-right', 'top-left', 'bottom-left'] },
          },
          autoResize: !0,
          clickToUse: !1,
          end: '',
          format: {
            minorLabels: {
              millisecond: 'SSS', second: 's', minute: 'HH:mm', hour: 'HH:mm', weekday: 'ddd D', day: 'D', month: 'MMM', year: 'YYYY',
            },
            majorLabels: {
              millisecond: 'HH:mm:ss', second: 'D MMMM HH:mm', minute: 'ddd D MMMM', hour: 'ddd D MMMM', weekday: 'MMMM YYYY', day: 'MMMM YYYY', month: 'YYYY', year: '',
            },
          },
          height: '',
          locale: '',
          max: '',
          maxHeight: '',
          maxMinorChars: [7, 0, 20, 1],
          min: '',
          minHeight: '',
          moveable: !0,
          orientation: ['both', 'bottom', 'top'],
          showCurrentTime: !1,
          showMajorLabels: !0,
          showMinorLabels: !0,
          start: '',
          width: '100%',
          zoomable: !0,
          zoomKey: ['ctrlKey', 'altKey', 'metaKey', ''],
          zoomMax: [31536e10, 10, 31536e10, 1],
          zoomMin: [10, 10, 31536e10, 1],
          zIndex: 0,
        },
      }; e.allOptions = c, e.configureOptions = p;
    }, function (t, e, i) {
      const o = i(29); const n = s(o); function s(t) { return t && t.__esModule ? t : { default: t }; } function r(t) { return u = t, M(); } const a = {
        fontsize: 'font.size', fontcolor: 'font.color', labelfontcolor: 'font.color', fontname: 'font.face', color: ['color.border', 'color.background'], fillcolor: 'color.background', tooltip: 'title', labeltooltip: 'title',
      }; const h = (0, n.default)(a); h.color = 'color.color', h.style = 'dashes'; const d = {
        NULL: 0, DELIMITER: 1, IDENTIFIER: 2, UNKNOWN: 3,
      }; const l = {
        '{': !0, '}': !0, '[': !0, ']': !0, ';': !0, '=': !0, ',': !0, '->': !0, '--': !0,
      }; var u = ''; let c = 0; let p = ''; let f = ''; let m = d.NULL; function v() { c = 0, p = u.charAt(0); } function g() { c++, p = u.charAt(c); } function y() { return u.charAt(c + 1); } const b = /[a-zA-Z_0-9.:#]/; function _(t) { return b.test(t); } function w(t, e) { if (t || (t = {}), e) for (const i in e)e.hasOwnProperty(i) && (t[i] = e[i]); return t; } function x(t, e, i) { const o = e.split('.'); let n = t; while (o.length) { const s = o.shift(); o.length ? (n[s] || (n[s] = {}), n = n[s]) : n[s] = i; } } function k(t, e) { let i; let o; let n = null; const s = [t]; let r = t; while (r.parent)s.push(r.parent), r = r.parent; if (r.nodes) for (i = 0, o = r.nodes.length; i < o; i++) if (e.id === r.nodes[i].id) { n = r.nodes[i]; break; } for (n || (n = { id: e.id }, t.node && (n.attr = w(n.attr, t.node))), i = s.length - 1; i >= 0; i--) { const a = s[i]; a.nodes || (a.nodes = []), a.nodes.indexOf(n) === -1 && a.nodes.push(n); }e.attr && (n.attr = w(n.attr, e.attr)); } function D(t, e) { if (t.edges || (t.edges = []), t.edges.push(e), t.edge) { const i = w({}, t.edge); e.attr = w(i, e.attr); } } function S(t, e, i, o, n) { const s = { from: e, to: i, type: o }; return t.edge && (s.attr = w({}, t.edge)), s.attr = w(s.attr || {}, n), s; } function C() { m = d.NULL, f = ''; while (p === ' ' || p === '\t' || p === '\n' || p === '\r')g(); do { var t = !1; if (p === '#') { let e = c - 1; while (u.charAt(e) === ' ' || u.charAt(e) === '\t')e--; if (u.charAt(e) === '\n' || u.charAt(e) === '') { while (p != '' && p != '\n')g(); t = !0; } } if (p === '/' && y() === '/') { while (p != '' && p != '\n')g(); t = !0; } if (p === '/' && y() === '*') { while (p != '') { if (p === '*' && y() === '/') { g(), g(); break; }g(); }t = !0; } while (p === ' ' || p === '\t' || p === '\n' || p === '\r')g(); } while (t);if (p !== '') { const i = p + y(); if (l[i]) return m = d.DELIMITER, f = i, g(), void g(); if (l[p]) return m = d.DELIMITER, f = p, void g(); if (_(p) || p === '-') { f += p, g(); while (_(p))f += p, g(); return f === 'false' ? f = !1 : f === 'true' ? f = !0 : isNaN(Number(f)) || (f = Number(f)), void (m = d.IDENTIFIER); } if (p === '"') { g(); while (p != '' && (p != '"' || p === '"' && y() === '"'))p === '"' ? (f += p, g()) : p === '\\' && y() === 'n' ? (f += '\n', g()) : f += p, g(); if (p != '"') throw A('End of string " expected'); return g(), void (m = d.IDENTIFIER); }m = d.UNKNOWN; while (p != '')f += p, g(); throw new SyntaxError(`Syntax error in part "${z(f, 30)}"`); }m = d.DELIMITER; } function M() { const t = {}; if (v(), C(), f === 'strict' && (t.strict = !0, C()), f !== 'graph' && f !== 'digraph' || (t.type = f, C()), m === d.IDENTIFIER && (t.id = f, C()), f != '{') throw A('Angle bracket { expected'); if (C(), O(t), f != '}') throw A('Angle bracket } expected'); if (C(), f !== '') throw A('End of file expected'); return C(), delete t.node, delete t.edge, delete t.graph, t; } function O(t) { while (f !== '' && f != '}')E(t), f === ';' && C(); } function E(t) { const e = T(t); if (e)N(t, e); else { const i = P(t); if (!i) { if (m != d.IDENTIFIER) throw A('Identifier expected'); const o = f; if (C(), f === '=') { if (C(), m != d.IDENTIFIER) throw A('Identifier expected'); t[o] = f, C(); } else I(t, o); } } } function T(t) { let e = null; if (f === 'subgraph' && (e = {}, e.type = 'subgraph', C(), m === d.IDENTIFIER && (e.id = f, C())), f === '{') { if (C(), e || (e = {}), e.parent = t, e.node = t.node, e.edge = t.edge, e.graph = t.graph, O(e), f != '}') throw A('Angle bracket } expected'); C(), delete e.node, delete e.edge, delete e.graph, delete e.parent, t.subgraphs || (t.subgraphs = []), t.subgraphs.push(e); } return e; } function P(t) { return f === 'node' ? (C(), t.node = R(), 'node') : f === 'edge' ? (C(), t.edge = R(), 'edge') : f === 'graph' ? (C(), t.graph = R(), 'graph') : null; } function I(t, e) { const i = { id: e }; const o = R(); o && (i.attr = o), k(t, i), N(t, e); } function N(t, e) { while (f === '->' || f === '--') { var i; const o = f; C(); const n = T(t); if (n)i = n; else { if (m != d.IDENTIFIER) throw A('Identifier or subgraph expected'); i = f, k(t, { id: i }), C(); } const s = R(); const r = S(t, e, i, o, s); D(t, r), e = i; } } function R() { let t = null; const e = { dashed: !0, solid: !1, dotted: [1, 5] }; while (f === '[') { C(), t = {}; while (f !== '' && f != ']') { if (m != d.IDENTIFIER) throw A('Attribute name expected'); const i = f; if (C(), f != '=') throw A('Equal sign = expected'); if (C(), m != d.IDENTIFIER) throw A('Attribute value expected'); let o = f; i === 'style' && (o = e[o]), x(t, i, o), C(), f == ',' && C(); } if (f != ']') throw A('Bracket ] expected'); C(); } return t; } function A(t) { return new SyntaxError(`${t}, got "${z(f, 30)}" (char ${c})`); } function z(t, e) { return t.length <= e ? t : `${t.substr(0, 27)}...`; } function L(t, e, i) { Array.isArray(t) ? t.forEach((t) => { Array.isArray(e) ? e.forEach((e) => { i(t, e); }) : i(t, e); }) : Array.isArray(e) ? e.forEach((e) => { i(t, e); }) : i(t, e); } function F(t, e, i) { for (var o = e.split('.'), n = o.pop(), s = t, r = 0; r < o.length; r++) { const a = o[r]; a in s || (s[a] = {}), s = s[a]; } return s[n] = i, t; } function B(t, e) { const i = {}; for (var o in t) if (t.hasOwnProperty(o)) { const n = e[o]; Array.isArray(n) ? n.forEach((e) => { F(i, e, t[o]); }) : F(i, typeof n === 'string' ? n : o, t[o]); } return i; } function j(t) { const e = r(t); const i = { nodes: [], edges: [], options: {} }; if (e.nodes && e.nodes.forEach((t) => { const e = { id: t.id, label: String(t.label || t.id) }; w(e, B(t.attr, a)), e.image && (e.shape = 'image'), i.nodes.push(e); }), e.edges) { const o = function (t) { const e = { from: t.from, to: t.to }; return w(e, B(t.attr, h)), e.arrows = t.type === '->' ? 'to' : void 0, e; }; e.edges.forEach((t) => { let e; let n; e = t.from instanceof Object ? t.from.nodes : { id: t.from }, n = t.to instanceof Object ? t.to.nodes : { id: t.to }, t.from instanceof Object && t.from.edges && t.from.edges.forEach((t) => { const e = o(t); i.edges.push(e); }), L(e, n, (e, n) => { const s = S(i, e.id, n.id, t.type, t.attr); const r = o(s); i.edges.push(r); }), t.to instanceof Object && t.to.edges && t.to.edges.forEach((t) => { const e = o(t); i.edges.push(e); }); }); } return e.attr && (i.options = e.attr), i; }e.parseDOT = r, e.DOTToGraph = j;
    }, function (t, e, i) {
      function o(t, e) {
        const i = []; const o = []; const n = { edges: { inheritColor: !1 }, nodes: { fixed: !1, parseColor: !1 } }; void 0 !== e && (void 0 !== e.fixed && (n.nodes.fixed = e.fixed), void 0 !== e.parseColor && (n.nodes.parseColor = e.parseColor), void 0 !== e.inheritColor && (n.edges.inheritColor = e.inheritColor)); for (var s = t.edges, r = t.nodes, a = 0; a < s.length; a++) { const h = {}; const d = s[a]; h.id = d.id, h.from = d.source, h.to = d.target, h.attributes = d.attributes, h.label = d.label, h.title = void 0 !== d.attributes ? d.attributes.title : void 0, d.type === 'Directed' && (h.arrows = 'to'), d.color && !1 === n.inheritColor && (h.color = d.color), i.push(h); } for (let l = 0; l < r.length; l++) {
          const u = {}; const c = r[l]; u.id = c.id, u.attributes = c.attributes, u.x = c.x, u.y = c.y, u.label = c.label, u.title = void 0 !== c.attributes ? c.attributes.title : c.title, !0 === n.nodes.parseColor ? u.color = c.color : u.color = void 0 !== c.color ? {
            background: c.color, border: c.color, highlight: { background: c.color, border: c.color }, hover: { background: c.color, border: c.color },
          } : void 0, u.size = c.size, u.fixed = n.nodes.fixed && void 0 !== c.x && void 0 !== c.y, o.push(u);
        } return { nodes: o, edges: i };
      }e.parseGephi = o;
    }, function (t, e, i) { Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(0); const n = d(o); const s = i(1); const r = d(s); const a = i(185); const h = d(a); function d(t) { return t && t.__esModule ? t : { default: t }; } const l = (function () { function t(e) { (0, n.default)(this, t), this.images = {}, this.imageBroken = {}, this.callback = e; } return (0, r.default)(t, [{ key: '_tryloadBrokenUrl', value(t, e, i) { void 0 !== t && void 0 !== i && (void 0 !== e ? (i.onerror = function () { console.error('Could not load brokenImage:', e); }, i.image.src = e) : console.warn('No broken url image defined')); } }, { key: '_redrawWithImage', value(t) { this.callback && this.callback(t); } }, { key: 'load', value(t, e) { const i = this; const o = this.images[t]; if (o) return o; const n = new h.default(); return this.images[t] = n, n.image.onload = function () { i._fixImageCoordinates(n.image), n.init(), i._redrawWithImage(n); }, n.image.onerror = function () { console.error('Could not load image:', t), i._tryloadBrokenUrl(t, e, n); }, n.image.src = t, n; } }, { key: '_fixImageCoordinates', value(t) { t.width === 0 && (document.body.appendChild(t), t.width = t.offsetWidth, t.height = t.offsetHeight, document.body.removeChild(t)); } }]), t; }()); e.default = l; }, function (t, e, i) {
      Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(30); const n = u(o); const s = i(6); const r = u(s); const a = i(0); const h = u(a); const d = i(1); const l = u(d); function u(t) { return t && t.__esModule ? t : { default: t }; } const c = i(2); const p = i(48).default; const f = i(191).default; const m = ['bold', 'ital', 'boldital', 'mono']; const v = (function () {
        function t(e, i) {
          const o = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; (0, h.default)(this, t), this.body = e, this.pointToSelf = !1, this.baseSize = void 0, this.fontOptions = {}, this.setOptions(i), this.size = {
            top: 0, left: 0, width: 0, height: 0, yLine: 0,
          }, this.isEdgeLabel = o;
        } return (0, l.default)(t, [{ key: 'setOptions', value(t) { if (this.elementOptions = t, this.initFontOptions(t.font), p.isValidLabel(t.label) ? this.labelDirty = !0 : t.label = '', void 0 !== t.font && t.font !== null) if (typeof t.font === 'string') this.baseSize = this.fontOptions.size; else if ((0, r.default)(t.font) === 'object') { const e = t.font.size; void 0 !== e && (this.baseSize = e); } } }, { key: 'initFontOptions', value(e) { const i = this; c.forEach(m, (t) => { i.fontOptions[t] = {}; }), t.parseFontString(this.fontOptions, e) ? this.fontOptions.vadjust = 0 : c.forEach(e, (t, e) => { void 0 !== t && t !== null && (typeof t==='undefined' ? 'undefined':(0, r.default)(t)) !== 'object' && (i.fontOptions[e] = t); }); } }, {
          key: 'constrain',
          value(t) {
            const e = {
              constrainWidth: !1, maxWdt: -1, minWdt: -1, constrainHeight: !1, minHgt: -1, valign: 'middle',
            }; const i = c.topMost(t, 'widthConstraint'); if (typeof i === 'number')e.maxWdt = Number(i), e.minWdt = Number(i); else if ((typeof i === 'undefined' ? 'undefined' : (0, r.default)(i)) === 'object') { const o = c.topMost(t, ['widthConstraint', 'maximum']); typeof o === 'number' && (e.maxWdt = Number(o)); const n = c.topMost(t, ['widthConstraint', 'minimum']); typeof n === 'number' && (e.minWdt = Number(n)); } const s = c.topMost(t, 'heightConstraint'); if (typeof s === 'number')e.minHgt = Number(s); else if ((typeof s === 'undefined' ? 'undefined' : (0, r.default)(s)) === 'object') { const a = c.topMost(t, ['heightConstraint', 'minimum']); typeof a === 'number' && (e.minHgt = Number(a)); const h = c.topMost(t, ['heightConstraint', 'valign']); typeof h === 'string' && (h !== 'top' && h !== 'bottom' || (e.valign = h)); } return e;
          }, 
        }, { key: 'update', value(t, e) { this.setOptions(t, !0), this.propagateFonts(e), c.deepExtend(this.fontOptions, this.constrain(e)), this.fontOptions.chooser = p.choosify('label', e); } }, { key: 'adjustSizes', value(t) { const e = t ? t.right + t.left : 0; this.fontOptions.constrainWidth && (this.fontOptions.maxWdt -= e, this.fontOptions.minWdt -= e); const i = t ? t.top + t.bottom : 0; this.fontOptions.constrainHeight && (this.fontOptions.minHgt -= i); } }, { key: 'addFontOptionsToPile', value(t, e) { for (let i = 0; i < e.length; ++i) this.addFontToPile(t, e[i]); } }, { key: 'addFontToPile', value(t, e) { if (void 0 !== e && void 0 !== e.font && e.font !== null) { const i = e.font; t.push(i); } } }, { key: 'getBasicOptions', value(e) { for (var i = {}, o = 0; o < e.length; ++o) { let n = e[o]; const s = {}; t.parseFontString(s, n) && (n = s), c.forEach(n, (t, e) => { void 0 !== t && (i.hasOwnProperty(e) || (m.indexOf(e) !== -1 ? i[e] = {} : i[e] = t)); }); } return i; } }, { key: 'getFontOption', value(e, i, o) { for (let n = void 0, s = 0; s < e.length; ++s) { const r = e[s]; if (r.hasOwnProperty(i)) { if (n = r[i], void 0 === n || n === null) continue; const a = {}; if (t.parseFontString(a, n) && (n = a), n.hasOwnProperty(o)) return n[o]; } } if (this.fontOptions.hasOwnProperty(o)) return this.fontOptions[o]; throw new Error(`Did not find value for multi-font for property: '${o}'`); } }, { key: 'getFontOptions', value(t, e) { for (var i = {}, o = ['color', 'size', 'face', 'mod', 'vadjust'], n = 0; n < o.length; ++n) { const s = o[n]; i[s] = this.getFontOption(t, e, s); } return i; } }, { key: 'propagateFonts', value(t) { const e = this; const i = []; this.addFontOptionsToPile(i, t), this.fontOptions = this.getBasicOptions(i); for (let o = function (t) { const o = m[t]; const n = e.fontOptions[o]; const s = e.getFontOptions(i, o); c.forEach(s, (t, e) => { n[e] = t; }), n.size = Number(n.size), n.vadjust = Number(n.vadjust); }, n = 0; n < m.length; ++n)o(n); } }, { key: 'draw', value(t, e, i, o, n) { const s = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 'middle'; if (void 0 !== this.elementOptions.label) { let r = this.fontOptions.size * this.body.view.scale; this.elementOptions.label && r < this.elementOptions.scaling.label.drawThreshold - 1 || (r >= this.elementOptions.scaling.label.maxVisible && (r = Number(this.elementOptions.scaling.label.maxVisible) / this.body.view.scale), this.calculateLabelSize(t, o, n, e, i, s), this._drawBackground(t), this._drawText(t, e, this.size.yLine, s, r)); } } }, { key: '_drawBackground', value(t) { if (void 0 !== this.fontOptions.background && this.fontOptions.background !== 'none') { t.fillStyle = this.fontOptions.background; const e = this.getSize(); t.fillRect(e.left, e.top, e.width, e.height); } } }, {
          key: '_drawText',
          value(t, e, i) {
            const o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 'middle'; const s = arguments[4]; const r = this._setAlignment(t, e, i, o); const 
              a = (0, n.default)(r, 2); e = a[0], i = a[1], t.textAlign = 'left', e -= this.size.width / 2, this.fontOptions.valign && this.size.height > this.size.labelHeight && (this.fontOptions.valign === 'top' && (i -= (this.size.height - this.size.labelHeight) / 2), this.fontOptions.valign === 'bottom' && (i += (this.size.height - this.size.labelHeight) / 2)); for (let h = 0; h < this.lineCount; h++) { const d = this.lines[h]; if (d && d.blocks) { let l = 0; this.isEdgeLabel || this.fontOptions.align === 'center' ? l += (this.size.width - d.width) / 2 : this.fontOptions.align === 'right' && (l += this.size.width - d.width); for (let u = 0; u < d.blocks.length; u++) { const c = d.blocks[u]; t.font = c.font; const p = this._getColor(c.color, s, c.strokeColor); const f = (0, n.default)(p, 2); const m = f[0]; const v = f[1]; c.strokeWidth > 0 && (t.lineWidth = c.strokeWidth, t.strokeStyle = v, t.lineJoin = 'round'), t.fillStyle = m, c.strokeWidth > 0 && t.strokeText(c.text, e + l, i + c.vadjust), t.fillText(c.text, e + l, i + c.vadjust), l += c.width; }i += d.height; } }
          }, 
        }, { key: '_setAlignment', value(t, e, i, o) { if (this.isEdgeLabel && this.fontOptions.align !== 'horizontal' && !1 === this.pointToSelf) { e = 0, i = 0; const n = 2; this.fontOptions.align === 'top' ? (t.textBaseline = 'alphabetic', i -= 2 * n) : this.fontOptions.align === 'bottom' ? (t.textBaseline = 'hanging', i += 2 * n) : t.textBaseline = 'middle'; } else t.textBaseline = o; return [e, i]; } }, { key: '_getColor', value(t, e, i) { let o = t || '#000000'; let n = i || '#ffffff'; if (e <= this.elementOptions.scaling.label.drawThreshold) { const s = Math.max(0, Math.min(1, 1 - (this.elementOptions.scaling.label.drawThreshold - e))); o = c.overrideOpacity(o, s), n = c.overrideOpacity(n, s); } return [o, n]; } }, { key: 'getTextSize', value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; const i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; return this._processLabel(t, e, i), { width: this.size.width, height: this.size.height, lineCount: this.lineCount }; } }, {
          key: 'getSize',
          value() {
            const t = 2; let e = this.size.left; let i = this.size.top - 0.5 * t; if (this.isEdgeLabel) { const o = 0.5 * -this.size.width; switch (this.fontOptions.align) { case 'middle': e = o, i = 0.5 * -this.size.height; break; case 'top': e = o, i = -(this.size.height + t); break; case 'bottom': e = o, i = t; break; } } const n = {
              left: e, top: i, width: this.size.width, height: this.size.height,
            }; return n;
          }, 
        }, { key: 'calculateLabelSize', value(t, e, i) { const o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0; const n = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0; const s = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 'middle'; this._processLabel(t, e, i), this.size.left = o - 0.5 * this.size.width, this.size.top = n - 0.5 * this.size.height, this.size.yLine = n + 0.5 * (1 - this.lineCount) * this.fontOptions.size, s === 'hanging' && (this.size.top += 0.5 * this.fontOptions.size, this.size.top += 4, this.size.yLine += 4); } }, {
          key: 'getFormattingValues',
          value(t, e, i, o) {
            const n = function (t, e, i) { return e === 'normal' ? i === 'mod' ? '' : t[i] : void 0 !== t[e][i] ? t[e][i] : t[i]; }; const s = {
              color: n(this.fontOptions, o, 'color'), size: n(this.fontOptions, o, 'size'), face: n(this.fontOptions, o, 'face'), mod: n(this.fontOptions, o, 'mod'), vadjust: n(this.fontOptions, o, 'vadjust'), strokeWidth: this.fontOptions.strokeWidth, strokeColor: this.fontOptions.strokeColor,
            }; (e || i) && (o === 'normal' && !0 === this.fontOptions.chooser && this.elementOptions.labelHighlightBold ? s.mod = 'bold' : typeof this.fontOptions.chooser === 'function' && this.fontOptions.chooser(s, this.elementOptions.id, e, i)); let r = ''; return void 0 !== s.mod && s.mod !== '' && (r += `${s.mod} `), r += `${s.size}px ${s.face}`, t.font = r.replace(/"/g, ''), s.font = t.font, s.height = s.size, s;
          }, 
        }, { key: 'differentState', value(t, e) { return t !== this.selectedState || e !== this.hoverState; } }, { key: '_processLabelText', value(t, e, i, o) { const n = new f(t, this, e, i); return n.process(o); } }, { key: '_processLabel', value(t, e, i) { if (!1 !== this.labelDirty || this.differentState(e, i)) { const o = this._processLabelText(t, e, i, this.elementOptions.label); this.fontOptions.minWdt > 0 && o.width < this.fontOptions.minWdt && (o.width = this.fontOptions.minWdt), this.size.labelHeight = o.height, this.fontOptions.minHgt > 0 && o.height < this.fontOptions.minHgt && (o.height = this.fontOptions.minHgt), this.lines = o.lines, this.lineCount = o.lines.length, this.size.width = o.width, this.size.height = o.height, this.selectedState = e, this.hoverState = i, this.labelDirty = !1; } } }, { key: 'visible', value() { if (this.size.width === 0 || this.size.height === 0 || void 0 === this.elementOptions.label) return !1; const t = this.fontOptions.size * this.body.view.scale; return !(t < this.elementOptions.scaling.label.drawThreshold - 1); } }], [{ key: 'parseFontString', value(t, e) { if (!e || typeof e !== 'string') return !1; const i = e.split(' '); return t.size = i[0].replace('px', ''), t.face = i[1], t.color = i[2], !0; } }]), t;
      }()); e.default = v;
    }, function (t, e, i) {
      Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(30); const n = d(o); const s = i(0); const r = d(s); const a = i(1); const h = d(a); function d(t) { return t && t.__esModule ? t : { default: t }; } const l = i(2); const u = i(119).default; const c = (function () {
        function t(e, i, o) { (0, r.default)(this, t), this.body = i, this.labelModule = o, this.options = {}, this.setOptions(e), this.colorDirty = !0, this.color = {}, this.selectionWidth = 2, this.hoverWidth = 1.5, this.fromPoint = this.from, this.toPoint = this.to; } return (0, h.default)(t, [{ key: 'connect', value() { this.from = this.body.nodes[this.options.from], this.to = this.body.nodes[this.options.to]; } }, { key: 'cleanup', value() { return !1; } }, { key: 'setOptions', value(t) { this.options = t, this.from = this.body.nodes[this.options.from], this.to = this.body.nodes[this.options.to], this.id = this.options.id; } }, { key: 'drawLine', value(t, e, i, o, n) { t.strokeStyle = this.getColor(t, e, i, o), t.lineWidth = e.width, !1 !== e.dashes ? this._drawDashedLine(t, e, n) : this._drawLine(t, e, n); } }, { key: '_drawLine', value(t, e, i, o, s) { if (this.from != this.to) this._line(t, e, i, o, s); else { const r = this._getCircleData(t); const a = (0, n.default)(r, 3); const h = a[0]; const d = a[1]; const l = a[2]; this._circle(t, e, h, d, l); } } }, { key: '_drawDashedLine', value(t, e, i, o, s) { t.lineCap = 'round'; let r = [5, 5]; if (!0 === Array.isArray(e.dashes) && (r = e.dashes), void 0 !== t.setLineDash) { if (t.save(), t.setLineDash(r), t.lineDashOffset = 0, this.from != this.to) this._line(t, e, i); else { const a = this._getCircleData(t); const h = (0, n.default)(a, 3); const d = h[0]; const l = h[1]; const u = h[2]; this._circle(t, e, d, l, u); }t.setLineDash([0]), t.lineDashOffset = 0, t.restore(); } else { if (this.from != this.to)t.dashedLine(this.from.x, this.from.y, this.to.x, this.to.y, r); else { const c = this._getCircleData(t); const p = (0, n.default)(c, 3); const f = p[0]; const m = p[1]; const v = p[2]; this._circle(t, e, f, m, v); } this.enableShadow(t, e), t.stroke(), this.disableShadow(t, e); } } }, { key: 'findBorderPosition', value(t, e, i) { return this.from != this.to ? this._findBorderPosition(t, e, i) : this._findBorderPositionCircle(t, e, i); } }, {
          key: 'findBorderPositions',
          value(t) {
            let e = {}; let i = {}; if (this.from != this.to)e = this._findBorderPosition(this.from, t), i = this._findBorderPosition(this.to, t); else {
              const o = this._getCircleData(t).slice(0, 2); const s = (0, n.default)(o, 2); const r = s[0]; const a = s[1]; e = this._findBorderPositionCircle(this.from, t, {
                x: r, y: a, low: 0.25, high: 0.6, direction: -1,
              }), i = this._findBorderPositionCircle(this.from, t, {
                x: r, y: a, low: 0.6, high: 0.8, direction: 1,
              });
            } return { from: e, to: i };
          }, 
        }, { key: '_getCircleData', value(t) { let e = void 0; let i = void 0; const o = this.from; const n = this.options.selfReferenceSize; return void 0 !== t && void 0 === o.shape.width && o.shape.resize(t), o.shape.width > o.shape.height ? (e = o.x + 0.5 * o.shape.width, i = o.y - n) : (e = o.x + n, i = o.y - 0.5 * o.shape.height), [e, i, n]; } }, { key: '_pointOnCircle', value(t, e, i, o) { const n = 2 * o * Math.PI; return { x: t + i * Math.cos(n), y: e - i * Math.sin(n) }; } }, { key: '_findBorderPositionCircle', value(t, e, i) { const o = i.x; const n = i.y; let s = i.low; let r = i.high; const a = i.direction; const h = 10; let d = 0; const l = this.options.selfReferenceSize; let u = void 0; let c = void 0; let p = void 0; let f = void 0; let m = void 0; const v = 0.05; let g = 0.5 * (s + r); while (s <= r && d < h) { if (g = 0.5 * (s + r), u = this._pointOnCircle(o, n, l, g), c = Math.atan2(t.y - u.y, t.x - u.x), p = t.distanceToBorder(e, c), f = Math.sqrt(Math.pow(u.x - t.x, 2) + Math.pow(u.y - t.y, 2)), m = p - f, Math.abs(m) < v) break; m > 0 ? a > 0 ? s = g : r = g : a > 0 ? r = g : s = g, d++; } return u.t = g, u; } }, { key: 'getLineWidth', value(t, e) { return !0 === t ? Math.max(this.selectionWidth, 0.3 / this.body.view.scale) : !0 === e ? Math.max(this.hoverWidth, 0.3 / this.body.view.scale) : Math.max(this.options.width, 0.3 / this.body.view.scale); } }, { key: 'getColor', value(t, e, i, o) { if (!1 !== e.inheritsColor) { if (e.inheritsColor === 'both' && this.from.id !== this.to.id) { const n = t.createLinearGradient(this.from.x, this.from.y, this.to.x, this.to.y); let s = void 0; let r = void 0; return s = this.from.options.color.highlight.border, r = this.to.options.color.highlight.border, !1 === this.from.selected && !1 === this.to.selected ? (s = l.overrideOpacity(this.from.options.color.border, e.opacity), r = l.overrideOpacity(this.to.options.color.border, e.opacity)) : !0 === this.from.selected && !1 === this.to.selected ? r = this.to.options.color.border : !1 === this.from.selected && !0 === this.to.selected && (s = this.from.options.color.border), n.addColorStop(0, s), n.addColorStop(1, r), n; } return e.inheritsColor === 'to' ? l.overrideOpacity(this.to.options.color.border, e.opacity) : l.overrideOpacity(this.from.options.color.border, e.opacity); } return l.overrideOpacity(e.color, e.opacity); } }, { key: '_circle', value(t, e, i, o, n) { this.enableShadow(t, e), t.beginPath(), t.arc(i, o, n, 0, 2 * Math.PI, !1), t.stroke(), this.disableShadow(t, e); } }, { key: 'getDistanceToEdge', value(t, e, i, o, s, r, a, h) { let d = 0; if (this.from != this.to)d = this._getDistanceToEdge(t, e, i, o, s, r, a); else { const l = this._getCircleData(void 0); const u = (0, n.default)(l, 3); const c = u[0]; const p = u[1]; const f = u[2]; const m = c - s; const v = p - r; d = Math.abs(Math.sqrt(m * m + v * v) - f); } return d; } }, { key: '_getDistanceToLine', value(t, e, i, o, n, s) { const r = i - t; const a = o - e; const h = r * r + a * a; let d = ((n - t) * r + (s - e) * a) / h; d > 1 ? d = 1 : d < 0 && (d = 0); const l = t + d * r; const u = e + d * a; const c = l - n; const p = u - s; return Math.sqrt(c * c + p * p); } }, {
          key: 'getArrowData',
          value(t, e, i, o, s, r) {
            let a = void 0; let h = void 0; let d = void 0; let l = void 0; let u = void 0; let c = void 0; let p = void 0; let f = r.width; if (e === 'from' ? (d = this.from, l = this.to, u = 0.1, c = r.fromArrowScale, p = r.fromArrowType) : e === 'to' ? (d = this.to, l = this.from, u = -0.1, c = r.toArrowScale, p = r.toArrowType) : (d = this.to, l = this.from, c = r.middleArrowScale, p = r.middleArrowType), d != l) if (e !== 'middle') if (!0 === this.options.smooth.enabled) { h = this.findBorderPosition(d, t, { via: i }); const m = this.getPoint(Math.max(0, Math.min(1, h.t + u)), i); a = Math.atan2(h.y - m.y, h.x - m.x); } else a = Math.atan2(d.y - l.y, d.x - l.x), h = this.findBorderPosition(d, t); else a = Math.atan2(d.y - l.y, d.x - l.x), h = this.getPoint(0.5, i); else {
              const v = this._getCircleData(t); const g = (0, n.default)(v, 3); const y = g[0]; const b = g[1]; const _ = g[2]; e === 'from' ? (h = this.findBorderPosition(this.from, t, {
                x: y, y: b, low: 0.25, high: 0.6, direction: -1,
              }), a = -2 * h.t * Math.PI + 1.5 * Math.PI + 0.1 * Math.PI) : e === 'to' ? (h = this.findBorderPosition(this.from, t, {
                x: y, y: b, low: 0.6, high: 1, direction: 1,
              }), a = -2 * h.t * Math.PI + 1.5 * Math.PI - 1.1 * Math.PI) : (h = this._pointOnCircle(y, b, _, 0.175), a = 3.9269908169872414);
            }e === 'middle' && c < 0 && (f *= -1); const w = 15 * c + 3 * f; const x = h.x - 0.9 * w * Math.cos(a); const k = h.y - 0.9 * w * Math.sin(a); const D = { x, y: k }; return {
              point: h, core: D, angle: a, length: w, type: p,
            };
          }, 
        }, { key: 'drawArrowHead', value(t, e, i, o, n) { t.strokeStyle = this.getColor(t, e, i, o), t.fillStyle = t.strokeStyle, t.lineWidth = e.width, u.draw(t, n), this.enableShadow(t, e), t.fill(), this.disableShadow(t, e); } }, { key: 'enableShadow', value(t, e) { !0 === e.shadow && (t.shadowColor = e.shadowColor, t.shadowBlur = e.shadowSize, t.shadowOffsetX = e.shadowX, t.shadowOffsetY = e.shadowY); } }, { key: 'disableShadow', value(t, e) { !0 === e.shadow && (t.shadowColor = 'rgba(0,0,0,0)', t.shadowBlur = 0, t.shadowOffsetX = 0, t.shadowOffsetY = 0); } }]), t;
      }()); e.default = c;
    }, function (t, e, i) { Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(3); const n = p(o); const s = i(4); const r = p(s); const a = i(5); const h = p(a); const d = i(0); const l = p(d); const u = i(1); const c = p(u); function p(t) { return t && t.__esModule ? t : { default: t }; } const f = (function () { function t() { (0, l.default)(this, t); } return (0, c.default)(t, null, [{ key: 'transform', value(t, e) { t instanceof Array || (t = [t]); for (let i = e.point.x, o = e.point.y, n = e.angle, s = e.length, r = 0; r < t.length; ++r) { const a = t[r]; const h = a.x * Math.cos(n) - a.y * Math.sin(n); const d = a.x * Math.sin(n) + a.y * Math.cos(n); a.x = i + s * h, a.y = o + s * d; } } }, { key: 'drawPath', value(t, e) { t.beginPath(), t.moveTo(e[0].x, e[0].y); for (let i = 1; i < e.length; ++i)t.lineTo(e[i].x, e[i].y); t.closePath(); } }]), t; }()); const m = (function (t) { function e() { return (0, l.default)(this, e), (0, r.default)(this, (e.__proto__ || (0, n.default)(e)).apply(this, arguments)); } return (0, h.default)(e, t), (0, c.default)(e, null, [{ key: 'draw', value(t, e) { const i = [{ x: 0, y: 0 }, { x: -1, y: 0.3 }, { x: -0.9, y: 0 }, { x: -1, y: -0.3 }]; f.transform(i, e), f.drawPath(t, i); } }]), e; }(f)); const v = (function () { function t() { (0, l.default)(this, t); } return (0, c.default)(t, null, [{ key: 'draw', value(t, e) { const i = { x: -0.4, y: 0 }; f.transform(i, e), t.circle(i.x, i.y, 0.4 * e.length); } }]), t; }()); const g = (function () { function t() { (0, l.default)(this, t); } return (0, c.default)(t, null, [{ key: 'draw', value(t, e) { const i = [{ x: 0, y: 0.5 }, { x: 0, y: -0.5 }, { x: -0.15, y: -0.5 }, { x: -0.15, y: 0.5 }]; f.transform(i, e), f.drawPath(t, i); } }]), t; }()); const y = (function () { function t() { (0, l.default)(this, t); } return (0, c.default)(t, null, [{ key: 'draw', value(t, e) { let i; switch (e.type && (i = e.type.toLowerCase()), i) { case 'circle': v.draw(t, e); break; case 'bar': g.draw(t, e); break; case 'arrow': default: m.draw(t, e); } } }]), t; }()); e.default = y; }, function (t, e, i) {
      Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(0); const n = a(o); const s = i(1); const r = a(s); function a(t) { return t && t.__esModule ? t : { default: t }; } const h = (function () {
        function t(e, i, o) { (0, n.default)(this, t), this.body = e, this.physicsBody = i, this.barnesHutTree, this.setOptions(o), this.randomSeed = 5; } return (0, r.default)(t, [{ key: 'setOptions', value(t) { this.options = t, this.thetaInversed = 1 / this.options.theta, this.overlapAvoidanceFactor = 1 - Math.max(0, Math.min(1, this.options.avoidOverlap)); } }, { key: 'seededRandom', value() { const t = 1e4 * Math.sin(this.randomSeed++); return t - Math.floor(t); } }, { key: 'solve', value() { if (this.options.gravitationalConstant !== 0 && this.physicsBody.physicsNodeIndices.length > 0) { let t = void 0; const e = this.body.nodes; const i = this.physicsBody.physicsNodeIndices; const o = i.length; const n = this._formBarnesHutTree(e, i); this.barnesHutTree = n; for (let s = 0; s < o; s++)t = e[i[s]], t.options.mass > 0 && this._getForceContributions(n.root, t); } } }, { key: '_getForceContributions', value(t, e) { this._getForceContribution(t.children.NW, e), this._getForceContribution(t.children.NE, e), this._getForceContribution(t.children.SW, e), this._getForceContribution(t.children.SE, e); } }, { key: '_getForceContribution', value(t, e) { if (t.childrenCount > 0) { let i = void 0; let o = void 0; let n = void 0; i = t.centerOfMass.x - e.x, o = t.centerOfMass.y - e.y, n = Math.sqrt(i * i + o * o), n * t.calcSize > this.thetaInversed ? this._calculateForces(n, i, o, e, t) : t.childrenCount === 4 ? this._getForceContributions(t, e) : t.children.data.id != e.id && this._calculateForces(n, i, o, e, t); } } }, { key: '_calculateForces', value(t, e, i, o, n) { t === 0 && (t = 0.1, e = t), this.overlapAvoidanceFactor < 1 && o.shape.radius && (t = Math.max(0.1 + this.overlapAvoidanceFactor * o.shape.radius, t - o.shape.radius)); const s = this.options.gravitationalConstant * n.mass * o.options.mass / Math.pow(t, 3); const r = e * s; const a = i * s; this.physicsBody.forces[o.id].x += r, this.physicsBody.forces[o.id].y += a; } }, {
          key: '_formBarnesHutTree',
          value(t, e) {
            for (var i = void 0, o = e.length, n = t[e[0]].x, s = t[e[0]].y, r = t[e[0]].x, a = t[e[0]].y, h = 1; h < o; h++) { const d = t[e[h]]; const l = d.x; const u = d.y; d.options.mass > 0 && (l < n && (n = l), l > r && (r = l), u < s && (s = u), u > a && (a = u)); } const c = Math.abs(r - n) - Math.abs(a - s); c > 0 ? (s -= 0.5 * c, a += 0.5 * c) : (n += 0.5 * c, r -= 0.5 * c); const p = 1e-5; const f = Math.max(p, Math.abs(r - n)); const m = 0.5 * f; const v = 0.5 * (n + r); const g = 0.5 * (s + a); const y = {
              root: {
                centerOfMass: { x: 0, y: 0 },
                mass: 0,
                range: {
                  minX: v - m, maxX: v + m, minY: g - m, maxY: g + m,
                },
                size: f,
                calcSize: 1 / f,
                children: { data: null },
                maxWidth: 0,
                level: 0,
                childrenCount: 4,
              }, 
            }; this._splitBranch(y.root); for (let b = 0; b < o; b++)i = t[e[b]], i.options.mass > 0 && this._placeInTree(y.root, i); return y;
          }, 
        }, { key: '_updateBranchMass', value(t, e) { const i = t.centerOfMass; const o = t.mass + e.options.mass; const n = 1 / o; i.x = i.x * t.mass + e.x * e.options.mass, i.x *= n, i.y = i.y * t.mass + e.y * e.options.mass, i.y *= n, t.mass = o; const s = Math.max(Math.max(e.height, e.radius), e.width); t.maxWidth = t.maxWidth < s ? s : t.maxWidth; } }, { key: '_placeInTree', value(t, e, i) { i == 1 && void 0 !== i || this._updateBranchMass(t, e); const o = t.children.NW.range; let n = void 0; n = o.maxX > e.x ? o.maxY > e.y ? 'NW' : 'SW' : o.maxY > e.y ? 'NE' : 'SE', this._placeInRegion(t, e, n); } }, { key: '_placeInRegion', value(t, e, i) { const o = t.children[i]; switch (o.childrenCount) { case 0: o.children.data = e, o.childrenCount = 1, this._updateBranchMass(o, e); break; case 1: o.children.data.x === e.x && o.children.data.y === e.y ? (e.x += this.seededRandom(), e.y += this.seededRandom()) : (this._splitBranch(o), this._placeInTree(o, e)); break; case 4: this._placeInTree(o, e); break; } } }, { key: '_splitBranch', value(t) { let e = null; t.childrenCount === 1 && (e = t.children.data, t.mass = 0, t.centerOfMass.x = 0, t.centerOfMass.y = 0), t.childrenCount = 4, t.children.data = null, this._insertRegion(t, 'NW'), this._insertRegion(t, 'NE'), this._insertRegion(t, 'SW'), this._insertRegion(t, 'SE'), e != null && this._placeInTree(t, e); } }, {
          key: '_insertRegion',
          value(t, e) {
            let i = void 0; let o = void 0; let n = void 0; let s = void 0; const r = 0.5 * t.size; switch (e) { case 'NW': i = t.range.minX, o = t.range.minX + r, n = t.range.minY, s = t.range.minY + r; break; case 'NE': i = t.range.minX + r, o = t.range.maxX, n = t.range.minY, s = t.range.minY + r; break; case 'SW': i = t.range.minX, o = t.range.minX + r, n = t.range.minY + r, s = t.range.maxY; break; case 'SE': i = t.range.minX + r, o = t.range.maxX, n = t.range.minY + r, s = t.range.maxY; break; }t.children[e] = {
              centerOfMass: { x: 0, y: 0 },
              mass: 0,
              range: {
                minX: i, maxX: o, minY: n, maxY: s,
              },
              size: 0.5 * t.size,
              calcSize: 2 * t.calcSize,
              children: { data: null },
              maxWidth: 0,
              level: t.level + 1,
              childrenCount: 0,
            };
          }, 
        }, { key: '_debug', value(t, e) { void 0 !== this.barnesHutTree && (t.lineWidth = 1, this._drawBranch(this.barnesHutTree.root, t, e)); } }, { key: '_drawBranch', value(t, e, i) { void 0 === i && (i = '#FF0000'), t.childrenCount === 4 && (this._drawBranch(t.children.NW, e), this._drawBranch(t.children.NE, e), this._drawBranch(t.children.SE, e), this._drawBranch(t.children.SW, e)), e.strokeStyle = i, e.beginPath(), e.moveTo(t.range.minX, t.range.minY), e.lineTo(t.range.maxX, t.range.minY), e.stroke(), e.beginPath(), e.moveTo(t.range.maxX, t.range.minY), e.lineTo(t.range.maxX, t.range.maxY), e.stroke(), e.beginPath(), e.moveTo(t.range.maxX, t.range.maxY), e.lineTo(t.range.minX, t.range.maxY), e.stroke(), e.beginPath(), e.moveTo(t.range.minX, t.range.maxY), e.lineTo(t.range.minX, t.range.minY), e.stroke(); } }]), t;
      }()); e.default = h;
    }, function (t, e, i) { Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(0); const n = a(o); const s = i(1); const r = a(s); function a(t) { return t && t.__esModule ? t : { default: t }; } const h = (function () { function t(e, i, o) { (0, n.default)(this, t), this.body = e, this.physicsBody = i, this.setOptions(o); } return (0, r.default)(t, [{ key: 'setOptions', value(t) { this.options = t; } }, { key: 'solve', value() { for (let t = void 0, e = void 0, i = void 0, o = void 0, n = this.body.nodes, s = this.physicsBody.physicsNodeIndices, r = this.physicsBody.forces, a = 0; a < s.length; a++) { const h = s[a]; o = n[h], t = -o.x, e = -o.y, i = Math.sqrt(t * t + e * e), this._calculateForces(i, t, e, r, o); } } }, { key: '_calculateForces', value(t, e, i, o, n) { const s = t === 0 ? 0 : this.options.centralGravity / t; o[n.id].x = e * s, o[n.id].y = i * s; } }]), t; }()); e.default = h; }, function (t, e, i) {
      Object.defineProperty(e, '__esModule', { value: !0 }); const o = 'string'; const n = 'boolean'; const s = 'number'; const r = 'array'; const a = 'object'; const h = 'dom'; const d = 'any'; const l = ['arrow', 'circle', 'bar']; const u = {
        configure: {
          enabled: { boolean: n },
          filter: {
            boolean: n, string: o, array: r, function: 'function',
          },
          container: { dom: h },
          showButton: { boolean: n },
          __type__: {
            object: a, boolean: n, string: o, array: r, function: 'function',
          },
        },
        edges: {
          arrows: {
            to: {
              enabled: { boolean: n }, scaleFactor: { number: s }, type: { string: l }, __type__: { object: a, boolean: n },
            },
            middle: {
              enabled: { boolean: n }, scaleFactor: { number: s }, type: { string: l }, __type__: { object: a, boolean: n },
            },
            from: {
              enabled: { boolean: n }, scaleFactor: { number: s }, type: { string: l }, __type__: { object: a, boolean: n },
            },
            __type__: { string: ['from', 'to', 'middle'], object: a },
          },
          arrowStrikethrough: { boolean: n },
          chosen: { label: { boolean: n, function: 'function' }, edge: { boolean: n, function: 'function' }, __type__: { object: a, boolean: n } },
          color: {
            color: { string: o }, highlight: { string: o }, hover: { string: o }, inherit: { string: ['from', 'to', 'both'], boolean: n }, opacity: { number: s }, __type__: { object: a, string: o },
          },
          dashes: { boolean: n, array: r },
          font: {
            color: { string: o },
            size: { number: s },
            face: { string: o },
            background: { string: o },
            strokeWidth: { number: s },
            strokeColor: { string: o },
            align: { string: ['horizontal', 'top', 'middle', 'bottom'] },
            vadjust: { number: s },
            multi: { boolean: n, string: o },
            bold: {
              color: { string: o }, size: { number: s }, face: { string: o }, mod: { string: o }, vadjust: { number: s }, __type__: { object: a, string: o },
            },
            boldital: {
              color: { string: o }, size: { number: s }, face: { string: o }, mod: { string: o }, vadjust: { number: s }, __type__: { object: a, string: o },
            },
            ital: {
              color: { string: o }, size: { number: s }, face: { string: o }, mod: { string: o }, vadjust: { number: s }, __type__: { object: a, string: o },
            },
            mono: {
              color: { string: o }, size: { number: s }, face: { string: o }, mod: { string: o }, vadjust: { number: s }, __type__: { object: a, string: o },
            },
            __type__: { object: a, string: o },
          },
          hidden: { boolean: n },
          hoverWidth: { function: 'function', number: s },
          label: { string: o, undefined: 'undefined' },
          labelHighlightBold: { boolean: n },
          length: { number: s, undefined: 'undefined' },
          physics: { boolean: n },
          scaling: {
            min: { number: s },
            max: { number: s },
            label: {
              enabled: { boolean: n }, min: { number: s }, max: { number: s }, maxVisible: { number: s }, drawThreshold: { number: s }, __type__: { object: a, boolean: n },
            },
            customScalingFunction: { function: 'function' },
            __type__: { object: a },
          },
          selectionWidth: { function: 'function', number: s },
          selfReferenceSize: { number: s },
          shadow: {
            enabled: { boolean: n }, color: { string: o }, size: { number: s }, x: { number: s }, y: { number: s }, __type__: { object: a, boolean: n },
          },
          smooth: {
            enabled: { boolean: n }, type: { string: ['dynamic', 'continuous', 'discrete', 'diagonalCross', 'straightCross', 'horizontal', 'vertical', 'curvedCW', 'curvedCCW', 'cubicBezier'] }, roundness: { number: s }, forceDirection: { string: ['horizontal', 'vertical', 'none'], boolean: n }, __type__: { object: a, boolean: n },
          },
          title: { string: o, undefined: 'undefined' },
          width: { number: s },
          widthConstraint: { maximum: { number: s }, __type__: { object: a, boolean: n, number: s } },
          value: { number: s, undefined: 'undefined' },
          __type__: { object: a },
        },
        groups: { useDefaultGroups: { boolean: n }, __any__: 'get from nodes, will be overwritten below', __type__: { object: a } },
        interaction: {
          dragNodes: { boolean: n },
          dragView: { boolean: n },
          hideEdgesOnDrag: { boolean: n },
          hideNodesOnDrag: { boolean: n },
          hover: { boolean: n },
          keyboard: {
            enabled: { boolean: n },
            speed: {
              x: { number: s }, y: { number: s }, zoom: { number: s }, __type__: { object: a },
            },
            bindToWindow: { boolean: n },
            __type__: { object: a, boolean: n },
          },
          multiselect: { boolean: n },
          navigationButtons: { boolean: n },
          selectable: { boolean: n },
          selectConnectedEdges: { boolean: n },
          hoverConnectedEdges: { boolean: n },
          tooltipDelay: { number: s },
          zoomView: { boolean: n },
          __type__: { object: a },
        },
        layout: {
          randomSeed: { undefined: 'undefined', number: s },
          improvedLayout: { boolean: n },
          hierarchical: {
            enabled: { boolean: n }, levelSeparation: { number: s }, nodeSpacing: { number: s }, treeSpacing: { number: s }, blockShifting: { boolean: n }, edgeMinimization: { boolean: n }, parentCentralization: { boolean: n }, direction: { string: ['UD', 'DU', 'LR', 'RL'] }, sortMethod: { string: ['hubsize', 'directed'] }, __type__: { object: a, boolean: n },
          },
          __type__: { object: a },
        },
        manipulation: {
          enabled: { boolean: n }, initiallyActive: { boolean: n }, addNode: { boolean: n, function: 'function' }, addEdge: { boolean: n, function: 'function' }, editNode: { function: 'function' }, editEdge: { editWithoutDrag: { function: 'function' }, __type__: { object: a, boolean: n, function: 'function' } }, deleteNode: { boolean: n, function: 'function' }, deleteEdge: { boolean: n, function: 'function' }, controlNodeStyle: 'get from nodes, will be overwritten below', __type__: { object: a, boolean: n },
        },
        nodes: {
          borderWidth: { number: s },
          borderWidthSelected: { number: s, undefined: 'undefined' },
          brokenImage: { string: o, undefined: 'undefined' },
          chosen: { label: { boolean: n, function: 'function' }, node: { boolean: n, function: 'function' }, __type__: { object: a, boolean: n } },
          color: {
            border: { string: o }, background: { string: o }, highlight: { border: { string: o }, background: { string: o }, __type__: { object: a, string: o } }, hover: { border: { string: o }, background: { string: o }, __type__: { object: a, string: o } }, __type__: { object: a, string: o },
          },
          fixed: { x: { boolean: n }, y: { boolean: n }, __type__: { object: a, boolean: n } },
          font: {
            align: { string: o },
            color: { string: o },
            size: { number: s },
            face: { string: o },
            background: { string: o },
            strokeWidth: { number: s },
            strokeColor: { string: o },
            vadjust: { number: s },
            multi: { boolean: n, string: o },
            bold: {
              color: { string: o }, size: { number: s }, face: { string: o }, mod: { string: o }, vadjust: { number: s }, __type__: { object: a, string: o },
            },
            boldital: {
              color: { string: o }, size: { number: s }, face: { string: o }, mod: { string: o }, vadjust: { number: s }, __type__: { object: a, string: o },
            },
            ital: {
              color: { string: o }, size: { number: s }, face: { string: o }, mod: { string: o }, vadjust: { number: s }, __type__: { object: a, string: o },
            },
            mono: {
              color: { string: o }, size: { number: s }, face: { string: o }, mod: { string: o }, vadjust: { number: s }, __type__: { object: a, string: o },
            },
            __type__: { object: a, string: o },
          },
          group: { string: o, number: s, undefined: 'undefined' },
          heightConstraint: { minimum: { number: s }, valign: { string: o }, __type__: { object: a, boolean: n, number: s } },
          hidden: { boolean: n },
          icon: {
            face: { string: o }, code: { string: o }, size: { number: s }, color: { string: o }, __type__: { object: a },
          },
          id: { string: o, number: s },
          image: { selected: { string: o, undefined: 'undefined' }, unselected: { string: o, undefined: 'undefined' }, __type__: { object: a, string: o } },
          label: { string: o, undefined: 'undefined' },
          labelHighlightBold: { boolean: n },
          level: { number: s, undefined: 'undefined' },
          margin: {
            top: { number: s }, right: { number: s }, bottom: { number: s }, left: { number: s }, __type__: { object: a, number: s },
          },
          mass: { number: s },
          physics: { boolean: n },
          scaling: {
            min: { number: s },
            max: { number: s },
            label: {
              enabled: { boolean: n }, min: { number: s }, max: { number: s }, maxVisible: { number: s }, drawThreshold: { number: s }, __type__: { object: a, boolean: n },
            },
            customScalingFunction: { function: 'function' },
            __type__: { object: a },
          },
          shadow: {
            enabled: { boolean: n }, color: { string: o }, size: { number: s }, x: { number: s }, y: { number: s }, __type__: { object: a, boolean: n },
          },
          shape: { string: ['ellipse', 'circle', 'database', 'box', 'text', 'image', 'circularImage', 'diamond', 'dot', 'star', 'triangle', 'triangleDown', 'square', 'icon', 'hexagon'] },
          shapeProperties: {
            borderDashes: { boolean: n, array: r }, borderRadius: { number: s }, interpolation: { boolean: n }, useImageSize: { boolean: n }, useBorderWithImage: { boolean: n }, __type__: { object: a },
          },
          size: { number: s },
          title: { string: o, dom: h, undefined: 'undefined' },
          value: { number: s, undefined: 'undefined' },
          widthConstraint: { minimum: { number: s }, maximum: { number: s }, __type__: { object: a, boolean: n, number: s } },
          x: { number: s },
          y: { number: s },
          __type__: { object: a },
        },
        physics: {
          enabled: { boolean: n },
          barnesHut: {
            gravitationalConstant: { number: s }, centralGravity: { number: s }, springLength: { number: s }, springConstant: { number: s }, damping: { number: s }, avoidOverlap: { number: s }, __type__: { object: a },
          },
          forceAtlas2Based: {
            gravitationalConstant: { number: s }, centralGravity: { number: s }, springLength: { number: s }, springConstant: { number: s }, damping: { number: s }, avoidOverlap: { number: s }, __type__: { object: a },
          },
          repulsion: {
            centralGravity: { number: s }, springLength: { number: s }, springConstant: { number: s }, nodeDistance: { number: s }, damping: { number: s }, __type__: { object: a },
          },
          hierarchicalRepulsion: {
            centralGravity: { number: s }, springLength: { number: s }, springConstant: { number: s }, nodeDistance: { number: s }, damping: { number: s }, __type__: { object: a },
          },
          maxVelocity: { number: s },
          minVelocity: { number: s },
          solver: { string: ['barnesHut', 'repulsion', 'hierarchicalRepulsion', 'forceAtlas2Based'] },
          stabilization: {
            enabled: { boolean: n }, iterations: { number: s }, updateInterval: { number: s }, onlyDynamicEdges: { boolean: n }, fit: { boolean: n }, __type__: { object: a, boolean: n },
          },
          timestep: { number: s },
          adaptiveTimestep: { boolean: n },
          __type__: { object: a, boolean: n },
        },
        autoResize: { boolean: n },
        clickToUse: { boolean: n },
        locale: { string: o },
        locales: { __any__: { any: d }, __type__: { object: a } },
        height: { string: o },
        width: { string: o },
        __type__: { object: a },
      }; u.groups.__any__ = u.nodes, u.manipulation.controlNodeStyle = u.nodes; const c = {
        nodes: {
          borderWidth: [1, 0, 10, 1],
          borderWidthSelected: [2, 0, 10, 1],
          color: {
            border: ['color', '#2B7CE9'], background: ['color', '#97C2FC'], highlight: { border: ['color', '#2B7CE9'], background: ['color', '#D2E5FF'] }, hover: { border: ['color', '#2B7CE9'], background: ['color', '#D2E5FF'] },
          },
          fixed: { x: !1, y: !1 },
          font: {
            color: ['color', '#343434'], size: [14, 0, 100, 1], face: ['arial', 'verdana', 'tahoma'], background: ['color', 'none'], strokeWidth: [0, 0, 50, 1], strokeColor: ['color', '#ffffff'],
          },
          hidden: !1,
          labelHighlightBold: !0,
          physics: !0,
          scaling: {
            min: [10, 0, 200, 1],
            max: [30, 0, 200, 1],
            label: {
              enabled: !1, min: [14, 0, 200, 1], max: [30, 0, 200, 1], maxVisible: [30, 0, 200, 1], drawThreshold: [5, 0, 20, 1],
            },
          },
          shadow: {
            enabled: !1, color: 'rgba(0,0,0,0.5)', size: [10, 0, 20, 1], x: [5, -30, 30, 1], y: [5, -30, 30, 1],
          },
          shape: ['ellipse', 'box', 'circle', 'database', 'diamond', 'dot', 'square', 'star', 'text', 'triangle', 'triangleDown', 'hexagon'],
          shapeProperties: {
            borderDashes: !1, borderRadius: [6, 0, 20, 1], interpolation: !0, useImageSize: !1,
          },
          size: [25, 0, 200, 1],
        },
        edges: {
          arrows: { to: { enabled: !1, scaleFactor: [1, 0, 3, 0.05], type: 'arrow' }, middle: { enabled: !1, scaleFactor: [1, 0, 3, 0.05], type: 'arrow' }, from: { enabled: !1, scaleFactor: [1, 0, 3, 0.05], type: 'arrow' } },
          arrowStrikethrough: !0,
          color: {
            color: ['color', '#848484'], highlight: ['color', '#848484'], hover: ['color', '#848484'], inherit: ['from', 'to', 'both', !0, !1], opacity: [1, 0, 1, 0.05],
          },
          dashes: !1,
          font: {
            color: ['color', '#343434'], size: [14, 0, 100, 1], face: ['arial', 'verdana', 'tahoma'], background: ['color', 'none'], strokeWidth: [2, 0, 50, 1], strokeColor: ['color', '#ffffff'], align: ['horizontal', 'top', 'middle', 'bottom'],
          },
          hidden: !1,
          hoverWidth: [1.5, 0, 5, 0.1],
          labelHighlightBold: !0,
          physics: !0,
          scaling: {
            min: [1, 0, 100, 1],
            max: [15, 0, 100, 1],
            label: {
              enabled: !0, min: [14, 0, 200, 1], max: [30, 0, 200, 1], maxVisible: [30, 0, 200, 1], drawThreshold: [5, 0, 20, 1],
            },
          },
          selectionWidth: [1.5, 0, 5, 0.1],
          selfReferenceSize: [20, 0, 200, 1],
          shadow: {
            enabled: !1, color: 'rgba(0,0,0,0.5)', size: [10, 0, 20, 1], x: [5, -30, 30, 1], y: [5, -30, 30, 1],
          },
          smooth: {
            enabled: !0, type: ['dynamic', 'continuous', 'discrete', 'diagonalCross', 'straightCross', 'horizontal', 'vertical', 'curvedCW', 'curvedCCW', 'cubicBezier'], forceDirection: ['horizontal', 'vertical', 'none'], roundness: [0.5, 0, 1, 0.05],
          },
          width: [1, 0, 30, 1],
        },
        layout: {
          hierarchical: {
            enabled: !1, levelSeparation: [150, 20, 500, 5], nodeSpacing: [100, 20, 500, 5], treeSpacing: [200, 20, 500, 5], blockShifting: !0, edgeMinimization: !0, parentCentralization: !0, direction: ['UD', 'DU', 'LR', 'RL'], sortMethod: ['hubsize', 'directed'],
          },
        },
        interaction: {
          dragNodes: !0, dragView: !0, hideEdgesOnDrag: !1, hideNodesOnDrag: !1, hover: !1, keyboard: { enabled: !1, speed: { x: [10, 0, 40, 1], y: [10, 0, 40, 1], zoom: [0.02, 0, 0.1, 0.005] }, bindToWindow: !0 }, multiselect: !1, navigationButtons: !1, selectable: !0, selectConnectedEdges: !0, hoverConnectedEdges: !0, tooltipDelay: [300, 0, 1e3, 25], zoomView: !0,
        },
        manipulation: { enabled: !1, initiallyActive: !1 },
        physics: {
          enabled: !0,
          barnesHut: {
            gravitationalConstant: [-2e3, -3e4, 0, 50], centralGravity: [0.3, 0, 10, 0.05], springLength: [95, 0, 500, 5], springConstant: [0.04, 0, 1.2, 0.005], damping: [0.09, 0, 1, 0.01], avoidOverlap: [0, 0, 1, 0.01],
          },
          forceAtlas2Based: {
            gravitationalConstant: [-50, -500, 0, 1], centralGravity: [0.01, 0, 1, 0.005], springLength: [95, 0, 500, 5], springConstant: [0.08, 0, 1.2, 0.005], damping: [0.4, 0, 1, 0.01], avoidOverlap: [0, 0, 1, 0.01],
          },
          repulsion: {
            centralGravity: [0.2, 0, 10, 0.05], springLength: [200, 0, 500, 5], springConstant: [0.05, 0, 1.2, 0.005], nodeDistance: [100, 0, 500, 5], damping: [0.09, 0, 1, 0.01],
          },
          hierarchicalRepulsion: {
            centralGravity: [0.2, 0, 10, 0.05], springLength: [100, 0, 500, 5], springConstant: [0.01, 0, 1.2, 0.005], nodeDistance: [120, 0, 500, 5], damping: [0.09, 0, 1, 0.01],
          },
          maxVelocity: [50, 0, 150, 1],
          minVelocity: [0.1, 0.01, 0.5, 0.01],
          solver: ['barnesHut', 'forceAtlas2Based', 'repulsion', 'hierarchicalRepulsion'],
          timestep: [0.5, 0.01, 1, 0.01],
        },
      }; e.allOptions = u, e.configureOptions = c;
    }, function (t, e, i) { const o = i(2); o.extend(e, i(159)), o.extend(e, i(177)), o.extend(e, i(181)); }, function (t, e, i) { i(49), i(60), t.exports = i(136); }, function (t, e, i) { const o = i(126); const n = i(127); const s = i(31); const r = i(25); t.exports = i(79)(Array, 'Array', function (t, e) { this._t = r(t), this._i = 0, this._k = e; }, function () { const t = this._t; const e = this._k; const i = this._i++; return !t || i >= t.length ? (this._t = void 0, n(1)) : n(0, e == 'keys' ? i : e == 'values' ? t[i] : [i, t[i]]); }, 'values'), s.Arguments = s.Array, o('keys'), o('values'), o('entries'); }, function (t, e) { t.exports = function () {}; }, function (t, e) { t.exports = function (t, e) { return { value: e, done: !!t }; }; }, function (t, e) { t.exports = function (t) { if (typeof t !== 'function') throw TypeError(`${t} is not a function!`); return t; }; }, function (t, e, i) { const o = i(54); const n = i(39); const s = i(59); const r = {}; i(26)(r, i(13)('iterator'), function () { return this; }), t.exports = function (t, e, i) { t.prototype = o(r, { next: n(1, i) }), s(t, `${e} Iterator`); }; }, function (t, e, i) { const o = i(20); const n = i(27); const s = i(33); t.exports = i(21) ? Object.defineProperties : function (t, e) { n(t); let i; const r = s(e); const a = r.length; let h = 0; while (a > h)o.f(t, i = r[h++], e[i]); return t; }; }, function (t, e, i) { const o = i(25); const n = i(132); const s = i(133); t.exports = function (t) { return function (e, i, r) { let a; const h = o(e); const d = n(h.length); let l = s(r, d); if (t && i != i) { while (d > l) if (a = h[l++], a != a) return !0; } else for (;d > l; l++) if ((t || l in h) && h[l] === i) return t || l || 0; return !t && -1; }; }; }, function (t, e, i) { const o = i(55); const n = Math.min; t.exports = function (t) { return t > 0 ? n(o(t), 9007199254740991) : 0; }; }, function (t, e, i) { const o = i(55); const n = Math.max; const s = Math.min; t.exports = function (t, e) { return t = o(t), t < 0 ? n(t + e, 0) : s(t, e); }; }, function (t, e, i) { const o = i(18).document; t.exports = o && o.documentElement; }, function (t, e, i) { const o = i(55); const n = i(51); t.exports = function (t) { return function (e, i) { let s; let r; const a = String(n(e)); const h = o(i); const d = a.length; return h < 0 || h >= d ? t ? '' : void 0 : (s = a.charCodeAt(h), s < 55296 || s > 56319 || h + 1 === d || (r = a.charCodeAt(h + 1)) < 56320 || r > 57343 ? t ? a.charAt(h) : s : t ? a.slice(h, h + 2) : r - 56320 + (s - 55296 << 10) + 65536); }; }; }, function (t, e, i) { const o = i(27); const n = i(137); t.exports = i(7).getIterator = function (t) { const e = n(t); if (typeof e !== 'function') throw TypeError(`${t} is not iterable!`); return o(e.call(t)); }; }, function (t, e, i) { const o = i(86); const n = i(13)('iterator'); const s = i(31); t.exports = i(7).getIteratorMethod = function (t) { if (void 0 != t) return t[n] || t['@@iterator'] || s[o(t)]; }; }, function (t, e, i) { i(139); const o = i(7).Object; t.exports = function (t, e) { return o.create(t, e); }; }, function (t, e, i) { const o = i(17); o(o.S, 'Object', { create: i(54) }); }, function (t, e, i) { i(141), t.exports = i(7).Object.keys; }, function (t, e, i) { const o = i(41); const n = i(33); i(87)('keys', () => function (t) { return n(o(t)); }); }, function (t, e, i) { t.exports = { default: i(143), __esModule: !0 }; }, function (t, e, i) { i(60), i(49), t.exports = i(61).f('iterator'); }, function (t, e, i) { t.exports = { default: i(145), __esModule: !0 }; }, function (t, e, i) { i(146), i(151), i(152), i(153), t.exports = i(7).Symbol; }, function (t, e, i) {
      const o = i(18); const n = i(22); const s = i(21); const r = i(17); const a = i(83); const h = i(147).KEY; const d = i(28); const l = i(57); const u = i(59); const c = i(40); const p = i(13); const f = i(61); const m = i(62); const v = i(148); const g = i(149); const y = i(27); const b = i(25); const _ = i(53); const w = i(39); const x = i(54); const k = i(150); const D = i(89); const S = i(20); const C = i(33); const M = D.f; const O = S.f; const E = k.f; let T = o.Symbol; const P = o.JSON; const I = P && P.stringify; const N = 'prototype'; const R = p('_hidden'); const A = p('toPrimitive'); const z = {}.propertyIsEnumerable; const L = l('symbol-registry'); const F = l('symbols'); const B = l('op-symbols'); const j = Object[N]; const H = typeof T === 'function'; const W = o.QObject; let Y = !W || !W[N] || !W[N].findChild; const G = s && d(() => x(O({}, 'a', { get () { return O(this, "a", { value: 7 }).a } })).a != 7) ? function (t, e, i) { const o = M(j, e); o && delete j[e], O(t, e, i), o && t !== j && O(j, e, o); } : O; const V = function (t) { const e = F[t] = x(T[N]); return e._k = t, e; }; const U = H && typeof T.iterator === 'symbol' ? function (t) { return typeof t === 'symbol'; } : function (t) { return t instanceof T; }; var q = function (t, e, i) { return t === j && q(B, e, i), y(t), e = _(e, !0), y(i), n(F, e) ? (i.enumerable ? (n(t, R) && t[R][e] && (t[R][e] = !1), i = x(i, { enumerable: w(0, !1) })) : (n(t, R) || O(t, R, w(1, {})), t[R][e] = !0), G(t, e, i)) : O(t, e, i); }; const X = function (t, e) { y(t); let i; const o = v(e = b(e)); let n = 0; const s = o.length; while (s > n)q(t, i = o[n++], e[i]); return t; }; const Z = function (t, e) { return void 0 === e ? x(t) : X(x(t), e); }; const K = function (t) { const e = z.call(this, t = _(t, !0)); return !(this === j && n(F, t) && !n(B, t)) && (!(e || !n(this, t) || !n(F, t) || n(this, R) && this[R][t]) || e); }; const $ = function (t, e) { if (t = b(t), e = _(e, !0), t !== j || !n(F, e) || n(B, e)) { const i = M(t, e); return !i || !n(F, e) || n(t, R) && t[R][e] || (i.enumerable = !0), i; } }; const J = function (t) { let e; const i = E(b(t)); const o = []; let s = 0; while (i.length > s)n(F, e = i[s++]) || e == R || e == h || o.push(e); return o; }; const Q = function (t) { let e; const i = t === j; const o = E(i ? B : b(t)); const s = []; let r = 0; while (o.length > r)!n(F, e = o[r++]) || i && !n(j, e) || s.push(F[e]); return s; }; H || (T = function () { if (this instanceof T) throw TypeError('Symbol is not a constructor!'); const t = c(arguments.length > 0 ? arguments[0] : void 0); var e = function (i) { this === j && e.call(B, i), n(this, R) && n(this[R], t) && (this[R][t] = !1), G(this, t, w(1, i)); }; return s && Y && G(j, t, { configurable: !0, set: e }), V(t); }, a(T[N], 'toString', function () { return this._k; }), D.f = $, S.f = q, i(88).f = k.f = J, i(42).f = K, i(63).f = Q, s && !i(52) && a(j, 'propertyIsEnumerable', K, !0), f.f = function (t) { return V(p(t)); }), r(r.G + r.W + r.F * !H, { Symbol: T }); for (let tt = 'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'.split(','), et = 0; tt.length > et;)p(tt[et++]); for (let it = C(p.store), ot = 0; it.length > ot;)m(it[ot++]); r(r.S + r.F * !H, 'Symbol', {
        for(t) { return n(L, t += '') ? L[t] : L[t] = T(t); }, keyFor(t) { if (!U(t)) throw TypeError(`${t} is not a symbol!`); for (const e in L) if (L[e] === t) return e; }, useSetter() { Y = !0; }, useSimple() { Y = !1; },
      }), r(r.S + r.F * !H, 'Object', {
        create: Z, defineProperty: q, defineProperties: X, getOwnPropertyDescriptor: $, getOwnPropertyNames: J, getOwnPropertySymbols: Q,
      }), P && r(r.S + r.F * (!H || d(() => { const t = T(); return I([t]) != '[null]' || I({ a: t }) != '{}' || I(Object(t)) != '{}'; })), 'JSON', { stringify(t) { if (void 0 !== t && !U(t)) { let e; let i; const o = [t]; let n = 1; while (arguments.length > n)o.push(arguments[n++]); return e = o[1], typeof e === 'function' && (i = e), !i && g(e) || (e = function (t, e) { if (i && (e = i.call(this, t, e)), !U(e)) return e; }), o[1] = e, I.apply(P, o); } } }), T[N][A] || i(26)(T[N], A, T[N].valueOf), u(T, 'Symbol'), u(Math, 'Math', !0), u(o.JSON, 'JSON', !0);
    }, function (t, e, i) {
      const o = i(40)('meta'); const n = i(32); const s = i(22); const r = i(20).f; let a = 0; const h = Object.isExtensible || function () { return !0; }; const d = !i(28)(() => h(Object.preventExtensions({}))); const l = function (t) { r(t, o, { value: { i: `O${++a}`, w: {} } }); }; const u = function (t, e) { if (!n(t)) return typeof t === 'symbol' ? t : (typeof t === 'string' ? 'S' : 'P') + t; if (!s(t, o)) { if (!h(t)) return 'F'; if (!e) return 'E'; l(t); } return t[o].i; }; const c = function (t, e) { if (!s(t, o)) { if (!h(t)) return !0; if (!e) return !1; l(t); } return t[o].w; }; const p = function (t) { return d && f.NEED && h(t) && !s(t, o) && l(t), t; }; var f = t.exports = {
        KEY: o, NEED: !1, fastKey: u, getWeak: c, onFreeze: p,
      };
    }, function (t, e, i) { const o = i(33); const n = i(63); const s = i(42); t.exports = function (t) { const e = o(t); const i = n.f; if (i) { let r; const a = i(t); const h = s.f; let d = 0; while (a.length > d)h.call(t, r = a[d++]) && e.push(r); } return e; }; }, function (t, e, i) { const o = i(50); t.exports = Array.isArray || function (t) { return o(t) == 'Array'; }; }, function (t, e, i) { const o = i(25); const n = i(88).f; const s = {}.toString; const r = typeof window === 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : []; const a = function (t) { try { return n(t); } catch (e) { return r.slice(); } }; t.exports.f = function (t) { return r && s.call(t) == '[object Window]' ? a(t) : n(o(t)); }; }, function (t, e) {}, function (t, e, i) { i(62)('asyncIterator'); }, function (t, e, i) { i(62)('observable'); }, function (t, e, i) {
      (function (t) {
        (function (e, i) { t.exports = i(); }(0, () => {
          let e; let i; function o() { return e(...arguments); } function n(t) { e = t; } function s(t) { return t instanceof Array || Object.prototype.toString.call(t) === '[object Array]'; } function r(t) { return t != null && Object.prototype.toString.call(t) === '[object Object]'; } function a(t) { if (Object.getOwnPropertyNames) return Object.getOwnPropertyNames(t).length === 0; let e; for (e in t) if (t.hasOwnProperty(e)) return !1; return !0; } function h(t) { return void 0 === t; } function d(t) { return typeof t === 'number' || Object.prototype.toString.call(t) === '[object Number]'; } function l(t) { return t instanceof Date || Object.prototype.toString.call(t) === '[object Date]'; } function u(t, e) { let i; const o = []; for (i = 0; i < t.length; ++i)o.push(e(t[i], i)); return o; } function c(t, e) { return Object.prototype.hasOwnProperty.call(t, e); } function p(t, e) { for (const i in e)c(e, i) && (t[i] = e[i]); return c(e, 'toString') && (t.toString = e.toString), c(e, 'valueOf') && (t.valueOf = e.valueOf), t; } function f(t, e, i, o) { return Vi(t, e, i, o, !0).utc(); } function m() {
            return {
              empty: !1, unusedTokens: [], unusedInput: [], overflow: -2, charsLeftOver: 0, nullInput: !1, invalidMonth: null, invalidFormat: !1, userInvalidated: !1, iso: !1, parsedDateParts: [], meridiem: null, rfc2822: !1, weekdayMismatch: !1,
            };
          } function v(t) { return t._pf == null && (t._pf = m()), t._pf; } function g(t) { if (t._isValid == null) { const e = v(t); const o = i.call(e.parsedDateParts, (t) => t!=null); let n = !isNaN(t._d.getTime()) && e.overflow < 0 && !e.empty && !e.invalidMonth && !e.invalidWeekday && !e.weekdayMismatch && !e.nullInput && !e.invalidFormat && !e.userInvalidated && (!e.meridiem || e.meridiem && o); if (t._strict && (n = n && e.charsLeftOver === 0 && e.unusedTokens.length === 0 && void 0 === e.bigHour), Object.isFrozen != null && Object.isFrozen(t)) return n; t._isValid = n; } return t._isValid; } function y(t) { const e = f(NaN); return t != null ? p(v(e), t) : v(e).userInvalidated = !0, e; }i = Array.prototype.some ? Array.prototype.some : function (t) { for (let e = Object(this), i = e.length >>> 0, o = 0; o < i; o++) if (o in e && t.call(this, e[o], o, e)) return !0; return !1; }; const b = o.momentProperties = []; function _(t, e) { let i; let o; let n; if (h(e._isAMomentObject) || (t._isAMomentObject = e._isAMomentObject), h(e._i) || (t._i = e._i), h(e._f) || (t._f = e._f), h(e._l) || (t._l = e._l), h(e._strict) || (t._strict = e._strict), h(e._tzm) || (t._tzm = e._tzm), h(e._isUTC) || (t._isUTC = e._isUTC), h(e._offset) || (t._offset = e._offset), h(e._pf) || (t._pf = v(e)), h(e._locale) || (t._locale = e._locale), b.length > 0) for (i = 0; i < b.length; i++)o = b[i], n = e[o], h(n) || (t[o] = n); return t; } let w = !1; function x(t) { _(this, t), this._d = new Date(t._d != null ? t._d.getTime() : NaN), this.isValid() || (this._d = new Date(NaN)), !1 === w && (w = !0, o.updateOffset(this), w = !1); } function k(t) { return t instanceof x || t != null && t._isAMomentObject != null; } function D(t) { return t < 0 ? Math.ceil(t) || 0 : Math.floor(t); } function S(t) { const e = +t; let i = 0; return e !== 0 && isFinite(e) && (i = D(e)), i; } function C(t, e, i) { let o; const n = Math.min(t.length, e.length); const s = Math.abs(t.length - e.length); let r = 0; for (o = 0; o < n; o++)(i && t[o] !== e[o] || !i && S(t[o]) !== S(e[o])) && r++; return r + s; } function M(t) { !1 === o.suppressDeprecationWarnings && typeof console !== 'undefined' && console.warn && console.warn(`Deprecation warning: ${t}`); } function O(t, e) { let i = !0; return p(function () { if (o.deprecationHandler != null && o.deprecationHandler(null, t), i) { for (var n, s = [], r = 0; r < arguments.length; r++) { if (n = '', typeof arguments[r] === 'object') { for (const a in n += `\n[${r }] `, arguments[0])n += `${a}: ${arguments[0][a]}, `; n = n.slice(0, -2); } else n = arguments[r]; s.push(n); }M(`${t}\nArguments: ${Array.prototype.slice.call(s).join('')}\n${(new Error()).stack}`), i = !1; } return e.apply(this, arguments); }, e); } let E; const T = {}; function P(t, e) { o.deprecationHandler != null && o.deprecationHandler(t, e), T[t] || (M(e), T[t] = !0); } function I(t) { return t instanceof Function || Object.prototype.toString.call(t) === '[object Function]'; } function N(t) { let e; let i; for (i in t)e = t[i], I(e) ? this[i] = e : this[`_${i}`] = e; this._config = t, this._dayOfMonthOrdinalParseLenient = new RegExp(`${this._dayOfMonthOrdinalParse.source || this._ordinalParse.source}|${/\d{1,2}/.source}`); } function R(t, e) { let i; const o = p({}, t); for (i in e)c(e, i) && (r(t[i]) && r(e[i]) ? (o[i] = {}, p(o[i], t[i]), p(o[i], e[i])) : e[i] != null ? o[i] = e[i] : delete o[i]); for (i in t)c(t, i) && !c(e, i) && r(t[i]) && (o[i] = p({}, o[i])); return o; } function A(t) { t != null && this.set(t); }o.suppressDeprecationWarnings = !1, o.deprecationHandler = null, E = Object.keys ? Object.keys : function (t) { let e; const i = []; for (e in t)c(t, e) && i.push(e); return i; }; const z = {
            sameDay: '[Today at] LT', nextDay: '[Tomorrow at] LT', nextWeek: 'dddd [at] LT', lastDay: '[Yesterday at] LT', lastWeek: '[Last] dddd [at] LT', sameElse: 'L',
          }; function L(t, e, i) { const o = this._calendar[t] || this._calendar.sameElse; return I(o) ? o.call(e, i) : o; } const F = {
            LTS: 'h:mm:ss A', LT: 'h:mm A', L: 'MM/DD/YYYY', LL: 'MMMM D, YYYY', LLL: 'MMMM D, YYYY h:mm A', LLLL: 'dddd, MMMM D, YYYY h:mm A',
          }; function B(t) { const e = this._longDateFormat[t]; const i = this._longDateFormat[t.toUpperCase()]; return e || !i ? e : (this._longDateFormat[t] = i.replace(/MMMM|MM|DD|dddd/g, t => t.slice(1)), this._longDateFormat[t]); } const j = 'Invalid date'; function H() { return this._invalidDate; } const W = '%d'; const Y = /\d{1,2}/; function G(t) { return this._ordinal.replace('%d', t); } const V = {
            future: 'in %s', past: '%s ago', s: 'a few seconds', ss: '%d seconds', m: 'a minute', mm: '%d minutes', h: 'an hour', hh: '%d hours', d: 'a day', dd: '%d days', M: 'a month', MM: '%d months', y: 'a year', yy: '%d years',
          }; function U(t, e, i, o) { const n = this._relativeTime[i]; return I(n) ? n(t, e, i, o) : n.replace(/%d/i, t); } function q(t, e) { const i = this._relativeTime[t > 0 ? 'future' : 'past']; return I(i) ? i(e) : i.replace(/%s/i, e); } const X = {}; function Z(t, e) { const i = t.toLowerCase(); X[i] = X[`${i}s`] = X[e] = t; } function K(t) { return typeof t === 'string' ? X[t] || X[t.toLowerCase()] : void 0; } function $(t) { let e; let i; const o = {}; for (i in t)c(t, i) && (e = K(i), e && (o[e] = t[i])); return o; } const J = {}; function Q(t, e) { J[t] = e; } function tt(t) { const e = []; for (const i in t)e.push({ unit: i, priority: J[i] }); return e.sort((t, e) => t.priority - e.priority), e; } function et(t, e, i) { const o = `${Math.abs(t)}`; const n = e - o.length; const s = t >= 0; return (s ? i ? '+' : '' : '-') + Math.pow(10, Math.max(0, n)).toString().substr(1) + o; } const it = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g; const ot = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g; const nt = {}; const st = {}; function rt(t, e, i, o) { let n = o; typeof o === 'string' && (n = function () { return this[o](); }), t && (st[t] = n), e && (st[e[0]] = function () { return et(n.apply(this, arguments), e[1], e[2]); }), i && (st[i] = function () { return this.localeData().ordinal(n.apply(this, arguments), t); }); } function at(t) { return t.match(/\[[\s\S]/) ? t.replace(/^\[|\]$/g, '') : t.replace(/\\/g, ''); } function ht(t) { let e; let i; const o = t.match(it); for (e = 0, i = o.length; e < i; e++)st[o[e]] ? o[e] = st[o[e]] : o[e] = at(o[e]); return function (e) { let n; let s = ''; for (n = 0; n < i; n++)s += I(o[n]) ? o[n].call(e, t) : o[n]; return s; }; } function dt(t, e) { return t.isValid() ? (e = lt(e, t.localeData()), nt[e] = nt[e] || ht(e), nt[e](t)) : t.localeData().invalidDate(); } function lt(t, e) { let i = 5; function o(t) { return e.longDateFormat(t) || t; }ot.lastIndex = 0; while (i >= 0 && ot.test(t))t = t.replace(ot, o), ot.lastIndex = 0, i -= 1; return t; } const ut = /\d/; const ct = /\d\d/; const pt = /\d{3}/; const ft = /\d{4}/; const mt = /[+-]?\d{6}/; const vt = /\d\d?/; const gt = /\d\d\d\d?/; const yt = /\d\d\d\d\d\d?/; const bt = /\d{1,3}/; const _t = /\d{1,4}/; const wt = /[+-]?\d{1,6}/; const xt = /\d+/; const kt = /[+-]?\d+/; const Dt = /Z|[+-]\d\d:?\d\d/gi; const St = /Z|[+-]\d\d(?::?\d\d)?/gi; const Ct = /[+-]?\d+(\.\d{1,3})?/; const Mt = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i; const Ot = {}; function Et(t, e, i) { Ot[t] = I(e) ? e : function (t, o) { return t && i ? i : e; }; } function Tt(t, e) { return c(Ot, t) ? Ot[t](e._strict, e._locale) : new RegExp(Pt(t)); } function Pt(t) { return It(t.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, (t, e, i, o, n) => e || i || o || n)); } function It(t) { return t.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'); } const Nt = {}; function Rt(t, e) { let i; let o = e; for (typeof t === 'string' && (t = [t]), d(e) && (o = function (t, i) { i[e] = S(t); }), i = 0; i < t.length; i++)Nt[t[i]] = o; } function At(t, e) { Rt(t, (t, i, o, n) => { o._w = o._w || {}, e(t, o._w, o, n); }); } function zt(t, e, i) { e != null && c(Nt, t) && Nt[t](e, i._a, i, t); } const Lt = 0; const Ft = 1; const Bt = 2; const jt = 3; const Ht = 4; const Wt = 5; const Yt = 6; const Gt = 7; const Vt = 8; function Ut(t) { return qt(t) ? 366 : 365; } function qt(t) { return t % 4 === 0 && t % 100 !== 0 || t % 400 === 0; }rt('Y', 0, 0, function () { const t = this.year(); return t <= 9999 ? `${t}` : `+${t}`; }), rt(0, ['YY', 2], 0, function () { return this.year() % 100; }), rt(0, ['YYYY', 4], 0, 'year'), rt(0, ['YYYYY', 5], 0, 'year'), rt(0, ['YYYYYY', 6, !0], 0, 'year'), Z('year', 'y'), Q('year', 1), Et('Y', kt), Et('YY', vt, ct), Et('YYYY', _t, ft), Et('YYYYY', wt, mt), Et('YYYYYY', wt, mt), Rt(['YYYYY', 'YYYYYY'], Lt), Rt('YYYY', (t, e) => { e[Lt] = t.length === 2 ? o.parseTwoDigitYear(t) : S(t); }), Rt('YY', (t, e) => { e[Lt] = o.parseTwoDigitYear(t); }), Rt('Y', (t, e) => { e[Lt] = parseInt(t, 10); }), o.parseTwoDigitYear = function (t) { return S(t) + (S(t) > 68 ? 1900 : 2e3); }; let Xt; const Zt = $t('FullYear', !0); function Kt() { return qt(this.year()); } function $t(t, e) { return function (i) { return i != null ? (Qt(this, t, i), o.updateOffset(this, e), this) : Jt(this, t); }; } function Jt(t, e) { return t.isValid() ? t._d[`get${t._isUTC ? 'UTC' : ''}${e}`]() : NaN; } function Qt(t, e, i) { t.isValid() && !isNaN(i) && (e === 'FullYear' && qt(t.year()) ? t._d[`set${t._isUTC ? 'UTC' : ''}${e}`](i, t.month(), oe(i, t.month())) : t._d[`set${t._isUTC ? 'UTC' : ''}${e}`](i)); } function te(t) { return t = K(t), I(this[t]) ? this[t]() : this; } function ee(t, e) { if (typeof t === 'object') { t = $(t); for (let i = tt(t), o = 0; o < i.length; o++) this[i[o].unit](t[i[o].unit]); } else if (t = K(t), I(this[t])) return this[t](e); return this; } function ie(t, e) { return (t % e + e) % e; } function oe(t, e) { if (isNaN(t) || isNaN(e)) return NaN; const i = ie(e, 12); return t += (e - i) / 12, i === 1 ? qt(t) ? 29 : 28 : 31 - i % 7 % 2; }Xt = Array.prototype.indexOf ? Array.prototype.indexOf : function (t) { let e; for (e = 0; e < this.length; ++e) if (this[e] === t) return e; return -1; }, rt('M', ['MM', 2], 'Mo', function () { return this.month() + 1; }), rt('MMM', 0, 0, function (t) { return this.localeData().monthsShort(this, t); }), rt('MMMM', 0, 0, function (t) { return this.localeData().months(this, t); }), Z('month', 'M'), Q('month', 8), Et('M', vt), Et('MM', vt, ct), Et('MMM', (t, e) => e.monthsShortRegex(t)), Et('MMMM', (t, e) => e.monthsRegex(t)), Rt(['M', 'MM'], (t, e) => { e[Ft] = S(t) - 1; }), Rt(['MMM', 'MMMM'], (t, e, i, o) => { const n = i._locale.monthsParse(t, o, i._strict); n != null ? e[Ft] = n : v(i).invalidMonth = t; }); const ne = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/; const se = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'); function re(t, e) { return t ? s(this._months) ? this._months[t.month()] : this._months[(this._months.isFormat || ne).test(e) ? 'format' : 'standalone'][t.month()] : s(this._months) ? this._months : this._months.standalone; } const ae = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'); function he(t, e) { return t ? s(this._monthsShort) ? this._monthsShort[t.month()] : this._monthsShort[ne.test(e) ? 'format' : 'standalone'][t.month()] : s(this._monthsShort) ? this._monthsShort : this._monthsShort.standalone; } function de(t, e, i) { let o; let n; let s; const r = t.toLocaleLowerCase(); if (!this._monthsParse) for (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = [], o = 0; o < 12; ++o)s = f([2e3, o]), this._shortMonthsParse[o] = this.monthsShort(s, '').toLocaleLowerCase(), this._longMonthsParse[o] = this.months(s, '').toLocaleLowerCase(); return i ? e === 'MMM' ? (n = Xt.call(this._shortMonthsParse, r), n !== -1 ? n : null) : (n = Xt.call(this._longMonthsParse, r), n !== -1 ? n : null) : e === 'MMM' ? (n = Xt.call(this._shortMonthsParse, r), n !== -1 ? n : (n = Xt.call(this._longMonthsParse, r), n !== -1 ? n : null)) : (n = Xt.call(this._longMonthsParse, r), n !== -1 ? n : (n = Xt.call(this._shortMonthsParse, r), n !== -1 ? n : null)); } function le(t, e, i) { let o; let n; let s; if (this._monthsParseExact) return de.call(this, t, e, i); for (this._monthsParse || (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = []), o = 0; o < 12; o++) { if (n = f([2e3, o]), i && !this._longMonthsParse[o] && (this._longMonthsParse[o] = new RegExp(`^${this.months(n, '').replace('.', '')}$`, 'i'), this._shortMonthsParse[o] = new RegExp(`^${this.monthsShort(n, '').replace('.', '')}$`, 'i')), i || this._monthsParse[o] || (s = `^${this.months(n, '') }|^${this.monthsShort(n, '')}`, this._monthsParse[o] = new RegExp(s.replace('.', ''), 'i')), i && e === 'MMMM' && this._longMonthsParse[o].test(t)) return o; if (i && e === 'MMM' && this._shortMonthsParse[o].test(t)) return o; if (!i && this._monthsParse[o].test(t)) return o; } } function ue(t, e) { let i; if (!t.isValid()) return t; if (typeof e === 'string') if (/^\d+$/.test(e))e = S(e); else if (e = t.localeData().monthsParse(e), !d(e)) return t; return i = Math.min(t.date(), oe(t.year(), e)), t._d[`set${t._isUTC ? 'UTC' : ''}Month`](e, i), t; } function ce(t) { return t != null ? (ue(this, t), o.updateOffset(this, !0), this) : Jt(this, 'Month'); } function pe() { return oe(this.year(), this.month()); } const fe = Mt; function me(t) { return this._monthsParseExact ? (c(this, '_monthsRegex') || ye.call(this), t ? this._monthsShortStrictRegex : this._monthsShortRegex) : (c(this, '_monthsShortRegex') || (this._monthsShortRegex = fe), this._monthsShortStrictRegex && t ? this._monthsShortStrictRegex : this._monthsShortRegex); } const ve = Mt; function ge(t) { return this._monthsParseExact ? (c(this, '_monthsRegex') || ye.call(this), t ? this._monthsStrictRegex : this._monthsRegex) : (c(this, '_monthsRegex') || (this._monthsRegex = ve), this._monthsStrictRegex && t ? this._monthsStrictRegex : this._monthsRegex); } function ye() { function t(t, e) { return e.length - t.length; } let e; let i; const o = []; const n = []; const s = []; for (e = 0; e < 12; e++)i = f([2e3, e]), o.push(this.monthsShort(i, '')), n.push(this.months(i, '')), s.push(this.months(i, '')), s.push(this.monthsShort(i, '')); for (o.sort(t), n.sort(t), s.sort(t), e = 0; e < 12; e++)o[e] = It(o[e]), n[e] = It(n[e]); for (e = 0; e < 24; e++)s[e] = It(s[e]); this._monthsRegex = new RegExp(`^(${s.join('|')})`, 'i'), this._monthsShortRegex = this._monthsRegex, this._monthsStrictRegex = new RegExp(`^(${n.join('|')})`, 'i'), this._monthsShortStrictRegex = new RegExp(`^(${o.join('|')})`, 'i'); } function be(t, e, i, o, n, s, r) { const a = new Date(t, e, i, o, n, s, r); return t < 100 && t >= 0 && isFinite(a.getFullYear()) && a.setFullYear(t), a; } function _e(t) { const e = new Date(Date.UTC.apply(null, arguments)); return t < 100 && t >= 0 && isFinite(e.getUTCFullYear()) && e.setUTCFullYear(t), e; } function we(t, e, i) { const o = 7 + e - i; const n = (7 + _e(t, 0, o).getUTCDay() - e) % 7; return -n + o - 1; } function xe(t, e, i, o, n) { let s; let r; const a = (7 + i - o) % 7; const h = we(t, o, n); const d = 1 + 7 * (e - 1) + a + h; return d <= 0 ? (s = t - 1, r = Ut(s) + d) : d > Ut(t) ? (s = t + 1, r = d - Ut(t)) : (s = t, r = d), { year: s, dayOfYear: r }; } function ke(t, e, i) { let o; let n; const s = we(t.year(), e, i); const r = Math.floor((t.dayOfYear() - s - 1) / 7) + 1; return r < 1 ? (n = t.year() - 1, o = r + De(n, e, i)) : r > De(t.year(), e, i) ? (o = r - De(t.year(), e, i), n = t.year() + 1) : (n = t.year(), o = r), { week: o, year: n }; } function De(t, e, i) { const o = we(t, e, i); const n = we(t + 1, e, i); return (Ut(t) - o + n) / 7; } function Se(t) { return ke(t, this._week.dow, this._week.doy).week; }rt('w', ['ww', 2], 'wo', 'week'), rt('W', ['WW', 2], 'Wo', 'isoWeek'), Z('week', 'w'), Z('isoWeek', 'W'), Q('week', 5), Q('isoWeek', 5), Et('w', vt), Et('ww', vt, ct), Et('W', vt), Et('WW', vt, ct), At(['w', 'ww', 'W', 'WW'], (t, e, i, o) => { e[o.substr(0, 1)] = S(t); }); const Ce = { dow: 0, doy: 6 }; function Me() { return this._week.dow; } function Oe() { return this._week.doy; } function Ee(t) { const e = this.localeData().week(this); return t == null ? e : this.add(7 * (t - e), 'd'); } function Te(t) { const e = ke(this, 1, 4).week; return t == null ? e : this.add(7 * (t - e), 'd'); } function Pe(t, e) { return typeof t !== 'string' ? t : isNaN(t) ? (t = e.weekdaysParse(t), typeof t === 'number' ? t : null) : parseInt(t, 10); } function Ie(t, e) { return typeof t === 'string' ? e.weekdaysParse(t) % 7 || 7 : isNaN(t) ? null : t; }rt('d', 0, 'do', 'day'), rt('dd', 0, 0, function (t) { return this.localeData().weekdaysMin(this, t); }), rt('ddd', 0, 0, function (t) { return this.localeData().weekdaysShort(this, t); }), rt('dddd', 0, 0, function (t) { return this.localeData().weekdays(this, t); }), rt('e', 0, 0, 'weekday'), rt('E', 0, 0, 'isoWeekday'), Z('day', 'd'), Z('weekday', 'e'), Z('isoWeekday', 'E'), Q('day', 11), Q('weekday', 11), Q('isoWeekday', 11), Et('d', vt), Et('e', vt), Et('E', vt), Et('dd', (t, e) => e.weekdaysMinRegex(t)), Et('ddd', (t, e) => e.weekdaysShortRegex(t)), Et('dddd', (t, e) => e.weekdaysRegex(t)), At(['dd', 'ddd', 'dddd'], (t, e, i, o) => { const n = i._locale.weekdaysParse(t, o, i._strict); n != null ? e.d = n : v(i).invalidWeekday = t; }), At(['d', 'e', 'E'], (t, e, i, o) => { e[o] = S(t); }); const Ne = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'); function Re(t, e) { return t ? s(this._weekdays) ? this._weekdays[t.day()] : this._weekdays[this._weekdays.isFormat.test(e) ? 'format' : 'standalone'][t.day()] : s(this._weekdays) ? this._weekdays : this._weekdays.standalone; } const Ae = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'); function ze(t) { return t ? this._weekdaysShort[t.day()] : this._weekdaysShort; } const Le = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'); function Fe(t) { return t ? this._weekdaysMin[t.day()] : this._weekdaysMin; } function Be(t, e, i) { let o; let n; let s; const r = t.toLocaleLowerCase(); if (!this._weekdaysParse) for (this._weekdaysParse = [], this._shortWeekdaysParse = [], this._minWeekdaysParse = [], o = 0; o < 7; ++o)s = f([2e3, 1]).day(o), this._minWeekdaysParse[o] = this.weekdaysMin(s, '').toLocaleLowerCase(), this._shortWeekdaysParse[o] = this.weekdaysShort(s, '').toLocaleLowerCase(), this._weekdaysParse[o] = this.weekdays(s, '').toLocaleLowerCase(); return i ? e === 'dddd' ? (n = Xt.call(this._weekdaysParse, r), n !== -1 ? n : null) : e === 'ddd' ? (n = Xt.call(this._shortWeekdaysParse, r), n !== -1 ? n : null) : (n = Xt.call(this._minWeekdaysParse, r), n !== -1 ? n : null) : e === 'dddd' ? (n = Xt.call(this._weekdaysParse, r), n !== -1 ? n : (n = Xt.call(this._shortWeekdaysParse, r), n !== -1 ? n : (n = Xt.call(this._minWeekdaysParse, r), n !== -1 ? n : null))) : e === 'ddd' ? (n = Xt.call(this._shortWeekdaysParse, r), n !== -1 ? n : (n = Xt.call(this._weekdaysParse, r), n !== -1 ? n : (n = Xt.call(this._minWeekdaysParse, r), n !== -1 ? n : null))) : (n = Xt.call(this._minWeekdaysParse, r), n !== -1 ? n : (n = Xt.call(this._weekdaysParse, r), n !== -1 ? n : (n = Xt.call(this._shortWeekdaysParse, r), n !== -1 ? n : null))); } function je(t, e, i) { let o; let n; let s; if (this._weekdaysParseExact) return Be.call(this, t, e, i); for (this._weekdaysParse || (this._weekdaysParse = [], this._minWeekdaysParse = [], this._shortWeekdaysParse = [], this._fullWeekdaysParse = []), o = 0; o < 7; o++) { if (n = f([2e3, 1]).day(o), i && !this._fullWeekdaysParse[o] && (this._fullWeekdaysParse[o] = new RegExp(`^${this.weekdays(n, '').replace('.', '.?')}$`, 'i'), this._shortWeekdaysParse[o] = new RegExp(`^${this.weekdaysShort(n, '').replace('.', '.?')}$`, 'i'), this._minWeekdaysParse[o] = new RegExp(`^${this.weekdaysMin(n, '').replace('.', '.?')}$`, 'i')), this._weekdaysParse[o] || (s = `^${this.weekdays(n, '') }|^${this.weekdaysShort(n, '') }|^${this.weekdaysMin(n, '')}`, this._weekdaysParse[o] = new RegExp(s.replace('.', ''), 'i')), i && e === 'dddd' && this._fullWeekdaysParse[o].test(t)) return o; if (i && e === 'ddd' && this._shortWeekdaysParse[o].test(t)) return o; if (i && e === 'dd' && this._minWeekdaysParse[o].test(t)) return o; if (!i && this._weekdaysParse[o].test(t)) return o; } } function He(t) { if (!this.isValid()) return t != null ? this : NaN; const e = this._isUTC ? this._d.getUTCDay() : this._d.getDay(); return t != null ? (t = Pe(t, this.localeData()), this.add(t - e, 'd')) : e; } function We(t) { if (!this.isValid()) return t != null ? this : NaN; const e = (this.day() + 7 - this.localeData()._week.dow) % 7; return t == null ? e : this.add(t - e, 'd'); } function Ye(t) { if (!this.isValid()) return t != null ? this : NaN; if (t != null) { const e = Ie(t, this.localeData()); return this.day(this.day() % 7 ? e : e - 7); } return this.day() || 7; } const Ge = Mt; function Ve(t) { return this._weekdaysParseExact ? (c(this, '_weekdaysRegex') || Ke.call(this), t ? this._weekdaysStrictRegex : this._weekdaysRegex) : (c(this, '_weekdaysRegex') || (this._weekdaysRegex = Ge), this._weekdaysStrictRegex && t ? this._weekdaysStrictRegex : this._weekdaysRegex); } const Ue = Mt; function qe(t) { return this._weekdaysParseExact ? (c(this, '_weekdaysRegex') || Ke.call(this), t ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex) : (c(this, '_weekdaysShortRegex') || (this._weekdaysShortRegex = Ue), this._weekdaysShortStrictRegex && t ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex); } const Xe = Mt; function Ze(t) { return this._weekdaysParseExact ? (c(this, '_weekdaysRegex') || Ke.call(this), t ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex) : (c(this, '_weekdaysMinRegex') || (this._weekdaysMinRegex = Xe), this._weekdaysMinStrictRegex && t ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex); } function Ke() { function t(t, e) { return e.length - t.length; } let e; let i; let o; let n; let s; const r = []; const a = []; const h = []; const d = []; for (e = 0; e < 7; e++)i = f([2e3, 1]).day(e), o = this.weekdaysMin(i, ''), n = this.weekdaysShort(i, ''), s = this.weekdays(i, ''), r.push(o), a.push(n), h.push(s), d.push(o), d.push(n), d.push(s); for (r.sort(t), a.sort(t), h.sort(t), d.sort(t), e = 0; e < 7; e++)a[e] = It(a[e]), h[e] = It(h[e]), d[e] = It(d[e]); this._weekdaysRegex = new RegExp(`^(${d.join('|')})`, 'i'), this._weekdaysShortRegex = this._weekdaysRegex, this._weekdaysMinRegex = this._weekdaysRegex, this._weekdaysStrictRegex = new RegExp(`^(${h.join('|')})`, 'i'), this._weekdaysShortStrictRegex = new RegExp(`^(${a.join('|')})`, 'i'), this._weekdaysMinStrictRegex = new RegExp(`^(${r.join('|')})`, 'i'); } function $e() { return this.hours() % 12 || 12; } function Je() { return this.hours() || 24; } function Qe(t, e) { rt(t, 0, 0, function () { return this.localeData().meridiem(this.hours(), this.minutes(), e); }); } function ti(t, e) { return e._meridiemParse; } function ei(t) { return (`${t}`).toLowerCase().charAt(0) === 'p'; }rt('H', ['HH', 2], 0, 'hour'), rt('h', ['hh', 2], 0, $e), rt('k', ['kk', 2], 0, Je), rt('hmm', 0, 0, function () { return `${$e.apply(this) }${et(this.minutes(), 2)}`; }), rt('hmmss', 0, 0, function () { return `${$e.apply(this) }${et(this.minutes(), 2) }${et(this.seconds(), 2)}`; }), rt('Hmm', 0, 0, function () { return `${this.hours() }${et(this.minutes(), 2)}`; }), rt('Hmmss', 0, 0, function () { return `${this.hours() }${et(this.minutes(), 2) }${et(this.seconds(), 2)}`; }), Qe('a', !0), Qe('A', !1), Z('hour', 'h'), Q('hour', 13), Et('a', ti), Et('A', ti), Et('H', vt), Et('h', vt), Et('k', vt), Et('HH', vt, ct), Et('hh', vt, ct), Et('kk', vt, ct), Et('hmm', gt), Et('hmmss', yt), Et('Hmm', gt), Et('Hmmss', yt), Rt(['H', 'HH'], jt), Rt(['k', 'kk'], (t, e, i) => { const o = S(t); e[jt] = o === 24 ? 0 : o; }), Rt(['a', 'A'], (t, e, i) => { i._isPm = i._locale.isPM(t), i._meridiem = t; }), Rt(['h', 'hh'], (t, e, i) => { e[jt] = S(t), v(i).bigHour = !0; }), Rt('hmm', (t, e, i) => { const o = t.length - 2; e[jt] = S(t.substr(0, o)), e[Ht] = S(t.substr(o)), v(i).bigHour = !0; }), Rt('hmmss', (t, e, i) => { const o = t.length - 4; const n = t.length - 2; e[jt] = S(t.substr(0, o)), e[Ht] = S(t.substr(o, 2)), e[Wt] = S(t.substr(n)), v(i).bigHour = !0; }), Rt('Hmm', (t, e, i) => { const o = t.length - 2; e[jt] = S(t.substr(0, o)), e[Ht] = S(t.substr(o)); }), Rt('Hmmss', (t, e, i) => { const o = t.length - 4; const n = t.length - 2; e[jt] = S(t.substr(0, o)), e[Ht] = S(t.substr(o, 2)), e[Wt] = S(t.substr(n)); }); const ii = /[ap]\.?m?\.?/i; function oi(t, e, i) { return t > 11 ? i ? 'pm' : 'PM' : i ? 'am' : 'AM'; } let ni; const si = $t('Hours', !0); const ri = {
            calendar: z, longDateFormat: F, invalidDate: j, ordinal: W, dayOfMonthOrdinalParse: Y, relativeTime: V, months: se, monthsShort: ae, week: Ce, weekdays: Ne, weekdaysMin: Le, weekdaysShort: Ae, meridiemParse: ii, 
          }; const ai = {}; const hi = {}; function di(t) { return t ? t.toLowerCase().replace('_', '-') : t; } function li(t) { let e; let i; let o; let n; let s = 0; while (s < t.length) { n = di(t[s]).split('-'), e = n.length, i = di(t[s + 1]), i = i ? i.split('-') : null; while (e > 0) { if (o = ui(n.slice(0, e).join('-')), o) return o; if (i && i.length >= e && C(n, i, !0) >= e - 1) break; e--; }s++; } return null; } function ui(e) { let i = null; if (!ai[e] && typeof t !== 'undefined' && t && t.exports) try { i = ni._abbr; !(function () { const t = new Error('Cannot find module "./locale"'); throw t.code = 'MODULE_NOT_FOUND', t; }()), ci(i); } catch (o) {} return ai[e]; } function ci(t, e) { let i; return t && (i = h(e) ? mi(t) : pi(t, e), i && (ni = i)), ni._abbr; } function pi(t, e) { if (e !== null) { let i = ri; if (e.abbr = t, ai[t] != null)P('defineLocaleOverride', 'use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info.'), i = ai[t]._config; else if (e.parentLocale != null) { if (ai[e.parentLocale] == null) return hi[e.parentLocale] || (hi[e.parentLocale] = []), hi[e.parentLocale].push({ name: t, config: e }), null; i = ai[e.parentLocale]._config; } return ai[t] = new A(R(i, e)), hi[t] && hi[t].forEach((t) => { pi(t.name, t.config); }), ci(t), ai[t]; } return delete ai[t], null; } function fi(t, e) { if (e != null) { let i; let o = ri; ai[t] != null && (o = ai[t]._config), e = R(o, e), i = new A(e), i.parentLocale = ai[t], ai[t] = i, ci(t); } else ai[t] != null && (ai[t].parentLocale != null ? ai[t] = ai[t].parentLocale : ai[t] != null && delete ai[t]); return ai[t]; } function mi(t) { let e; if (t && t._locale && t._locale._abbr && (t = t._locale._abbr), !t) return ni; if (!s(t)) { if (e = ui(t), e) return e; t = [t]; } return li(t); } function vi() { return E(ai); } function gi(t) { let e; const i = t._a; return i && v(t).overflow === -2 && (e = i[Ft] < 0 || i[Ft] > 11 ? Ft : i[Bt] < 1 || i[Bt] > oe(i[Lt], i[Ft]) ? Bt : i[jt] < 0 || i[jt] > 24 || i[jt] === 24 && (i[Ht] !== 0 || i[Wt] !== 0 || i[Yt] !== 0) ? jt : i[Ht] < 0 || i[Ht] > 59 ? Ht : i[Wt] < 0 || i[Wt] > 59 ? Wt : i[Yt] < 0 || i[Yt] > 999 ? Yt : -1, v(t)._overflowDayOfYear && (e < Lt || e > Bt) && (e = Bt), v(t)._overflowWeeks && e === -1 && (e = Gt), v(t)._overflowWeekday && e === -1 && (e = Vt), v(t).overflow = e), t; } function yi(t, e, i) { return t != null ? t : e != null ? e : i; } function bi(t) { const e = new Date(o.now()); return t._useUTC ? [e.getUTCFullYear(), e.getUTCMonth(), e.getUTCDate()] : [e.getFullYear(), e.getMonth(), e.getDate()]; } function _i(t) { let e; let i; let o; let n; const s = []; if (!t._d) { for (o = bi(t), t._w && t._a[Bt] == null && t._a[Ft] == null && wi(t), t._dayOfYear != null && (n = yi(t._a[Lt], o[Lt]), (t._dayOfYear > Ut(n) || t._dayOfYear === 0) && (v(t)._overflowDayOfYear = !0), i = _e(n, 0, t._dayOfYear), t._a[Ft] = i.getUTCMonth(), t._a[Bt] = i.getUTCDate()), e = 0; e < 3 && t._a[e] == null; ++e)t._a[e] = s[e] = o[e]; for (;e < 7; e++)t._a[e] = s[e] = t._a[e] == null ? e === 2 ? 1 : 0 : t._a[e]; t._a[jt] === 24 && t._a[Ht] === 0 && t._a[Wt] === 0 && t._a[Yt] === 0 && (t._nextDay = !0, t._a[jt] = 0), t._d = (t._useUTC ? _e : be)(...s), t._tzm != null && t._d.setUTCMinutes(t._d.getUTCMinutes() - t._tzm), t._nextDay && (t._a[jt] = 24), t._w && typeof t._w.d !== 'undefined' && t._w.d !== t._d.getDay() && (v(t).weekdayMismatch = !0); } } function wi(t) { let e; let i; let o; let n; let s; let r; let a; let h; if (e = t._w, e.GG != null || e.W != null || e.E != null)s = 1, r = 4, i = yi(e.GG, t._a[Lt], ke(Ui(), 1, 4).year), o = yi(e.W, 1), n = yi(e.E, 1), (n < 1 || n > 7) && (h = !0); else { s = t._locale._week.dow, r = t._locale._week.doy; const d = ke(Ui(), s, r); i = yi(e.gg, t._a[Lt], d.year), o = yi(e.w, d.week), e.d != null ? (n = e.d, (n < 0 || n > 6) && (h = !0)) : e.e != null ? (n = e.e + s, (e.e < 0 || e.e > 6) && (h = !0)) : n = s; }o < 1 || o > De(i, s, r) ? v(t)._overflowWeeks = !0 : h != null ? v(t)._overflowWeekday = !0 : (a = xe(i, o, n, s, r), t._a[Lt] = a.year, t._dayOfYear = a.dayOfYear); } const xi = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/; const ki = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/; const Di = /Z|[+-]\d\d(?::?\d\d)?/; const Si = [['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/], ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/], ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/], ['GGGG-[W]WW', /\d{4}-W\d\d/, !1], ['YYYY-DDD', /\d{4}-\d{3}/], ['YYYY-MM', /\d{4}-\d\d/, !1], ['YYYYYYMMDD', /[+-]\d{10}/], ['YYYYMMDD', /\d{8}/], ['GGGG[W]WWE', /\d{4}W\d{3}/], ['GGGG[W]WW', /\d{4}W\d{2}/, !1], ['YYYYDDD', /\d{7}/]]; const Ci = [['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/], ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/], ['HH:mm:ss', /\d\d:\d\d:\d\d/], ['HH:mm', /\d\d:\d\d/], ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/], ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/], ['HHmmss', /\d\d\d\d\d\d/], ['HHmm', /\d\d\d\d/], ['HH', /\d\d/]]; const Mi = /^\/?Date\((\-?\d+)/i; function Oi(t) { let e; let i; let o; let n; let s; let r; const a = t._i; const h = xi.exec(a) || ki.exec(a); if (h) { for (v(t).iso = !0, e = 0, i = Si.length; e < i; e++) if (Si[e][1].exec(h[1])) { n = Si[e][0], o = !1 !== Si[e][2]; break; } if (n == null) return void (t._isValid = !1); if (h[3]) { for (e = 0, i = Ci.length; e < i; e++) if (Ci[e][1].exec(h[3])) { s = (h[2] || ' ') + Ci[e][0]; break; } if (s == null) return void (t._isValid = !1); } if (!o && s != null) return void (t._isValid = !1); if (h[4]) { if (!Di.exec(h[4])) return void (t._isValid = !1); r = 'Z'; }t._f = n + (s || '') + (r || ''), Fi(t); } else t._isValid = !1; } const Ei = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/; function Ti(t, e, i, o, n, s) { const r = [Pi(t), ae.indexOf(e), parseInt(i, 10), parseInt(o, 10), parseInt(n, 10)]; return s && r.push(parseInt(s, 10)), r; } function Pi(t) { const e = parseInt(t, 10); return e <= 49 ? 2e3 + e : e <= 999 ? 1900 + e : e; } function Ii(t) { return t.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').trim(); } function Ni(t, e, i) { if (t) { const o = Ae.indexOf(t); const n = new Date(e[0], e[1], e[2]).getDay(); if (o !== n) return v(i).weekdayMismatch = !0, i._isValid = !1, !1; } return !0; } const Ri = {
            UT: 0, GMT: 0, EDT: -240, EST: -300, CDT: -300, CST: -360, MDT: -360, MST: -420, PDT: -420, PST: -480,
          }; function Ai(t, e, i) { if (t) return Ri[t]; if (e) return 0; const o = parseInt(i, 10); const n = o % 100; const s = (o - n) / 100; return 60 * s + n; } function zi(t) { const e = Ei.exec(Ii(t._i)); if (e) { const i = Ti(e[4], e[3], e[2], e[5], e[6], e[7]); if (!Ni(e[1], i, t)) return; t._a = i, t._tzm = Ai(e[8], e[9], e[10]), t._d = _e(...t._a), t._d.setUTCMinutes(t._d.getUTCMinutes() - t._tzm), v(t).rfc2822 = !0; } else t._isValid = !1; } function Li(t) { const e = Mi.exec(t._i); e === null ? (Oi(t), !1 === t._isValid && (delete t._isValid, zi(t), !1 === t._isValid && (delete t._isValid, o.createFromInputFallback(t)))) : t._d = new Date(+e[1]); } function Fi(t) { if (t._f !== o.ISO_8601) if (t._f !== o.RFC_2822) { t._a = [], v(t).empty = !0; let e; let i; let n; let s; let r; let a = `${  t._i}`; const h = a.length; let d = 0; for (n = lt(t._f, t._locale).match(it) || [], e = 0; e < n.length; e++)s = n[e], i = (a.match(Tt(s, t)) || [])[0], i && (r = a.substr(0, a.indexOf(i)), r.length > 0 && v(t).unusedInput.push(r), a = a.slice(a.indexOf(i) + i.length), d += i.length), st[s] ? (i ? v(t).empty = !1 : v(t).unusedTokens.push(s), zt(s, i, t)) : t._strict && !i && v(t).unusedTokens.push(s); v(t).charsLeftOver = h - d, a.length > 0 && v(t).unusedInput.push(a), t._a[jt] <= 12 && !0 === v(t).bigHour && t._a[jt] > 0 && (v(t).bigHour = void 0), v(t).parsedDateParts = t._a.slice(0), v(t).meridiem = t._meridiem, t._a[jt] = Bi(t._locale, t._a[jt], t._meridiem), _i(t), gi(t); } else zi(t); else Oi(t); } function Bi(t, e, i) { let o; return i == null ? e : t.meridiemHour != null ? t.meridiemHour(e, i) : t.isPM != null ? (o = t.isPM(i), o && e < 12 && (e += 12), o || e !== 12 || (e = 0), e) : e; } function ji(t) { let e; let i; let o; let n; let s; if (t._f.length === 0) return v(t).invalidFormat = !0, void (t._d = new Date(NaN)); for (n = 0; n < t._f.length; n++)s = 0, e = _({}, t), t._useUTC != null && (e._useUTC = t._useUTC), e._f = t._f[n], Fi(e), g(e) && (s += v(e).charsLeftOver, s += 10 * v(e).unusedTokens.length, v(e).score = s, (o == null || s < o) && (o = s, i = e)); p(t, i || e); } function Hi(t) { if (!t._d) { const e = $(t._i); t._a = u([e.year, e.month, e.day || e.date, e.hour, e.minute, e.second, e.millisecond], t => t && parseInt(t, 10)), _i(t); } } function Wi(t) { const e = new x(gi(Yi(t))); return e._nextDay && (e.add(1, 'd'), e._nextDay = void 0), e; } function Yi(t) { let e = t._i; const i = t._f; return t._locale = t._locale || mi(t._l), e === null || void 0 === i && e === '' ? y({ nullInput: !0 }) : (typeof e === 'string' && (t._i = e = t._locale.preparse(e)), k(e) ? new x(gi(e)) : (l(e) ? t._d = e : s(i) ? ji(t) : i ? Fi(t) : Gi(t), g(t) || (t._d = null), t)); } function Gi(t) { const e = t._i; h(e) ? t._d = new Date(o.now()) : l(e) ? t._d = new Date(e.valueOf()) : typeof e === 'string' ? Li(t) : s(e) ? (t._a = u(e.slice(0), t => parseInt(t, 10)), _i(t)) : r(e) ? Hi(t) : d(e) ? t._d = new Date(e) : o.createFromInputFallback(t); } function Vi(t, e, i, o, n) { const h = {}; return !0 !== i && !1 !== i || (o = i, i = void 0), (r(t) && a(t) || s(t) && t.length === 0) && (t = void 0), h._isAMomentObject = !0, h._useUTC = h._isUTC = n, h._l = i, h._i = t, h._f = e, h._strict = o, Wi(h); } function Ui(t, e, i, o) { return Vi(t, e, i, o, !1); }o.createFromInputFallback = O('value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged and will be removed in an upcoming major release. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.', (t) => { t._d = new Date(t._i + (t._useUTC ? ' UTC' : '')); }), o.ISO_8601 = function () {}, o.RFC_2822 = function () {}; const qi = O('moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/', function () { const t = Ui(...arguments); return this.isValid() && t.isValid() ? t < this ? this : t : y(); }); const Xi = O('moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/', function () { const t = Ui(...arguments); return this.isValid() && t.isValid() ? t > this ? this : t : y(); }); function Zi(t, e) { let i; let o; if (e.length === 1 && s(e[0]) && (e = e[0]), !e.length) return Ui(); for (i = e[0], o = 1; o < e.length; ++o)e[o].isValid() && !e[o][t](i) || (i = e[o]); return i; } function Ki() { const t = [].slice.call(arguments, 0); return Zi('isBefore', t); } function $i() { const t = [].slice.call(arguments, 0); return Zi('isAfter', t); } const Ji = function () { return Date.now ? Date.now() : +new Date(); }; const Qi = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond']; function to(t) { for (const e in t) if (Xt.call(Qi, e) === -1 || t[e] != null && isNaN(t[e])) return !1; for (let i = !1, o = 0; o < Qi.length; ++o) if (t[Qi[o]]) { if (i) return !1; parseFloat(t[Qi[o]]) !== S(t[Qi[o]]) && (i = !0); } return !0; } function eo() { return this._isValid; } function io() { return So(NaN); } function oo(t) { const e = $(t); const i = e.year || 0; const o = e.quarter || 0; const n = e.month || 0; const s = e.week || 0; const r = e.day || 0; const a = e.hour || 0; const h = e.minute || 0; const d = e.second || 0; const l = e.millisecond || 0; this._isValid = to(e), this._milliseconds = +l + 1e3 * d + 6e4 * h + 1e3 * a * 60 * 60, this._days = +r + 7 * s, this._months = +n + 3 * o + 12 * i, this._data = {}, this._locale = mi(), this._bubble(); } function no(t) { return t instanceof oo; } function so(t) { return t < 0 ? -1 * Math.round(-1 * t) : Math.round(t); } function ro(t, e) { rt(t, 0, 0, function () { let t = this.utcOffset(); let i = '+'; return t < 0 && (t = -t, i = '-'), i + et(~~(t / 60), 2) + e + et(~~t % 60, 2); }); }ro('Z', ':'), ro('ZZ', ''), Et('Z', St), Et('ZZ', St), Rt(['Z', 'ZZ'], (t, e, i) => { i._useUTC = !0, i._tzm = ho(St, t); }); const ao = /([\+\-]|\d\d)/gi; function ho(t, e) { const i = (e || '').match(t); if (i === null) return null; const o = i[i.length - 1] || []; const n = (`${o}`).match(ao) || ['-', 0, 0]; const s = 60 * n[1] + S(n[2]); return s === 0 ? 0 : n[0] === '+' ? s : -s; } function lo(t, e) { let i; let n; return e._isUTC ? (i = e.clone(), n = (k(t) || l(t) ? t.valueOf() : Ui(t).valueOf()) - i.valueOf(), i._d.setTime(i._d.valueOf() + n), o.updateOffset(i, !1), i) : Ui(t).local(); } function uo(t) { return 15 * -Math.round(t._d.getTimezoneOffset() / 15); } function co(t, e, i) { let n; const s = this._offset || 0; if (!this.isValid()) return t != null ? this : NaN; if (t != null) { if (typeof t === 'string') { if (t = ho(St, t), t === null) return this; } else Math.abs(t) < 16 && !i && (t *= 60); return !this._isUTC && e && (n = uo(this)), this._offset = t, this._isUTC = !0, n != null && this.add(n, 'm'), s !== t && (!e || this._changeInProgress ? To(this, So(t - s, 'm'), 1, !1) : this._changeInProgress || (this._changeInProgress = !0, o.updateOffset(this, !0), this._changeInProgress = null)), this; } return this._isUTC ? s : uo(this); } function po(t, e) { return t != null ? (typeof t !== 'string' && (t = -t), this.utcOffset(t, e), this) : -this.utcOffset(); } function fo(t) { return this.utcOffset(0, t); } function mo(t) { return this._isUTC && (this.utcOffset(0, t), this._isUTC = !1, t && this.subtract(uo(this), 'm')), this; } function vo() { if (this._tzm != null) this.utcOffset(this._tzm, !1, !0); else if (typeof this._i === 'string') { const t = ho(Dt, this._i); t != null ? this.utcOffset(t) : this.utcOffset(0, !0); } return this; } function go(t) { return !!this.isValid() && (t = t ? Ui(t).utcOffset() : 0, (this.utcOffset() - t) % 60 === 0); } function yo() { return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset(); } function bo() { if (!h(this._isDSTShifted)) return this._isDSTShifted; let t = {}; if (_(t, this), t = Yi(t), t._a) { const e = t._isUTC ? f(t._a) : Ui(t._a); this._isDSTShifted = this.isValid() && C(t._a, e.toArray()) > 0; } else this._isDSTShifted = !1; return this._isDSTShifted; } function _o() { return !!this.isValid() && !this._isUTC; } function wo() { return !!this.isValid() && this._isUTC; } function xo() { return !!this.isValid() && (this._isUTC && this._offset === 0); }o.updateOffset = function () {}; const ko = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/; const Do = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/; function So(t, e) {
            let i; let o; let n; let s = t; let r = null; return no(t) ? s = { ms: t._milliseconds, d: t._days, M: t._months } : d(t) ? (s = {}, e ? s[e] = t : s.milliseconds = t) : (r = ko.exec(t)) ? (i = r[1] === '-' ? -1 : 1, s = {
              y: 0, d: S(r[Bt]) * i, h: S(r[jt]) * i, m: S(r[Ht]) * i, s: S(r[Wt]) * i, ms: S(so(1e3 * r[Yt])) * i,
            }) : (r = Do.exec(t)) ? (i = r[1] === '-' ? -1 : (r[1], 1), s = {
              y: Co(r[2], i), M: Co(r[3], i), w: Co(r[4], i), d: Co(r[5], i), h: Co(r[6], i), m: Co(r[7], i), s: Co(r[8], i),
            }) : s == null ? s = {} : typeof s === 'object' && ('from' in s || 'to' in s) && (n = Oo(Ui(s.from), Ui(s.to)), s = {}, s.ms = n.milliseconds, s.M = n.months), o = new oo(s), no(t) && c(t, '_locale') && (o._locale = t._locale), o;
          } function Co(t, e) { const i = t && parseFloat(t.replace(',', '.')); return (isNaN(i) ? 0 : i) * e; } function Mo(t, e) { const i = { milliseconds: 0, months: 0 }; return i.months = e.month() - t.month() + 12 * (e.year() - t.year()), t.clone().add(i.months, 'M').isAfter(e) && --i.months, i.milliseconds = +e - +t.clone().add(i.months, 'M'), i; } function Oo(t, e) { let i; return t.isValid() && e.isValid() ? (e = lo(e, t), t.isBefore(e) ? i = Mo(t, e) : (i = Mo(e, t), i.milliseconds = -i.milliseconds, i.months = -i.months), i) : { milliseconds: 0, months: 0 }; } function Eo(t, e) { return function (i, o) { let n; let s; return o === null || isNaN(+o) || (P(e, `moment().${e }(period, number) is deprecated. Please use moment().${e }(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.`), s = i, i = o, o = s), i = typeof i === 'string' ? +i : i, n = So(i, o), To(this, n, t), this; }; } function To(t, e, i, n) { const s = e._milliseconds; const r = so(e._days); const a = so(e._months); t.isValid() && (n = n == null || n, a && ue(t, Jt(t, 'Month') + a * i), r && Qt(t, 'Date', Jt(t, 'Date') + r * i), s && t._d.setTime(t._d.valueOf() + s * i), n && o.updateOffset(t, r || a)); }So.fn = oo.prototype, So.invalid = io; const Po = Eo(1, 'add'); const Io = Eo(-1, 'subtract'); function No(t, e) { const i = t.diff(e, 'days', !0); return i < -6 ? 'sameElse' : i < -1 ? 'lastWeek' : i < 0 ? 'lastDay' : i < 1 ? 'sameDay' : i < 2 ? 'nextDay' : i < 7 ? 'nextWeek' : 'sameElse'; } function Ro(t, e) { const i = t || Ui(); const n = lo(i, this).startOf('day'); const s = o.calendarFormat(this, n) || 'sameElse'; const r = e && (I(e[s]) ? e[s].call(this, i) : e[s]); return this.format(r || this.localeData().calendar(s, this, Ui(i))); } function Ao() { return new x(this); } function zo(t, e) { const i = k(t) ? t : Ui(t); return !(!this.isValid() || !i.isValid()) && (e = K(h(e) ? 'millisecond' : e), e === 'millisecond' ? this.valueOf() > i.valueOf() : i.valueOf() < this.clone().startOf(e).valueOf()); } function Lo(t, e) { const i = k(t) ? t : Ui(t); return !(!this.isValid() || !i.isValid()) && (e = K(h(e) ? 'millisecond' : e), e === 'millisecond' ? this.valueOf() < i.valueOf() : this.clone().endOf(e).valueOf() < i.valueOf()); } function Fo(t, e, i, o) { return o = o || '()', (o[0] === '(' ? this.isAfter(t, i) : !this.isBefore(t, i)) && (o[1] === ')' ? this.isBefore(e, i) : !this.isAfter(e, i)); } function Bo(t, e) { let i; const o = k(t) ? t : Ui(t); return !(!this.isValid() || !o.isValid()) && (e = K(e || 'millisecond'), e === 'millisecond' ? this.valueOf() === o.valueOf() : (i = o.valueOf(), this.clone().startOf(e).valueOf() <= i && i <= this.clone().endOf(e).valueOf())); } function jo(t, e) { return this.isSame(t, e) || this.isAfter(t, e); } function Ho(t, e) { return this.isSame(t, e) || this.isBefore(t, e); } function Wo(t, e, i) { let o; let n; let s; if (!this.isValid()) return NaN; if (o = lo(t, this), !o.isValid()) return NaN; switch (n = 6e4 * (o.utcOffset() - this.utcOffset()), e = K(e), e) { case 'year': s = Yo(this, o) / 12; break; case 'month': s = Yo(this, o); break; case 'quarter': s = Yo(this, o) / 3; break; case 'second': s = (this - o) / 1e3; break; case 'minute': s = (this - o) / 6e4; break; case 'hour': s = (this - o) / 36e5; break; case 'day': s = (this - o - n) / 864e5; break; case 'week': s = (this - o - n) / 6048e5; break; default: s = this - o; } return i ? s : D(s); } function Yo(t, e) { let i; let o; const n = 12 * (e.year() - t.year()) + (e.month() - t.month()); const s = t.clone().add(n, 'months'); return e - s < 0 ? (i = t.clone().add(n - 1, 'months'), o = (e - s) / (s - i)) : (i = t.clone().add(n + 1, 'months'), o = (e - s) / (i - s)), -(n + o) || 0; } function Go() { return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ'); } function Vo() { if (!this.isValid()) return null; const t = this.clone().utc(); return t.year() < 0 || t.year() > 9999 ? dt(t, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]') : I(Date.prototype.toISOString) ? this.toDate().toISOString() : dt(t, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]'); } function Uo() { if (!this.isValid()) return `moment.invalid(/* ${this._i } */)`; let t = 'moment'; let e = ''; this.isLocal() || (t = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone', e = 'Z'); const i = `[${t }("]`; const o = this.year() >= 0 && this.year() <= 9999 ? 'YYYY' : 'YYYYYY'; const n = '-MM-DD[T]HH:mm:ss.SSS'; const s = `${e}[")]`; return this.format(i + o + n + s); } function qo(t) { t || (t = this.isUtc() ? o.defaultFormatUtc : o.defaultFormat); const e = dt(this, t); return this.localeData().postformat(e); } function Xo(t, e) { return this.isValid() && (k(t) && t.isValid() || Ui(t).isValid()) ? So({ to: this, from: t }).locale(this.locale()).humanize(!e) : this.localeData().invalidDate(); } function Zo(t) { return this.from(Ui(), t); } function Ko(t, e) { return this.isValid() && (k(t) && t.isValid() || Ui(t).isValid()) ? So({ from: this, to: t }).locale(this.locale()).humanize(!e) : this.localeData().invalidDate(); } function $o(t) { return this.to(Ui(), t); } function Jo(t) { let e; return void 0 === t ? this._locale._abbr : (e = mi(t), e != null && (this._locale = e), this); }o.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ', o.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]'; const Qo = O('moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.', function (t) { return void 0 === t ? this.localeData() : this.locale(t); }); function tn() { return this._locale; } function en(t) { switch (t = K(t), t) { case 'year': this.month(0); case 'quarter': case 'month': this.date(1); case 'week': case 'isoWeek': case 'day': case 'date': this.hours(0); case 'hour': this.minutes(0); case 'minute': this.seconds(0); case 'second': this.milliseconds(0); } return t === 'week' && this.weekday(0), t === 'isoWeek' && this.isoWeekday(1), t === 'quarter' && this.month(3 * Math.floor(this.month() / 3)), this; } function on(t) { return t = K(t), void 0 === t || t === 'millisecond' ? this : (t === 'date' && (t = 'day'), this.startOf(t).add(1, t === 'isoWeek' ? 'week' : t).subtract(1, 'ms')); } function nn() { return this._d.valueOf() - 6e4 * (this._offset || 0); } function sn() { return Math.floor(this.valueOf() / 1e3); } function rn() { return new Date(this.valueOf()); } function an() { const t = this; return [t.year(), t.month(), t.date(), t.hour(), t.minute(), t.second(), t.millisecond()]; } function hn() {
            const t = this; return {
              years: t.year(), months: t.month(), date: t.date(), hours: t.hours(), minutes: t.minutes(), seconds: t.seconds(), milliseconds: t.milliseconds(),
            };
          } function dn() { return this.isValid() ? this.toISOString() : null; } function ln() { return g(this); } function un() { return p({}, v(this)); } function cn() { return v(this).overflow; } function pn() {
            return {
              input: this._i, format: this._f, locale: this._locale, isUTC: this._isUTC, strict: this._strict,
            };
          } function fn(t, e) { rt(0, [t, t.length], 0, e); } function mn(t) { return bn.call(this, t, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy); } function vn(t) { return bn.call(this, t, this.isoWeek(), this.isoWeekday(), 1, 4); } function gn() { return De(this.year(), 1, 4); } function yn() { const t = this.localeData()._week; return De(this.year(), t.dow, t.doy); } function bn(t, e, i, o, n) { let s; return t == null ? ke(this, o, n).year : (s = De(t, o, n), e > s && (e = s), _n.call(this, t, e, i, o, n)); } function _n(t, e, i, o, n) { const s = xe(t, e, i, o, n); const r = _e(s.year, 0, s.dayOfYear); return this.year(r.getUTCFullYear()), this.month(r.getUTCMonth()), this.date(r.getUTCDate()), this; } function wn(t) { return t == null ? Math.ceil((this.month() + 1) / 3) : this.month(3 * (t - 1) + this.month() % 3); }rt(0, ['gg', 2], 0, function () { return this.weekYear() % 100; }), rt(0, ['GG', 2], 0, function () { return this.isoWeekYear() % 100; }), fn('gggg', 'weekYear'), fn('ggggg', 'weekYear'), fn('GGGG', 'isoWeekYear'), fn('GGGGG', 'isoWeekYear'), Z('weekYear', 'gg'), Z('isoWeekYear', 'GG'), Q('weekYear', 1), Q('isoWeekYear', 1), Et('G', kt), Et('g', kt), Et('GG', vt, ct), Et('gg', vt, ct), Et('GGGG', _t, ft), Et('gggg', _t, ft), Et('GGGGG', wt, mt), Et('ggggg', wt, mt), At(['gggg', 'ggggg', 'GGGG', 'GGGGG'], (t, e, i, o) => { e[o.substr(0, 2)] = S(t); }), At(['gg', 'GG'], (t, e, i, n) => { e[n] = o.parseTwoDigitYear(t); }), rt('Q', 0, 'Qo', 'quarter'), Z('quarter', 'Q'), Q('quarter', 7), Et('Q', ut), Rt('Q', (t, e) => { e[Ft] = 3 * (S(t) - 1); }), rt('D', ['DD', 2], 'Do', 'date'), Z('date', 'D'), Q('date', 9), Et('D', vt), Et('DD', vt, ct), Et('Do', (t, e) => (t ? e._dayOfMonthOrdinalParse || e._ordinalParse:e._dayOfMonthOrdinalParseLenient)), Rt(['D', 'DD'], Bt), Rt('Do', (t, e) => { e[Bt] = S(t.match(vt)[0], 10); }); const xn = $t('Date', !0); function kn(t) { const e = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1; return t == null ? e : this.add(t - e, 'd'); }rt('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear'), Z('dayOfYear', 'DDD'), Q('dayOfYear', 4), Et('DDD', bt), Et('DDDD', pt), Rt(['DDD', 'DDDD'], (t, e, i) => { i._dayOfYear = S(t); }), rt('m', ['mm', 2], 0, 'minute'), Z('minute', 'm'), Q('minute', 14), Et('m', vt), Et('mm', vt, ct), Rt(['m', 'mm'], Ht); const Dn = $t('Minutes', !1); rt('s', ['ss', 2], 0, 'second'), Z('second', 's'), Q('second', 15), Et('s', vt), Et('ss', vt, ct), Rt(['s', 'ss'], Wt); let Sn; const Cn = $t('Seconds', !1); for (rt('S', 0, 0, function () { return ~~(this.millisecond() / 100); }), rt(0, ['SS', 2], 0, function () { return ~~(this.millisecond() / 10); }), rt(0, ['SSS', 3], 0, 'millisecond'), rt(0, ['SSSS', 4], 0, function () { return 10 * this.millisecond(); }), rt(0, ['SSSSS', 5], 0, function () { return 100 * this.millisecond(); }), rt(0, ['SSSSSS', 6], 0, function () { return 1e3 * this.millisecond(); }), rt(0, ['SSSSSSS', 7], 0, function () { return 1e4 * this.millisecond(); }), rt(0, ['SSSSSSSS', 8], 0, function () { return 1e5 * this.millisecond(); }), rt(0, ['SSSSSSSSS', 9], 0, function () { return 1e6 * this.millisecond(); }), Z('millisecond', 'ms'), Q('millisecond', 16), Et('S', bt, ut), Et('SS', bt, ct), Et('SSS', bt, pt), Sn = 'SSSS'; Sn.length <= 9; Sn += 'S')Et(Sn, xt); function Mn(t, e) { e[Yt] = S(1e3 * (`0.${t}`)); } for (Sn = 'S'; Sn.length <= 9; Sn += 'S')Rt(Sn, Mn); const On = $t('Milliseconds', !1); function En() { return this._isUTC ? 'UTC' : ''; } function Tn() { return this._isUTC ? 'Coordinated Universal Time' : ''; }rt('z', 0, 0, 'zoneAbbr'), rt('zz', 0, 0, 'zoneName'); const Pn = x.prototype; function In(t) { return Ui(1e3 * t); } function Nn() { return Ui(...arguments).parseZone(); } function Rn(t) { return t; }Pn.add = Po, Pn.calendar = Ro, Pn.clone = Ao, Pn.diff = Wo, Pn.endOf = on, Pn.format = qo, Pn.from = Xo, Pn.fromNow = Zo, Pn.to = Ko, Pn.toNow = $o, Pn.get = te, Pn.invalidAt = cn, Pn.isAfter = zo, Pn.isBefore = Lo, Pn.isBetween = Fo, Pn.isSame = Bo, Pn.isSameOrAfter = jo, Pn.isSameOrBefore = Ho, Pn.isValid = ln, Pn.lang = Qo, Pn.locale = Jo, Pn.localeData = tn, Pn.max = Xi, Pn.min = qi, Pn.parsingFlags = un, Pn.set = ee, Pn.startOf = en, Pn.subtract = Io, Pn.toArray = an, Pn.toObject = hn, Pn.toDate = rn, Pn.toISOString = Vo, Pn.inspect = Uo, Pn.toJSON = dn, Pn.toString = Go, Pn.unix = sn, Pn.valueOf = nn, Pn.creationData = pn, Pn.year = Zt, Pn.isLeapYear = Kt, Pn.weekYear = mn, Pn.isoWeekYear = vn, Pn.quarter = Pn.quarters = wn, Pn.month = ce, Pn.daysInMonth = pe, Pn.week = Pn.weeks = Ee, Pn.isoWeek = Pn.isoWeeks = Te, Pn.weeksInYear = yn, Pn.isoWeeksInYear = gn, Pn.date = xn, Pn.day = Pn.days = He, Pn.weekday = We, Pn.isoWeekday = Ye, Pn.dayOfYear = kn, Pn.hour = Pn.hours = si, Pn.minute = Pn.minutes = Dn, Pn.second = Pn.seconds = Cn, Pn.millisecond = Pn.milliseconds = On, Pn.utcOffset = co, Pn.utc = fo, Pn.local = mo, Pn.parseZone = vo, Pn.hasAlignedHourOffset = go, Pn.isDST = yo, Pn.isLocal = _o, Pn.isUtcOffset = wo, Pn.isUtc = xo, Pn.isUTC = xo, Pn.zoneAbbr = En, Pn.zoneName = Tn, Pn.dates = O('dates accessor is deprecated. Use date instead.', xn), Pn.months = O('months accessor is deprecated. Use month instead', ce), Pn.years = O('years accessor is deprecated. Use year instead', Zt), Pn.zone = O('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', po), Pn.isDSTShifted = O('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', bo); const An = A.prototype; function zn(t, e, i, o) { const n = mi(); const s = f().set(o, e); return n[i](s, t); } function Ln(t, e, i) { if (d(t) && (e = t, t = void 0), t = t || '', e != null) return zn(t, e, i, 'month'); let o; const n = []; for (o = 0; o < 12; o++)n[o] = zn(t, o, i, 'month'); return n; } function Fn(t, e, i, o) { typeof t === 'boolean' ? (d(e) && (i = e, e = void 0), e = e || '') : (e = t, i = e, t = !1, d(e) && (i = e, e = void 0), e = e || ''); let n; const s = mi(); const r = t ? s._week.dow : 0; if (i != null) return zn(e, (i + r) % 7, o, 'day'); const a = []; for (n = 0; n < 7; n++)a[n] = zn(e, (n + r) % 7, o, 'day'); return a; } function Bn(t, e) { return Ln(t, e, 'months'); } function jn(t, e) { return Ln(t, e, 'monthsShort'); } function Hn(t, e, i) { return Fn(t, e, i, 'weekdays'); } function Wn(t, e, i) { return Fn(t, e, i, 'weekdaysShort'); } function Yn(t, e, i) { return Fn(t, e, i, 'weekdaysMin'); }An.calendar = L, An.longDateFormat = B, An.invalidDate = H, An.ordinal = G, An.preparse = Rn, An.postformat = Rn, An.relativeTime = U, An.pastFuture = q, An.set = N, An.months = re, An.monthsShort = he, An.monthsParse = le, An.monthsRegex = ge, An.monthsShortRegex = me, An.week = Se, An.firstDayOfYear = Oe, An.firstDayOfWeek = Me, An.weekdays = Re, An.weekdaysMin = Fe, An.weekdaysShort = ze, An.weekdaysParse = je, An.weekdaysRegex = Ve, An.weekdaysShortRegex = qe, An.weekdaysMinRegex = Ze, An.isPM = ei, An.meridiem = oi, ci('en', { dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/, ordinal(t) { const e = t % 10; const i = S(t % 100 / 10) === 1 ? 'th' : e === 1 ? 'st' : e === 2 ? 'nd' : e === 3 ? 'rd' : 'th'; return t + i; } }), o.lang = O('moment.lang is deprecated. Use moment.locale instead.', ci), o.langData = O('moment.langData is deprecated. Use moment.localeData instead.', mi); const Gn = Math.abs; function Vn() { const t = this._data; return this._milliseconds = Gn(this._milliseconds), this._days = Gn(this._days), this._months = Gn(this._months), t.milliseconds = Gn(t.milliseconds), t.seconds = Gn(t.seconds), t.minutes = Gn(t.minutes), t.hours = Gn(t.hours), t.months = Gn(t.months), t.years = Gn(t.years), this; } function Un(t, e, i, o) { const n = So(e, i); return t._milliseconds += o * n._milliseconds, t._days += o * n._days, t._months += o * n._months, t._bubble(); } function qn(t, e) { return Un(this, t, e, 1); } function Xn(t, e) { return Un(this, t, e, -1); } function Zn(t) { return t < 0 ? Math.floor(t) : Math.ceil(t); } function Kn() { let t; let e; let i; let o; let n; let s = this._milliseconds; let r = this._days; let a = this._months; const h = this._data; return s >= 0 && r >= 0 && a >= 0 || s <= 0 && r <= 0 && a <= 0 || (s += 864e5 * Zn(Jn(a) + r), r = 0, a = 0), h.milliseconds = s % 1e3, t = D(s / 1e3), h.seconds = t % 60, e = D(t / 60), h.minutes = e % 60, i = D(e / 60), h.hours = i % 24, r += D(i / 24), n = D($n(r)), a += n, r -= Zn(Jn(n)), o = D(a / 12), a %= 12, h.days = r, h.months = a, h.years = o, this; } function $n(t) { return 4800 * t / 146097; } function Jn(t) { return 146097 * t / 4800; } function Qn(t) { if (!this.isValid()) return NaN; let e; let i; const o = this._milliseconds; if (t = K(t), t === 'month' || t === 'year') return e = this._days + o / 864e5, i = this._months + $n(e), t === 'month' ? i : i / 12; switch (e = this._days + Math.round(Jn(this._months)), t) { case 'week': return e / 7 + o / 6048e5; case 'day': return e + o / 864e5; case 'hour': return 24 * e + o / 36e5; case 'minute': return 1440 * e + o / 6e4; case 'second': return 86400 * e + o / 1e3; case 'millisecond': return Math.floor(864e5 * e) + o; default: throw new Error(`Unknown unit ${t}`); } } function ts() { return this.isValid() ? this._milliseconds + 864e5 * this._days + this._months % 12 * 2592e6 + 31536e6 * S(this._months / 12) : NaN; } function es(t) { return function () { return this.as(t); }; } const is = es('ms'); const os = es('s'); const ns = es('m'); const ss = es('h'); const rs = es('d'); const as = es('w'); const hs = es('M'); const ds = es('y'); function ls() { return So(this); } function us(t) { return t = K(t), this.isValid() ? this[`${t}s`]() : NaN; } function cs(t) { return function () { return this.isValid() ? this._data[t] : NaN; }; } const ps = cs('milliseconds'); const fs = cs('seconds'); const ms = cs('minutes'); const vs = cs('hours'); const gs = cs('days'); const ys = cs('months'); const bs = cs('years'); function _s() { return D(this.days() / 7); } let ws = Math.round; const xs = {
            ss: 44, s: 45, m: 45, h: 22, d: 26, M: 11,
          }; function ks(t, e, i, o, n) { return n.relativeTime(e || 1, !!i, t, o); } function Ds(t, e, i) { const o = So(t).abs(); const n = ws(o.as('s')); const s = ws(o.as('m')); const r = ws(o.as('h')); const a = ws(o.as('d')); const h = ws(o.as('M')); const d = ws(o.as('y')); const l = n <= xs.ss && ['s', n] || n < xs.s && ['ss', n] || s <= 1 && ['m'] || s < xs.m && ['mm', s] || r <= 1 && ['h'] || r < xs.h && ['hh', r] || a <= 1 && ['d'] || a < xs.d && ['dd', a] || h <= 1 && ['M'] || h < xs.M && ['MM', h] || d <= 1 && ['y'] || ['yy', d]; return l[2] = e, l[3] = +t > 0, l[4] = i, ks(...l); } function Ss(t) { return void 0 === t ? ws : typeof t === 'function' && (ws = t, !0); } function Cs(t, e) { return void 0 !== xs[t] && (void 0 === e ? xs[t] : (xs[t] = e, t === 's' && (xs.ss = e - 1), !0)); } function Ms(t) { if (!this.isValid()) return this.localeData().invalidDate(); const e = this.localeData(); let i = Ds(this, !t, e); return t && (i = e.pastFuture(+this, i)), e.postformat(i); } const Os = Math.abs; function Es(t) { return (t > 0) - (t < 0) || +t; } function Ts() {
            if (!this.isValid()) return this.localeData().invalidDate(); let t; let e; let i; let o = Os(this._milliseconds) / 1e3; const n = Os(this._days); let s = Os(this._months); t = D(o / 60), e = D(t / 60), o %= 60, t %= 60, i = D(s / 12), s %= 12; const r = i; const a = s; const h = n; const d = e; const l = t; const u = o ? o.toFixed(3).replace(/\.?0+$/, '') : ''; const c = this.asSeconds(); if (!c) return 'P0D'; const p = c < 0 ? '-' : ''; const f = Es(this._months) !== Es(c) ? '-' : ''; const m = Es(this._days) !== Es(c) ? '-' : ''; const 
              v = Es(this._milliseconds) !== Es(c) ? '-' : ''; return `${p}P${r ? `${f + r }Y` : ''}${a ? `${f + a }M` : ''}${h ? `${m + h }D` : ''}${d || l || u ? 'T' : ''}${d ? `${v + d }H` : ''}${l ? `${v + l }M` : ''}${u ? `${v + u }S` : ''}`;
          } const Ps = oo.prototype; return Ps.isValid = eo, Ps.abs = Vn, Ps.add = qn, Ps.subtract = Xn, Ps.as = Qn, Ps.asMilliseconds = is, Ps.asSeconds = os, Ps.asMinutes = ns, Ps.asHours = ss, Ps.asDays = rs, Ps.asWeeks = as, Ps.asMonths = hs, Ps.asYears = ds, Ps.valueOf = ts, Ps._bubble = Kn, Ps.clone = ls, Ps.get = us, Ps.milliseconds = ps, Ps.seconds = fs, Ps.minutes = ms, Ps.hours = vs, Ps.days = gs, Ps.weeks = _s, Ps.months = ys, Ps.years = bs, Ps.humanize = Ms, Ps.toISOString = Ts, Ps.toString = Ts, Ps.toJSON = Ts, Ps.locale = Jo, Ps.localeData = tn, Ps.toIsoString = O('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', Ts), Ps.lang = Qo, rt('X', 0, 0, 'unix'), rt('x', 0, 0, 'valueOf'), Et('x', kt), Et('X', Ct), Rt('X', (t, e, i) => { i._d = new Date(1e3 * parseFloat(t, 10)); }), Rt('x', (t, e, i) => { i._d = new Date(S(t)); }), o.version = '2.19.1', n(Ui), o.fn = Pn, o.min = Ki, o.max = $i, o.now = Ji, o.utc = f, o.unix = In, o.months = Bn, o.isDate = l, o.locale = ci, o.invalid = y, o.duration = So, o.isMoment = k, o.weekdays = Hn, o.parseZone = Nn, o.localeData = mi, o.isDuration = no, o.monthsShort = jn, o.weekdaysMin = Yn, o.defineLocale = pi, o.updateLocale = fi, o.locales = vi, o.weekdaysShort = Wn, o.normalizeUnits = K, o.relativeTimeRounding = Ss, o.relativeTimeThreshold = Cs, o.calendarFormat = No, o.prototype = Pn, o;
        }));
      }).call(e, i(155)(t));
    }, function (t, e) { t.exports = function (t) { return t.webpackPolyfill || (t.deprecate = function () {}, t.paths = [], t.children || (t.children = []), Object.defineProperty(t, 'loaded', { enumerable: !0, get() { return t.l; } }), Object.defineProperty(t, 'id', { enumerable: !0, get() { return t.i; } }), t.webpackPolyfill = 1), t; }; }, function (t, e) { function i(t) { throw new Error(`Cannot find module '${t}'.`); }i.keys = function () { return []; }, i.resolve = i, t.exports = i, i.id = 156; }, function (t, e, i) { (function (e) { let i; const o = typeof window !== 'undefined' ? window : typeof e !== 'undefined' ? e : null; if (o && o.crypto && crypto.getRandomValues) { const n = new Uint8Array(16); i = function () { return crypto.getRandomValues(n), n; }; } if (!i) { const s = new Array(16); i = function () { for (var t, e = 0; e < 16; e++)(3 & e) === 0 && (t = 4294967296 * Math.random()), s[e] = t >>> ((3 & e) << 3) & 255; return s; }; } for (var r = [], a = {}, h = 0; h < 256; h++)r[h] = (h + 256).toString(16).substr(1), a[r[h]] = h; function d(t, e, i) { const o = e && i || 0; let n = 0; e = e || [], t.toLowerCase().replace(/[0-9a-f]{2}/g, (t) => { n < 16 && (e[o + n++] = a[t]); }); while (n < 16)e[o + n++] = 0; return e; } function l(t, e) { let i = e || 0; const o = r; return `${o[t[i++]] + o[t[i++]] + o[t[i++]] + o[t[i++]]}-${o[t[i++]]}${o[t[i++]]}-${o[t[i++]]}${o[t[i++]]}-${o[t[i++]]}${o[t[i++]]}-${o[t[i++]]}${o[t[i++]]}${o[t[i++]]}${o[t[i++]]}${o[t[i++]]}${o[t[i++]]}`; } const u = i(); const c = [1 | u[0], u[1], u[2], u[3], u[4], u[5]]; let p = 16383 & (u[6] << 8 | u[7]); let f = 0; let m = 0; function v(t, e, i) { let o = e && i || 0; const n = e || []; t = t || {}; let s = void 0 !== t.clockseq ? t.clockseq : p; let r = void 0 !== t.msecs ? t.msecs : (new Date()).getTime(); let a = void 0 !== t.nsecs ? t.nsecs : m + 1; const h = r - f + (a - m) / 1e4; if (h < 0 && void 0 === t.clockseq && (s = s + 1 & 16383), (h < 0 || r > f) && void 0 === t.nsecs && (a = 0), a >= 1e4) throw new Error("uuid.v1(): Can't create more than 10M uuids/sec"); f = r, m = a, p = s, r += 122192928e5; const d = (1e4 * (268435455 & r) + a) % 4294967296; n[o++] = d >>> 24 & 255, n[o++] = d >>> 16 & 255, n[o++] = d >>> 8 & 255, n[o++] = 255 & d; const u = r / 4294967296 * 1e4 & 268435455; n[o++] = u >>> 8 & 255, n[o++] = 255 & u, n[o++] = u >>> 24 & 15 | 16, n[o++] = u >>> 16 & 255, n[o++] = s >>> 8 | 128, n[o++] = 255 & s; for (let v = t.node || c, g = 0; g < 6; g++)n[o + g] = v[g]; return e || l(n); } function g(t, e, o) { const n = e && o || 0; typeof t === 'string' && (e = t == 'binary' ? new Array(16) : null, t = null), t = t || {}; const s = t.random || (t.rng || i)(); if (s[6] = 15 & s[6] | 64, s[8] = 63 & s[8] | 128, e) for (let r = 0; r < 16; r++)e[n + r] = s[r]; return e || l(s); } const y = g; y.v1 = v, y.v4 = g, y.parse = d, y.unparse = l, t.exports = y; }).call(e, i(158)); }, function (t, e) { let i; i = (function () { return this; }()); try { i = i || Function('return this')() || (0, eval)('this'); } catch (o) { typeof window === 'object' && (i = window); }t.exports = i; }, function (t, e, i) {
      e.util = i(2), e.DOMutil = i(14), e.DataSet = i(11), e.DataView = i(12), e.Queue = i(43), e.Graph3d = i(161), e.graph3d = {
        Camera: i(95), Filter: i(96), Point2d: i(91), Point3d: i(34), Slider: i(92), StepNumber: i(93),
      }, e.moment = i(9), e.Hammer = i(10), e.keycharm = i(35);
    }, function (t, e, i) { const o = i(7); const n = o.JSON || (o.JSON = { stringify: JSON.stringify }); t.exports = function (t) { return n.stringify(...arguments); }; }, function (t, e, i) {
      const o = i(90); const n = s(o); function s(t) { return t && t.__esModule ? t : { default: t }; } const r = i(44); const a = i(2); const h = i(34); const d = i(91); const l = i(92); const u = i(93); const c = i(94); const p = i(15).default; const f = i(15); const m = f.printStyle; const v = i(172); const g = v.allOptions; const y = i(173); _.STYLE = c.STYLE; const b = void 0; function _(t, e, i) { if (!(this instanceof _)) throw new SyntaxError('Constructor must be called with the new operator'); this.containerElement = t, this.dataGroup = new y(), this.dataPoints = null, this.create(), c.setDefaults(_.DEFAULTS, this), this.colX = void 0, this.colY = void 0, this.colZ = void 0, this.colValue = void 0, this.setOptions(i), this.setData(e); } function w(t) { return 'clientX' in t ? t.clientX : t.targetTouches[0] && t.targetTouches[0].clientX || 0; } function x(t) { return 'clientY' in t ? t.clientY : t.targetTouches[0] && t.targetTouches[0].clientY || 0; }_.DEFAULTS = {
        width: '400px',
        height: '400px',
        filterLabel: 'time',
        legendLabel: 'value',
        xLabel: 'x',
        yLabel: 'y',
        zLabel: 'z',
        xValueLabel(t) { return t; },
        yValueLabel(t) { return t; },
        zValueLabel(t) { return t; },
        showXAxis: !0,
        showYAxis: !0,
        showZAxis: !0,
        showGrid: !0,
        showPerspective: !0,
        showShadow: !1,
        keepAspectRatio: !0,
        verticalRatio: 0.5,
        dotSizeRatio: 0.02,
        dotSizeMinFraction: 0.5,
        dotSizeMaxFraction: 2.5,
        showAnimationControls: b,
        animationInterval: 1e3,
        animationPreload: !1,
        animationAutoStart: b,
        axisColor: '#4D4D4D',
        gridColor: '#D3D3D3',
        xCenter: '55%',
        yCenter: '50%',
        style: _.STYLE.DOT,
        tooltip: !1,
        tooltipStyle: {
          content: {
            padding: '10px', border: '1px solid #4d4d4d', color: '#1a1a1a', background: 'rgba(255,255,255,0.7)', borderRadius: '2px', boxShadow: '5px 5px 10px rgba(128,128,128,0.5)',
          },
          line: { height: '40px', width: '0', borderLeft: '1px solid #4d4d4d' },
          dot: {
            height: '0', width: '0', border: '5px solid #4d4d4d', borderRadius: '5px',
          },
        },
        dataColor: { fill: '#7DC1FF', stroke: '#3267D2', strokeWidth: 1 },
        cameraPosition: { horizontal: 1, vertical: 0.5, distance: 1.7 },
        showLegend: b,
        backgroundColor: b,
        xBarWidth: b,
        yBarWidth: b,
        valueMin: b,
        valueMax: b,
        xMin: b,
        xMax: b,
        xStep: b,
        yMin: b,
        yMax: b,
        yStep: b,
        zMin: b,
        zMax: b,
        zStep: b,
      }, r(_.prototype), _.prototype._setScale = function () { this.scale = new h(1 / this.xRange.range(), 1 / this.yRange.range(), 1 / this.zRange.range()), this.keepAspectRatio && (this.scale.x < this.scale.y ? this.scale.y = this.scale.x : this.scale.x = this.scale.y), this.scale.z *= this.verticalRatio, void 0 !== this.valueRange && (this.scale.value = 1 / this.valueRange.range()); const t = this.xRange.center() * this.scale.x; const e = this.yRange.center() * this.scale.y; const i = this.zRange.center() * this.scale.z; this.camera.setArmLocation(t, e, i); }, _.prototype._convert3Dto2D = function (t) { const e = this._convertPointToTranslation(t); return this._convertTranslationToScreen(e); }, _.prototype._convertPointToTranslation = function (t) { const e = this.camera.getCameraLocation(); const i = this.camera.getCameraRotation(); const o = t.x * this.scale.x; const n = t.y * this.scale.y; const s = t.z * this.scale.z; const r = e.x; const a = e.y; const d = e.z; const l = Math.sin(i.x); const u = Math.cos(i.x); const c = Math.sin(i.y); const p = Math.cos(i.y); const f = Math.sin(i.z); const m = Math.cos(i.z); const v = p * (f * (n - a) + m * (o - r)) - c * (s - d); const g = l * (p * (s - d) + c * (f * (n - a) + m * (o - r))) + u * (m * (n - a) - f * (o - r)); const y = u * (p * (s - d) + c * (f * (n - a) + m * (o - r))) - l * (m * (n - a) - f * (o - r)); return new h(v, g, y); }, _.prototype._convertTranslationToScreen = function (t) { let e; let i; const o = this.eye.x; const n = this.eye.y; const s = this.eye.z; const r = t.x; const a = t.y; const h = t.z; return this.showPerspective ? (e = s / h * (r - o), i = s / h * (a - n)) : (e = r * (-s / this.camera.getArmLength()), i = a * (-s / this.camera.getArmLength())), new d(this.currentXCenter + e * this.frame.canvas.clientWidth, this.currentYCenter - i * this.frame.canvas.clientWidth); }, _.prototype._calcTranslations = function (t) { for (let e = 0; e < t.length; e++) { const i = t[e]; i.trans = this._convertPointToTranslation(i.point), i.screen = this._convertTranslationToScreen(i.trans); const o = this._convertPointToTranslation(i.bottom); i.dist = this.showPerspective ? o.length() : -o.z; } const n = function (t, e) { return e.dist - t.dist; }; t.sort(n); }, _.prototype._initializeRanges = function () { const t = this.dataGroup; this.xRange = t.xRange, this.yRange = t.yRange, this.zRange = t.zRange, this.valueRange = t.valueRange, this.xStep = t.xStep, this.yStep = t.yStep, this.zStep = t.zStep, this.xBarWidth = t.xBarWidth, this.yBarWidth = t.yBarWidth, this.colX = t.colX, this.colY = t.colY, this.colZ = t.colZ, this.colValue = t.colValue, this._setScale(); }, _.prototype.getDataPoints = function (t) { for (var e = [], i = 0; i < t.length; i++) { const o = new h(); o.x = t[i][this.colX] || 0, o.y = t[i][this.colY] || 0, o.z = t[i][this.colZ] || 0, o.data = t[i], void 0 !== this.colValue && (o.value = t[i][this.colValue] || 0); const n = {}; n.point = o, n.bottom = new h(o.x, o.y, this.zRange.min), n.trans = void 0, n.screen = void 0, e.push(n); } return e; }, _.prototype._getDataPoints = function (t) { let e; let i; let o; let n; let s = []; if (this.style === _.STYLE.GRID || this.style === _.STYLE.SURFACE) { const r = this.dataGroup.getDistinctValues(this.colX, t); const a = this.dataGroup.getDistinctValues(this.colY, t); s = this.getDataPoints(t); const h = []; for (o = 0; o < s.length; o++) { n = s[o]; const d = r.indexOf(n.point.x); const l = a.indexOf(n.point.y); void 0 === h[d] && (h[d] = []), h[d][l] = n; } for (e = 0; e < h.length; e++) for (i = 0; i < h[e].length; i++)h[e][i] && (h[e][i].pointRight = e < h.length - 1 ? h[e + 1][i] : void 0, h[e][i].pointTop = i < h[e].length - 1 ? h[e][i + 1] : void 0, h[e][i].pointCross = e < h.length - 1 && i < h[e].length - 1 ? h[e + 1][i + 1] : void 0); } else if (this._checkValueField(t), s = this.getDataPoints(t), this.style === _.STYLE.LINE) for (o = 0; o < s.length; o++)o > 0 && (s[o - 1].pointNext = s[o]); return s; }, _.prototype.create = function () { while (this.containerElement.hasChildNodes()) this.containerElement.removeChild(this.containerElement.firstChild); this.frame = document.createElement('div'), this.frame.style.position = 'relative', this.frame.style.overflow = 'hidden', this.frame.canvas = document.createElement('canvas'), this.frame.canvas.style.position = 'relative', this.frame.appendChild(this.frame.canvas); const t = document.createElement('DIV'); t.style.color = 'red', t.style.fontWeight = 'bold', t.style.padding = '10px', t.innerHTML = 'Error: your browser does not support HTML canvas', this.frame.canvas.appendChild(t), this.frame.filter = document.createElement('div'), this.frame.filter.style.position = 'absolute', this.frame.filter.style.bottom = '0px', this.frame.filter.style.left = '0px', this.frame.filter.style.width = '100%', this.frame.appendChild(this.frame.filter); const e = this; const i = function (t) { e._onMouseDown(t); }; const o = function (t) { e._onTouchStart(t); }; const n = function (t) { e._onWheel(t); }; const s = function (t) { e._onTooltip(t); }; const r = function (t) { e._onClick(t); }; a.addEventListener(this.frame.canvas, 'mousedown', i), a.addEventListener(this.frame.canvas, 'touchstart', o), a.addEventListener(this.frame.canvas, 'mousewheel', n), a.addEventListener(this.frame.canvas, 'mousemove', s), a.addEventListener(this.frame.canvas, 'click', r), this.containerElement.appendChild(this.frame); }, _.prototype._setSize = function (t, e) { this.frame.style.width = t, this.frame.style.height = e, this._resizeCanvas(); }, _.prototype._resizeCanvas = function () { this.frame.canvas.style.width = '100%', this.frame.canvas.style.height = '100%', this.frame.canvas.width = this.frame.canvas.clientWidth, this.frame.canvas.height = this.frame.canvas.clientHeight, this.frame.filter.style.width = `${this.frame.canvas.clientWidth - 20}px`; }, _.prototype.animationStart = function () { if (this.animationAutoStart && this.dataGroup.dataFilter) { if (!this.frame.filter || !this.frame.filter.slider) throw new Error('No animation available'); this.frame.filter.slider.play(); } }, _.prototype.animationStop = function () { this.frame.filter && this.frame.filter.slider && this.frame.filter.slider.stop(); }, _.prototype._resizeCenter = function () { this.xCenter.charAt(this.xCenter.length - 1) === '%' ? this.currentXCenter = parseFloat(this.xCenter) / 100 * this.frame.canvas.clientWidth : this.currentXCenter = parseFloat(this.xCenter), this.yCenter.charAt(this.yCenter.length - 1) === '%' ? this.currentYCenter = parseFloat(this.yCenter) / 100 * (this.frame.canvas.clientHeight - this.frame.filter.clientHeight) : this.currentYCenter = parseFloat(this.yCenter); }, _.prototype.getCameraPosition = function () { const t = this.camera.getArmRotation(); return t.distance = this.camera.getArmLength(), t; }, _.prototype._readData = function (t) { this.dataPoints = this.dataGroup.initializeData(this, t, this.style), this._initializeRanges(), this._redrawFilter(); }, _.prototype.setData = function (t) { void 0 !== t && t !== null && (this._readData(t), this.redraw(), this.animationStart()); }, _.prototype.setOptions = function (t) { if (void 0 !== t) { const e = p.validate(t, g); !0 === e && console.log('%cErrors have been found in the supplied options object.', m), this.animationStop(), c.setOptions(t, this), this.setPointDrawingMethod(), this._setSize(this.width, this.height), this.setData(this.dataGroup.getDataTable()), this.animationStart(); } }, _.prototype.setPointDrawingMethod = function () { let t = void 0; switch (this.style) { case _.STYLE.BAR: t = _.prototype._redrawBarGraphPoint; break; case _.STYLE.BARCOLOR: t = _.prototype._redrawBarColorGraphPoint; break; case _.STYLE.BARSIZE: t = _.prototype._redrawBarSizeGraphPoint; break; case _.STYLE.DOT: t = _.prototype._redrawDotGraphPoint; break; case _.STYLE.DOTLINE: t = _.prototype._redrawDotLineGraphPoint; break; case _.STYLE.DOTCOLOR: t = _.prototype._redrawDotColorGraphPoint; break; case _.STYLE.DOTSIZE: t = _.prototype._redrawDotSizeGraphPoint; break; case _.STYLE.SURFACE: t = _.prototype._redrawSurfaceGraphPoint; break; case _.STYLE.GRID: t = _.prototype._redrawGridGraphPoint; break; case _.STYLE.LINE: t = _.prototype._redrawLineGraphPoint; break; default: throw new Error(`Can not determine point drawing method for graph style '${this.style}'`); } this._pointDrawingMethod = t; }, _.prototype.redraw = function () { if (void 0 === this.dataPoints) throw new Error('Graph data not initialized'); this._resizeCanvas(), this._resizeCenter(), this._redrawSlider(), this._redrawClear(), this._redrawAxis(), this._redrawDataGraph(), this._redrawInfo(), this._redrawLegend(); }, _.prototype._getContext = function () { const t = this.frame.canvas; const e = t.getContext('2d'); return e.lineJoin = 'round', e.lineCap = 'round', e; }, _.prototype._redrawClear = function () { const t = this.frame.canvas; const e = t.getContext('2d'); e.clearRect(0, 0, t.width, t.height); }, _.prototype._dotSize = function () { return this.frame.clientWidth * this.dotSizeRatio; }, _.prototype._getLegendWidth = function () { let t; if (this.style === _.STYLE.DOTSIZE) { const e = this._dotSize(); t = e * this.dotSizeMaxFraction; } else t = this.style === _.STYLE.BARSIZE ? this.xBarWidth : 20; return t; }, _.prototype._redrawLegend = function () { if (!0 === this.showLegend && this.style !== _.STYLE.LINE && this.style !== _.STYLE.BARSIZE) { const t = this.style === _.STYLE.BARSIZE || this.style === _.STYLE.DOTSIZE; const e = this.style === _.STYLE.DOTSIZE || this.style === _.STYLE.DOTCOLOR || this.style === _.STYLE.BARCOLOR; const i = Math.max(0.25 * this.frame.clientHeight, 100); const o = this.margin; const n = this._getLegendWidth(); const s = this.frame.clientWidth - this.margin; const r = s - n; const a = o + i; const h = this._getContext(); if (h.lineWidth = 1, h.font = '14px arial', !1 === t) { var l; const c = 0; const p = i; for (l = c; l < p; l++) { const f = (l - c) / (p - c); const m = 240 * f; const v = this._hsv2rgb(m, 1, 1); h.strokeStyle = v, h.beginPath(), h.moveTo(r, o + l), h.lineTo(s, o + l), h.stroke(); }h.strokeStyle = this.axisColor, h.strokeRect(r, o, n, i); } else { let g; this.style === _.STYLE.DOTSIZE ? g = n * (this.dotSizeMinFraction / this.dotSizeMaxFraction) : (this.style, _.STYLE.BARSIZE), h.strokeStyle = this.axisColor, h.fillStyle = this.dataColor.fill, h.beginPath(), h.moveTo(r, o), h.lineTo(s, o), h.lineTo(r + g, a), h.lineTo(r, a), h.closePath(), h.fill(), h.stroke(); } let y; let b; const w = 5; const x = e ? this.valueRange.min : this.zRange.min; const k = e ? this.valueRange.max : this.zRange.max; const D = new u(x, k, (k - x) / 5, !0); D.start(!0); while (!D.end())l = a - (D.getCurrent() - x) / (k - x) * i, y = new d(r - w, l), b = new d(r, l), this._line(h, y, b), h.textAlign = 'right', h.textBaseline = 'middle', h.fillStyle = this.axisColor, h.fillText(D.getCurrent(), r - 2 * w, l), D.next(); h.textAlign = 'right', h.textBaseline = 'top'; const S = this.legendLabel; h.fillText(S, s, a + this.margin); } }, _.prototype._redrawFilter = function () { const t = this.dataGroup.dataFilter; const e = this.frame.filter; if (e.innerHTML = '', t) { const i = { visible: this.showAnimationControls }; const o = new l(e, i); e.slider = o, e.style.padding = '10px', o.setValues(t.values), o.setPlayInterval(this.animationInterval); const n = this; const s = function () { const t = n.dataGroup.dataFilter; const e = o.getIndex(); t.selectValue(e), n.dataPoints = t._getDataPoints(), n.redraw(); }; o.setOnChangeCallback(s); } else e.slider = void 0; }, _.prototype._redrawSlider = function () { void 0 !== this.frame.filter.slider && this.frame.filter.slider.redraw(); }, _.prototype._redrawInfo = function () { const t = this.dataGroup.getInfo(); if (void 0 !== t) { const e = this._getContext(); e.font = '14px arial', e.lineStyle = 'gray', e.fillStyle = 'gray', e.textAlign = 'left', e.textBaseline = 'top'; const i = this.margin; const o = this.margin; e.fillText(t, i, o); } }, _.prototype._line = function (t, e, i, o) { void 0 !== o && (t.strokeStyle = o), t.beginPath(), t.moveTo(e.x, e.y), t.lineTo(i.x, i.y), t.stroke(); }, _.prototype.drawAxisLabelX = function (t, e, i, o, n) { void 0 === n && (n = 0); const s = this._convert3Dto2D(e); Math.cos(2 * o) > 0 ? (t.textAlign = 'center', t.textBaseline = 'top', s.y += n) : Math.sin(2 * o) < 0 ? (t.textAlign = 'right', t.textBaseline = 'middle') : (t.textAlign = 'left', t.textBaseline = 'middle'), t.fillStyle = this.axisColor, t.fillText(i, s.x, s.y); }, _.prototype.drawAxisLabelY = function (t, e, i, o, n) { void 0 === n && (n = 0); const s = this._convert3Dto2D(e); Math.cos(2 * o) < 0 ? (t.textAlign = 'center', t.textBaseline = 'top', s.y += n) : Math.sin(2 * o) > 0 ? (t.textAlign = 'right', t.textBaseline = 'middle') : (t.textAlign = 'left', t.textBaseline = 'middle'), t.fillStyle = this.axisColor, t.fillText(i, s.x, s.y); }, _.prototype.drawAxisLabelZ = function (t, e, i, o) { void 0 === o && (o = 0); const n = this._convert3Dto2D(e); t.textAlign = 'right', t.textBaseline = 'middle', t.fillStyle = this.axisColor, t.fillText(i, n.x - o, n.y); }, _.prototype._line3d = function (t, e, i, o) { const n = this._convert3Dto2D(e); const s = this._convert3Dto2D(i); this._line(t, n, s, o); }, _.prototype._redrawAxis = function () { let t; let e; let i; let o; let n; let s; let r; let a; let l; let c; let p; const f = this._getContext(); f.font = `${24 / this.camera.getArmLength()}px arial`; let m; let v; let g; const y = 0.025 / this.scale.x; const b = 0.025 / this.scale.y; const _ = 5 / this.camera.getArmLength(); const w = this.camera.getArmRotation().horizontal; const x = new d(Math.cos(w), Math.sin(w)); const k = this.xRange; const D = this.yRange; const S = this.zRange; f.lineWidth = 1, o = void 0 === this.defaultXStep, i = new u(k.min, k.max, this.xStep, o), i.start(!0); while (!i.end()) { const C = i.getCurrent(); if (this.showGrid ? (t = new h(C, D.min, S.min), e = new h(C, D.max, S.min), this._line3d(f, t, e, this.gridColor)) : this.showXAxis && (t = new h(C, D.min, S.min), e = new h(C, D.min + y, S.min), this._line3d(f, t, e, this.axisColor), t = new h(C, D.max, S.min), e = new h(C, D.max - y, S.min), this._line3d(f, t, e, this.axisColor)), this.showXAxis) { r = x.x > 0 ? D.min : D.max, m = new h(C, r, S.min); const M = `  ${this.xValueLabel(C)}  `; this.drawAxisLabelX(f, m, M, w, _); }i.next(); }f.lineWidth = 1, o = void 0 === this.defaultYStep, i = new u(D.min, D.max, this.yStep, o), i.start(!0); while (!i.end()) { const O = i.getCurrent(); if (this.showGrid ? (t = new h(k.min, O, S.min), e = new h(k.max, O, S.min), this._line3d(f, t, e, this.gridColor)) : this.showYAxis && (t = new h(k.min, O, S.min), e = new h(k.min + b, O, S.min), this._line3d(f, t, e, this.axisColor), t = new h(k.max, O, S.min), e = new h(k.max - b, O, S.min), this._line3d(f, t, e, this.axisColor)), this.showYAxis) { s = x.y > 0 ? k.min : k.max, m = new h(s, O, S.min); const E = `  ${this.yValueLabel(O)}  `; this.drawAxisLabelY(f, m, E, w, _); }i.next(); } if (this.showZAxis) { f.lineWidth = 1, o = void 0 === this.defaultZStep, i = new u(S.min, S.max, this.zStep, o), i.start(!0), s = x.x > 0 ? k.min : k.max, r = x.y < 0 ? D.min : D.max; while (!i.end()) { const T = i.getCurrent(); const P = new h(s, r, T); const I = this._convert3Dto2D(P); e = new d(I.x - _, I.y), this._line(f, I, e, this.axisColor); const N = `${this.zValueLabel(T)} `; this.drawAxisLabelZ(f, P, N, 5), i.next(); }f.lineWidth = 1, t = new h(s, r, S.min), e = new h(s, r, S.max), this._line3d(f, t, e, this.axisColor); } this.showXAxis && (f.lineWidth = 1, v = new h(k.min, D.min, S.min), g = new h(k.max, D.min, S.min), this._line3d(f, v, g, this.axisColor), v = new h(k.min, D.max, S.min), g = new h(k.max, D.max, S.min), this._line3d(f, v, g, this.axisColor)); this.showYAxis && (f.lineWidth = 1, t = new h(k.min, D.min, S.min), e = new h(k.min, D.max, S.min), this._line3d(f, t, e, this.axisColor), t = new h(k.max, D.min, S.min), e = new h(k.max, D.max, S.min), this._line3d(f, t, e, this.axisColor)); const R = this.xLabel; R.length > 0 && this.showXAxis && (p = 0.1 / this.scale.y, s = (k.max + 3 * k.min) / 4, r = x.x > 0 ? D.min - p : D.max + p, n = new h(s, r, S.min), this.drawAxisLabelX(f, n, R, w)); const A = this.yLabel; A.length > 0 && this.showYAxis && (c = 0.1 / this.scale.x, s = x.y > 0 ? k.min - c : k.max + c, r = (D.max + 3 * D.min) / 4, n = new h(s, r, S.min), this.drawAxisLabelY(f, n, A, w)); const z = this.zLabel; z.length > 0 && this.showZAxis && (l = 30, s = x.x > 0 ? k.min : k.max, r = x.y < 0 ? D.min : D.max, a = (S.max + 3 * S.min) / 4, n = new h(s, r, a), this.drawAxisLabelZ(f, n, z, l)); }, _.prototype._hsv2rgb = function (t, e, i) { let o; let n; let s; let r; let a; let h; switch (r = i * e, a = Math.floor(t / 60), h = r * (1 - Math.abs(t / 60 % 2 - 1)), a) { case 0: o = r, n = h, s = 0; break; case 1: o = h, n = r, s = 0; break; case 2: o = 0, n = r, s = h; break; case 3: o = 0, n = h, s = r; break; case 4: o = h, n = 0, s = r; break; case 5: o = r, n = 0, s = h; break; default: o = 0, n = 0, s = 0; break; } return `RGB(${parseInt(255 * o)},${parseInt(255 * n)},${parseInt(255 * s)})`; }, _.prototype._getStrokeWidth = function (t) { return void 0 !== t ? this.showPerspective ? 1 / -t.trans.z * this.dataColor.strokeWidth : -this.eye.z / this.camera.getArmLength() * this.dataColor.strokeWidth : this.dataColor.strokeWidth; }, _.prototype._redrawBar = function (t, e, i, o, n, s) { let r; const a = this; const d = e.point; const l = this.zRange.min; const u = [{ point: new h(d.x - i, d.y - o, d.z) }, { point: new h(d.x + i, d.y - o, d.z) }, { point: new h(d.x + i, d.y + o, d.z) }, { point: new h(d.x - i, d.y + o, d.z) }]; const c = [{ point: new h(d.x - i, d.y - o, l) }, { point: new h(d.x + i, d.y - o, l) }, { point: new h(d.x + i, d.y + o, l) }, { point: new h(d.x - i, d.y + o, l) }]; u.forEach((t) => { t.screen = a._convert3Dto2D(t.point); }), c.forEach((t) => { t.screen = a._convert3Dto2D(t.point); }); const p = [{ corners: u, center: h.avg(c[0].point, c[2].point) }, { corners: [u[0], u[1], c[1], c[0]], center: h.avg(c[1].point, c[0].point) }, { corners: [u[1], u[2], c[2], c[1]], center: h.avg(c[2].point, c[1].point) }, { corners: [u[2], u[3], c[3], c[2]], center: h.avg(c[3].point, c[2].point) }, { corners: [u[3], u[0], c[0], c[3]], center: h.avg(c[0].point, c[3].point) }]; e.surfaces = p; for (let f = 0; f < p.length; f++) { r = p[f]; const m = this._convertPointToTranslation(r.center); r.dist = this.showPerspective ? m.length() : -m.z; }p.sort((t, e) => { const i = e.dist - t.dist; return i || (t.corners === u ? 1 : e.corners === u ? -1 : 0); }), t.lineWidth = this._getStrokeWidth(e), t.strokeStyle = s, t.fillStyle = n; for (let v = 2; v < p.length; v++)r = p[v], this._polygon(t, r.corners); }, _.prototype._polygon = function (t, e, i, o) { if (!(e.length < 2)) { void 0 !== i && (t.fillStyle = i), void 0 !== o && (t.strokeStyle = o), t.beginPath(), t.moveTo(e[0].screen.x, e[0].screen.y); for (let n = 1; n < e.length; ++n) { const s = e[n]; t.lineTo(s.screen.x, s.screen.y); }t.closePath(), t.fill(), t.stroke(); } }, _.prototype._drawCircle = function (t, e, i, o, n) { const s = this._calcRadius(e, n); t.lineWidth = this._getStrokeWidth(e), t.strokeStyle = o, t.fillStyle = i, t.beginPath(), t.arc(e.screen.x, e.screen.y, s, 0, 2 * Math.PI, !0), t.fill(), t.stroke(); }, _.prototype._getColorsRegular = function (t) { const e = 240 * (1 - (t.point.z - this.zRange.min) * this.scale.z / this.verticalRatio); const i = this._hsv2rgb(e, 1, 1); const o = this._hsv2rgb(e, 1, 0.8); return { fill: i, border: o }; }, _.prototype._getColorsColor = function (t) { let e; let i; if (typeof t.point.value === 'string')e = t.point.value, i = t.point.value; else { const o = 240 * (1 - (t.point.value - this.valueRange.min) * this.scale.value); e = this._hsv2rgb(o, 1, 1), i = this._hsv2rgb(o, 1, 0.8); } return { fill: e, border: i }; }, _.prototype._getColorsSize = function () { return { fill: this.dataColor.fill, border: this.dataColor.stroke }; }, _.prototype._calcRadius = function (t, e) { let i; return void 0 === e && (e = this._dotSize()), i = this.showPerspective ? e / -t.trans.z : e * (-this.eye.z / this.camera.getArmLength()), i < 0 && (i = 0), i; }, _.prototype._redrawBarGraphPoint = function (t, e) { const i = this.xBarWidth / 2; const o = this.yBarWidth / 2; const n = this._getColorsRegular(e); this._redrawBar(t, e, i, o, n.fill, n.border); }, _.prototype._redrawBarColorGraphPoint = function (t, e) { const i = this.xBarWidth / 2; const o = this.yBarWidth / 2; const n = this._getColorsColor(e); this._redrawBar(t, e, i, o, n.fill, n.border); }, _.prototype._redrawBarSizeGraphPoint = function (t, e) { const i = (e.point.value - this.valueRange.min) / this.valueRange.range(); const o = this.xBarWidth / 2 * (0.8 * i + 0.2); const n = this.yBarWidth / 2 * (0.8 * i + 0.2); const s = this._getColorsSize(); this._redrawBar(t, e, o, n, s.fill, s.border); }, _.prototype._redrawDotGraphPoint = function (t, e) { const i = this._getColorsRegular(e); this._drawCircle(t, e, i.fill, i.border); }, _.prototype._redrawDotLineGraphPoint = function (t, e) { const i = this._convert3Dto2D(e.bottom); t.lineWidth = 1, this._line(t, i, e.screen, this.gridColor), this._redrawDotGraphPoint(t, e); }, _.prototype._redrawDotColorGraphPoint = function (t, e) { const i = this._getColorsColor(e); this._drawCircle(t, e, i.fill, i.border); }, _.prototype._redrawDotSizeGraphPoint = function (t, e) { const i = this._dotSize(); const o = (e.point.value - this.valueRange.min) / this.valueRange.range(); const n = i * this.dotSizeMinFraction; const s = i * this.dotSizeMaxFraction - n; const r = n + s * o; const a = this._getColorsSize(); this._drawCircle(t, e, a.fill, a.border, r); }, _.prototype._redrawSurfaceGraphPoint = function (t, e) { const i = e.pointRight; const o = e.pointTop; const n = e.pointCross; if (void 0 !== e && void 0 !== i && void 0 !== o && void 0 !== n) { let s; let r; let a = !0; if (this.showGrayBottom || this.showShadow) { const d = h.subtract(n.trans, e.trans); const l = h.subtract(o.trans, i.trans); var u = h.crossProduct(d, l); var c = u.length(); a = u.z > 0; } if (a) { let p; const f = (e.point.z + i.point.z + o.point.z + n.point.z) / 4; const m = 240 * (1 - (f - this.zRange.min) * this.scale.z / this.verticalRatio); const v = 1; this.showShadow ? (p = Math.min(1 + u.x / c / 2, 1), s = this._hsv2rgb(m, v, p), r = s) : (p = 1, s = this._hsv2rgb(m, v, p), r = this.axisColor); } else s = 'gray', r = this.axisColor; t.lineWidth = this._getStrokeWidth(e); const g = [e, i, n, o]; this._polygon(t, g, s, r); } }, _.prototype._drawGridLine = function (t, e, i) { if (void 0 !== e && void 0 !== i) { const o = (e.point.z + i.point.z) / 2; const n = 240 * (1 - (o - this.zRange.min) * this.scale.z / this.verticalRatio); t.lineWidth = 2 * this._getStrokeWidth(e), t.strokeStyle = this._hsv2rgb(n, 1, 1), this._line(t, e.screen, i.screen); } }, _.prototype._redrawGridGraphPoint = function (t, e) { this._drawGridLine(t, e, e.pointRight), this._drawGridLine(t, e, e.pointTop); }, _.prototype._redrawLineGraphPoint = function (t, e) { void 0 !== e.pointNext && (t.lineWidth = this._getStrokeWidth(e), t.strokeStyle = this.dataColor.stroke, this._line(t, e.screen, e.pointNext.screen)); }, _.prototype._redrawDataGraph = function () { let t; const e = this._getContext(); if (!(void 0 === this.dataPoints || this.dataPoints.length <= 0)) for (this._calcTranslations(this.dataPoints), t = 0; t < this.dataPoints.length; t++) { const i = this.dataPoints[t]; this._pointDrawingMethod.call(this, e, i); } }, _.prototype._storeMousePosition = function (t) { this.startMouseX = w(t), this.startMouseY = x(t), this._startCameraOffset = this.camera.getOffset(); }, _.prototype._onMouseDown = function (t) { if (t = t || window.event, this.leftButtonDown && this._onMouseUp(t), this.leftButtonDown = t.which ? t.which === 1 : t.button === 1, this.leftButtonDown || this.touchDown) { this._storeMousePosition(t), this.startStart = new Date(this.start), this.startEnd = new Date(this.end), this.startArmRotation = this.camera.getArmRotation(), this.frame.style.cursor = 'move'; const e = this; this.onmousemove = function (t) { e._onMouseMove(t); }, this.onmouseup = function (t) { e._onMouseUp(t); }, a.addEventListener(document, 'mousemove', e.onmousemove), a.addEventListener(document, 'mouseup', e.onmouseup), a.preventDefault(t); } }, _.prototype._onMouseMove = function (t) { this.moving = !0, t = t || window.event; const e = parseFloat(w(t)) - this.startMouseX; const i = parseFloat(x(t)) - this.startMouseY; if (t && !0 === t.ctrlKey) { const o = 0.5 * this.frame.clientWidth; const n = 0.5 * this.frame.clientHeight; const s = (this._startCameraOffset.x || 0) - e / o * this.camera.armLength * 0.8; const r = (this._startCameraOffset.y || 0) + i / n * this.camera.armLength * 0.8; this.camera.setOffset(s, r), this._storeMousePosition(t); } else { let h = this.startArmRotation.horizontal + e / 200; let d = this.startArmRotation.vertical + i / 200; const l = 4; const u = Math.sin(l / 360 * 2 * Math.PI); Math.abs(Math.sin(h)) < u && (h = Math.round(h / Math.PI) * Math.PI - 0.001), Math.abs(Math.cos(h)) < u && (h = (Math.round(h / Math.PI - 0.5) + 0.5) * Math.PI - 0.001), Math.abs(Math.sin(d)) < u && (d = Math.round(d / Math.PI) * Math.PI), Math.abs(Math.cos(d)) < u && (d = (Math.round(d / Math.PI - 0.5) + 0.5) * Math.PI), this.camera.setArmRotation(h, d); } this.redraw(); const c = this.getCameraPosition(); this.emit('cameraPositionChange', c), a.preventDefault(t); }, _.prototype._onMouseUp = function (t) { this.frame.style.cursor = 'auto', this.leftButtonDown = !1, a.removeEventListener(document, 'mousemove', this.onmousemove), a.removeEventListener(document, 'mouseup', this.onmouseup), a.preventDefault(t); }, _.prototype._onClick = function (t) { if (this.onclick_callback) { if (this.moving) this.moving = !1; else { const e = this.frame.getBoundingClientRect(); const i = w(t) - e.left; const o = x(t) - e.top; const n = this._dataPointFromXY(i, o); n && this.onclick_callback(n.point.data); }a.preventDefault(t); } }, _.prototype._onTooltip = function (t) { const e = 300; const i = this.frame.getBoundingClientRect(); const o = w(t) - i.left; const n = x(t) - i.top; if (this.showTooltip) if (this.tooltipTimeout && clearTimeout(this.tooltipTimeout), this.leftButtonDown) this._hideTooltip(); else if (this.tooltip && this.tooltip.dataPoint) { const s = this._dataPointFromXY(o, n); s !== this.tooltip.dataPoint && (s ? this._showTooltip(s) : this._hideTooltip()); } else { const r = this; this.tooltipTimeout = setTimeout(() => { r.tooltipTimeout = null; const t = r._dataPointFromXY(o, n); t && r._showTooltip(t); }, e); } }, _.prototype._onTouchStart = function (t) { this.touchDown = !0; const e = this; this.ontouchmove = function (t) { e._onTouchMove(t); }, this.ontouchend = function (t) { e._onTouchEnd(t); }, a.addEventListener(document, 'touchmove', e.ontouchmove), a.addEventListener(document, 'touchend', e.ontouchend), this._onMouseDown(t); }, _.prototype._onTouchMove = function (t) { this._onMouseMove(t); }, _.prototype._onTouchEnd = function (t) { this.touchDown = !1, a.removeEventListener(document, 'touchmove', this.ontouchmove), a.removeEventListener(document, 'touchend', this.ontouchend), this._onMouseUp(t); }, _.prototype._onWheel = function (t) { t || (t = window.event); let e = 0; if (t.wheelDelta ? e = t.wheelDelta / 120 : t.detail && (e = -t.detail / 3), e) { const i = this.camera.getArmLength(); const o = i * (1 - e / 10); this.camera.setArmLength(o), this.redraw(), this._hideTooltip(); } const n = this.getCameraPosition(); this.emit('cameraPositionChange', n), a.preventDefault(t); }, _.prototype._insideTriangle = function (t, e) { const i = e[0]; const o = e[1]; const n = e[2]; function s(t) { return t > 0 ? 1 : t < 0 ? -1 : 0; } const r = s((o.x - i.x) * (t.y - i.y) - (o.y - i.y) * (t.x - i.x)); const a = s((n.x - o.x) * (t.y - o.y) - (n.y - o.y) * (t.x - o.x)); const h = s((i.x - n.x) * (t.y - n.y) - (i.y - n.y) * (t.x - n.x)); return (r == 0 || a == 0 || r == a) && (a == 0 || h == 0 || a == h) && (r == 0 || h == 0 || r == h); }, _.prototype._dataPointFromXY = function (t, e) { let i; const o = 100; let n = null; let s = null; let r = null; const a = new d(t, e); if (this.style === _.STYLE.BAR || this.style === _.STYLE.BARCOLOR || this.style === _.STYLE.BARSIZE) for (i = this.dataPoints.length - 1; i >= 0; i--) { n = this.dataPoints[i]; const h = n.surfaces; if (h) for (let l = h.length - 1; l >= 0; l--) { const u = h[l]; const c = u.corners; const p = [c[0].screen, c[1].screen, c[2].screen]; const f = [c[2].screen, c[3].screen, c[0].screen]; if (this._insideTriangle(a, p) || this._insideTriangle(a, f)) return n; } } else for (i = 0; i < this.dataPoints.length; i++) { n = this.dataPoints[i]; const m = n.screen; if (m) { const v = Math.abs(t - m.x); const g = Math.abs(e - m.y); const y = Math.sqrt(v * v + g * g); (r === null || y < r) && y < o && (r = y, s = n); } } return s; }, _.prototype.hasBars = function (t) { return t == _.STYLE.BAR || t == _.STYLE.BARCOLOR || t == _.STYLE.BARSIZE; }, _.prototype._showTooltip = function (t) { let e; let i; let o; this.tooltip ? (e = this.tooltip.dom.content, i = this.tooltip.dom.line, o = this.tooltip.dom.dot) : (e = document.createElement('div'), (0, n.default)(e.style, {}, this.tooltipStyle.content), e.style.position = 'absolute', i = document.createElement('div'), (0, n.default)(i.style, {}, this.tooltipStyle.line), i.style.position = 'absolute', o = document.createElement('div'), (0, n.default)(o.style, {}, this.tooltipStyle.dot), o.style.position = 'absolute', this.tooltip = { dataPoint: null, dom: { content: e, line: i, dot: o } }), this._hideTooltip(), this.tooltip.dataPoint = t, typeof this.showTooltip === 'function' ? e.innerHTML = this.showTooltip(t.point) : e.innerHTML = `<table><tr><td>${this.xLabel}:</td><td>${t.point.x}</td></tr><tr><td>${this.yLabel}:</td><td>${t.point.y}</td></tr><tr><td>${this.zLabel}:</td><td>${t.point.z}</td></tr></table>`, e.style.left = '0', e.style.top = '0', this.frame.appendChild(e), this.frame.appendChild(i), this.frame.appendChild(o); const s = e.offsetWidth; const r = e.offsetHeight; const a = i.offsetHeight; const h = o.offsetWidth; const d = o.offsetHeight; let l = t.screen.x - s / 2; l = Math.min(Math.max(l, 10), this.frame.clientWidth - 10 - s), i.style.left = `${t.screen.x}px`, i.style.top = `${t.screen.y - a}px`, e.style.left = `${l}px`, e.style.top = `${t.screen.y - a - r}px`, o.style.left = `${t.screen.x - h / 2}px`, o.style.top = `${t.screen.y - d / 2}px`; }, _.prototype._hideTooltip = function () { if (this.tooltip) for (const t in this.tooltip.dataPoint = null, this.tooltip.dom) if (this.tooltip.dom.hasOwnProperty(t)) { const e = this.tooltip.dom[t]; e && e.parentNode && e.parentNode.removeChild(e); } }, _.prototype.setCameraPosition = function (t) { c.setCameraPosition(t, this), this.redraw(); }, _.prototype.setSize = function (t, e) { this._setSize(t, e), this.redraw(); }, t.exports = _;
    }, function (t, e, i) { i(163), t.exports = i(7).Object.assign; }, function (t, e, i) { const o = i(17); o(o.S + o.F, 'Object', { assign: i(164) }); }, function (t, e, i) { const o = i(33); const n = i(63); const s = i(42); const r = i(41); const a = i(78); const h = Object.assign; t.exports = !h || i(28)(() => { const t = {}; const e = {}; const i = Symbol(); const o = 'abcdefghijklmnopqrst'; return t[i] = 7, o.split('').forEach((t) => { e[t] = t; }), h({}, t)[i] != 7 || Object.keys(h({}, e)).join('') != o; }) ? function (t, e) { const i = r(t); const h = arguments.length; let d = 1; const l = n.f; const u = s.f; while (h > d) { var c; const p = a(arguments[d++]); const f = l ? o(p).concat(l(p)) : o(p); const m = f.length; let v = 0; while (m > v)u.call(p, c = f[v++]) && (i[c] = p[c]); } return i; } : h; }, function (t, e, i) { t.exports = { default: i(166), __esModule: !0 }; }, function (t, e, i) { i(167), t.exports = i(7).Math.sign; }, function (t, e, i) { const o = i(17); o(o.S, 'Math', { sign: i(168) }); }, function (t, e) { t.exports = Math.sign || function (t) { return (t = +t) == 0 || t != t ? t : t < 0 ? -1 : 1; }; }, function (t, e, i) { t.exports = { default: i(170), __esModule: !0 }; }, function (t, e, i) { i(171); const o = i(7).Object; t.exports = function (t, e, i) { return o.defineProperty(t, e, i); }; }, function (t, e, i) { const o = i(17); o(o.S + o.F * !i(21), 'Object', { defineProperty: i(20).f }); }, function (t, e, i) {
      Object.defineProperty(e, '__esModule', { value: !0 }); const o = 'string'; const n = 'boolean'; const s = 'number'; const r = 'object'; const a = {
        fill: { string: o }, stroke: { string: o }, strokeWidth: { number: s }, __type__: { string: o, object: r, undefined: 'undefined' },
      }; const h = {
        animationAutoStart: { boolean: n, undefined: 'undefined' },
        animationInterval: { number: s },
        animationPreload: { boolean: n },
        axisColor: { string: o },
        backgroundColor: a,
        xBarWidth: { number: s, undefined: 'undefined' },
        yBarWidth: { number: s, undefined: 'undefined' },
        cameraPosition: {
          distance: { number: s }, horizontal: { number: s }, vertical: { number: s }, __type__: { object: r },
        },
        xCenter: { string: o },
        yCenter: { string: o },
        dataColor: a,
        dotSizeMinFraction: { number: s },
        dotSizeMaxFraction: { number: s },
        dotSizeRatio: { number: s },
        filterLabel: { string: o },
        gridColor: { string: o },
        onclick: { function: 'function' },
        keepAspectRatio: { boolean: n },
        xLabel: { string: o },
        yLabel: { string: o },
        zLabel: { string: o },
        legendLabel: { string: o },
        xMin: { number: s, undefined: 'undefined' },
        yMin: { number: s, undefined: 'undefined' },
        zMin: { number: s, undefined: 'undefined' },
        xMax: { number: s, undefined: 'undefined' },
        yMax: { number: s, undefined: 'undefined' },
        zMax: { number: s, undefined: 'undefined' },
        showAnimationControls: { boolean: n, undefined: 'undefined' },
        showGrid: { boolean: n },
        showLegend: { boolean: n, undefined: 'undefined' },
        showPerspective: { boolean: n },
        showShadow: { boolean: n },
        showXAxis: { boolean: n },
        showYAxis: { boolean: n },
        showZAxis: { boolean: n },
        xStep: { number: s, undefined: 'undefined' },
        yStep: { number: s, undefined: 'undefined' },
        zStep: { number: s, undefined: 'undefined' },
        style: { number: s, string: ['bar', 'bar-color', 'bar-size', 'dot', 'dot-line', 'dot-color', 'dot-size', 'line', 'grid', 'surface'] },
        tooltip: { boolean: n, function: 'function' },
        tooltipStyle: {
          content: {
            color: { string: o }, background: { string: o }, border: { string: o }, borderRadius: { string: o }, boxShadow: { string: o }, padding: { string: o }, __type__: { object: r },
          },
          line: {
            borderLeft: { string: o }, height: { string: o }, width: { string: o }, __type__: { object: r },
          },
          dot: {
            border: { string: o }, borderRadius: { string: o }, height: { string: o }, width: { string: o }, __type__: { object: r },
          },
          __type__: { object: r },
        },
        xValueLabel: { function: 'function' },
        yValueLabel: { function: 'function' },
        zValueLabel: { function: 'function' },
        valueMax: { number: s, undefined: 'undefined' },
        valueMin: { number: s, undefined: 'undefined' },
        verticalRatio: { number: s },
        height: { string: o },
        width: { string: o },
        __type__: { object: r },
      }; e.allOptions = h;
    }, function (t, e, i) {
      const o = i(11); const n = i(12); const s = i(174); const r = i(96); const a = i(94); const h = i(34); function d() { this.dataTable = null; }d.prototype.initializeData = function (t, e, i) { if (void 0 !== e) { let s; if (Array.isArray(e) && (e = new o(e)), !(e instanceof o || e instanceof n)) throw new Error('Array, DataSet, or DataView expected'); if (s = e.get(), s.length != 0) { this.style = i, this.dataSet && this.dataSet.off('*', this._onChange), this.dataSet = e, this.dataTable = s; const a = this; this._onChange = function () { t.setData(a.dataSet); }, this.dataSet.on('*', this._onChange), this.colX = 'x', this.colY = 'y', this.colZ = 'z'; const h = t.hasBars(i); if (h && (void 0 !== t.defaultXBarWidth ? this.xBarWidth = t.defaultXBarWidth : this.xBarWidth = this.getSmallestDifference(s, this.colX) || 1, void 0 !== t.defaultYBarWidth ? this.yBarWidth = t.defaultYBarWidth : this.yBarWidth = this.getSmallestDifference(s, this.colY) || 1), this._initializeRange(s, this.colX, t, h), this._initializeRange(s, this.colY, t, h), this._initializeRange(s, this.colZ, t, !1), s[0].hasOwnProperty('style')) { this.colValue = 'style'; const d = this.getColumnRange(s, this.colValue); this._setRangeDefaults(d, t.defaultValueMin, t.defaultValueMax), this.valueRange = d; } let l; const u = this.getDataTable(); return u[0].hasOwnProperty('filter') && void 0 === this.dataFilter && (this.dataFilter = new r(this, 'filter', t), this.dataFilter.setOnLoadCallback(() => { t.redraw(); })), l = this.dataFilter ? this.dataFilter._getDataPoints() : this._getDataPoints(this.getDataTable()), l; } } }, d.prototype._collectRangeSettings = function (t, e) {
        const i = ['x', 'y', 'z'].indexOf(t); if (i == -1) throw new Error(`Column '${t}' invalid`); const o = t.toUpperCase(); return {
          barWidth: this[`${t}BarWidth`], min: e[`default${o}Min`], max: e[`default${o}Max`], step: e[`default${o}Step`], range_label: `${t}Range`, step_label: `${t}Step`,
        };
      }, d.prototype._initializeRange = function (t, e, i, o) { const n = 5; const s = this._collectRangeSettings(e, i); const r = this.getColumnRange(t, e); o && e != 'z' && r.expand(s.barWidth / 2), this._setRangeDefaults(r, s.min, s.max), this[s.range_label] = r, this[s.step_label] = void 0 !== s.step ? s.step : r.range() / n; }, d.prototype.getDistinctValues = function (t, e) { void 0 === e && (e = this.dataTable); for (var i = [], o = 0; o < e.length; o++) { const n = e[o][t] || 0; i.indexOf(n) === -1 && i.push(n); } return i.sort((t, e) => t - e); }, d.prototype.getSmallestDifference = function (t, e) { for (var i = this.getDistinctValues(t, e), o = null, n = 1; n < i.length; n++) { const s = i[n] - i[n - 1]; (o == null || o > s) && (o = s); } return o; }, d.prototype.getColumnRange = function (t, e) { for (var i = new s(), o = 0; o < t.length; o++) { const n = t[o][e]; i.adjust(n); } return i; }, d.prototype.getNumberOfRows = function () { return this.dataTable.length; }, d.prototype._setRangeDefaults = function (t, e, i) { void 0 !== e && (t.min = e), void 0 !== i && (t.max = i), t.max <= t.min && (t.max = t.min + 1); }, d.prototype.getDataTable = function () { return this.dataTable; }, d.prototype.getDataSet = function () { return this.dataSet; }, d.prototype.getDataPoints = function (t) { for (var e = [], i = 0; i < t.length; i++) { const o = new h(); o.x = t[i][this.colX] || 0, o.y = t[i][this.colY] || 0, o.z = t[i][this.colZ] || 0, o.data = t[i], void 0 !== this.colValue && (o.value = t[i][this.colValue] || 0); const n = {}; n.point = o, n.bottom = new h(o.x, o.y, this.zRange.min), n.trans = void 0, n.screen = void 0, e.push(n); } return e; }, d.prototype.initDataAsMatrix = function (t) { let e; let i; let o; let n; const s = this.getDistinctValues(this.colX, t); const r = this.getDistinctValues(this.colY, t); const a = this.getDataPoints(t); const h = []; for (o = 0; o < a.length; o++) { n = a[o]; const d = s.indexOf(n.point.x); const l = r.indexOf(n.point.y); void 0 === h[d] && (h[d] = []), h[d][l] = n; } for (e = 0; e < h.length; e++) for (i = 0; i < h[e].length; i++)h[e][i] && (h[e][i].pointRight = e < h.length - 1 ? h[e + 1][i] : void 0, h[e][i].pointTop = i < h[e].length - 1 ? h[e][i + 1] : void 0, h[e][i].pointCross = e < h.length - 1 && i < h[e].length - 1 ? h[e + 1][i + 1] : void 0); return a; }, d.prototype.getInfo = function () { const t = this.dataFilter; if (t) return `${t.getLabel()}: ${t.getSelectedValue()}`; }, d.prototype.reload = function () { this.dataTable && this.setData(this.dataTable); }, d.prototype._getDataPoints = function (t) { let e = []; if (this.style === a.STYLE.GRID || this.style === a.STYLE.SURFACE)e = this.initDataAsMatrix(t); else if (this._checkValueField(t), e = this.getDataPoints(t), this.style === a.STYLE.LINE) for (let i = 0; i < e.length; i++)i > 0 && (e[i - 1].pointNext = e[i]); return e; }, d.prototype._checkValueField = function (t) { const e = this.style === a.STYLE.BARCOLOR || this.style === a.STYLE.BARSIZE || this.style === a.STYLE.DOTCOLOR || this.style === a.STYLE.DOTSIZE; if (e) { if (void 0 === this.colValue) throw new Error(`Expected data to have  field 'style'  for graph style '${this.style}'`); if (void 0 === t[0][this.colValue]) throw new Error(`Expected data to have  field '${this.colValue}'  for graph style '${this.style}'`); } }, t.exports = d;
    }, function (t, e, i) { function o() { this.min = void 0, this.max = void 0; }o.prototype.adjust = function (t) { void 0 !== t && ((void 0 === this.min || this.min > t) && (this.min = t), (void 0 === this.max || this.max < t) && (this.max = t)); }, o.prototype.combine = function (t) { this.add(t.min), this.add(t.max); }, o.prototype.expand = function (t) { if (void 0 !== t) { const e = this.min - t; const i = this.max + t; if (e > i) throw new Error('Passed expansion value makes range invalid'); this.min = e, this.max = i; } }, o.prototype.range = function () { return this.max - this.min; }, o.prototype.center = function () { return (this.min + this.max) / 2; }, t.exports = o; }, function (t, e, i) { let o; let n; let s; (function (i) { n = [], o = i, s = typeof o === 'function' ? o.apply(e, n) : o, void 0 === s || (t.exports = s); }(() => { let t = null; return function e(i, o) { const n = o || { preventDefault: !1 }; if (i.Manager) { const s = i; const r = function (t, i) { const o = Object.create(n); return i && s.assign(o, i), e(new s(t, o), o); }; return s.assign(r, s), r.Manager = function (t, i) { const o = Object.create(n); return i && s.assign(o, i), e(new s.Manager(t, o), o); }, r; } const a = Object.create(i); const h = i.element; function d(t) { return t.match(/[^ ]+/g); } function l(e) { if (e.type !== 'hammer.input') { if (e.srcEvent._handled || (e.srcEvent._handled = {}), e.srcEvent._handled[e.type]) return; e.srcEvent._handled[e.type] = !0; } let i = !1; e.stopPropagation = function () { i = !0; }; const o = e.srcEvent.stopPropagation.bind(e.srcEvent); typeof o === 'function' && (e.srcEvent.stopPropagation = function () { o(), e.stopPropagation(); }), e.firstTarget = t; let n = t; while (n && !i) { const s = n.hammer; if (s) for (var r, a = 0; a < s.length; a++) if (r = s[a]._handlers[e.type], r) for (let h = 0; h < r.length && !i; h++)r[h](e); n = n.parentNode; } } return h.hammer || (h.hammer = []), h.hammer.push(a), i.on('hammer.input', (e) => { !0 !== n.preventDefault && n.preventDefault !== e.pointerType || e.preventDefault(), e.isFirst && (t = e.target); }), a._handlers = {}, a.on = function (t, e) { return d(t).forEach((t) => { let o = a._handlers[t]; o || (a._handlers[t] = o = [], i.on(t, l)), o.push(e); }), a; }, a.off = function (t, e) { return d(t).forEach((t) => { let o = a._handlers[t]; o && (o = e ? o.filter(t => t !== e) : [], o.length > 0 ? a._handlers[t] = o : (i.off(t, l), delete a._handlers[t])); }), a; }, a.emit = function (e, o) { t = o.target, i.emit(e, o); }, a.destroy = function () { const t = i.element.hammer; const e = t.indexOf(a); e !== -1 && t.splice(e, 1), t.length || delete i.element.hammer, a._handlers = {}, i.destroy(); }, a; }; })); }, function (t, e, i) {
      let o;
      /*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
      /*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
      (function (n, s, r, a) {
        let h; const d = ['', 'webkit', 'Moz', 'MS', 'ms', 'o']; const l = s.createElement('div'); const u = 'function'; const c = Math.round; const p = Math.abs; const f = Date.now; function m(t, e, i) { return setTimeout(x(t, i), e); } function v(t, e, i) { return !!Array.isArray(t) && (g(t, i[e], i), !0); } function g(t, e, i) { let o; if (t) if (t.forEach)t.forEach(e, i); else if (t.length !== a) { o = 0; while (o < t.length)e.call(i, t[o], o, t), o++; } else for (o in t)t.hasOwnProperty(o) && e.call(i, t[o], o, t); } function y(t, e, i) { const o = `DEPRECATED METHOD: ${e}\n${i} AT \n`; return function () { const e = new Error('get-stack-trace'); const i = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '').replace(/^\s+at\s+/gm, '').replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace'; const s = n.console && (n.console.warn || n.console.log); return s && s.call(n.console, o, i), t.apply(this, arguments); }; }h = typeof Object.assign !== 'function' ? function (t) { if (t === a || t === null) throw new TypeError('Cannot convert undefined or null to object'); for (var e = Object(t), i = 1; i < arguments.length; i++) { const o = arguments[i]; if (o !== a && o !== null) for (const n in o)o.hasOwnProperty(n) && (e[n] = o[n]); } return e; } : Object.assign; const b = y((t, e, i) => { const o = Object.keys(e); let n = 0; while (n < o.length)(!i || i && t[o[n]] === a) && (t[o[n]] = e[o[n]]), n++; return t; }, 'extend', 'Use `assign`.'); const _ = y((t, e) => b(t, e, !0), 'merge', 'Use `assign`.'); function w(t, e, i) { let o; const n = e.prototype; o = t.prototype = Object.create(n), o.constructor = t, o._super = n, i && h(o, i); } function x(t, e) { return function () { return t.apply(e, arguments); }; } function k(t, e) { return typeof t === u ? t.apply(e && e[0] || a, e) : t; } function D(t, e) { return t === a ? e : t; } function S(t, e, i) { g(E(e), (e) => { t.addEventListener(e, i, !1); }); } function C(t, e, i) { g(E(e), (e) => { t.removeEventListener(e, i, !1); }); } function M(t, e) { while (t) { if (t == e) return !0; t = t.parentNode; } return !1; } function O(t, e) { return t.indexOf(e) > -1; } function E(t) { return t.trim().split(/\s+/g); } function T(t, e, i) { if (t.indexOf && !i) return t.indexOf(e); let o = 0; while (o < t.length) { if (i && t[o][i] == e || !i && t[o] === e) return o; o++; } return -1; } function P(t) { return Array.prototype.slice.call(t, 0); } function I(t, e, i) { let o = []; const n = []; let s = 0; while (s < t.length) { const r = e ? t[s][e] : t[s]; T(n, r) < 0 && o.push(t[s]), n[s] = r, s++; } return i && (o = e ? o.sort((t, i) => t[e] > i[e]) : o.sort()), o; } function N(t, e) { let i; let o; const n = e[0].toUpperCase() + e.slice(1); let s = 0; while (s < d.length) { if (i = d[s], o = i ? i + n : e, o in t) return o; s++; } return a; } let R = 1; function A() { return R++; } function z(t) { const e = t.ownerDocument || t; return e.defaultView || e.parentWindow || n; } const L = /mobile|tablet|ip(ad|hone|od)|android/i; const F = 'ontouchstart' in n; const B = N(n, 'PointerEvent') !== a; const j = F && L.test(navigator.userAgent); const H = 'touch'; const W = 'pen'; const Y = 'mouse'; const G = 'kinect'; const V = 25; const U = 1; const q = 2; const X = 4; const Z = 8; const K = 1; const $ = 2; const J = 4; const Q = 8; const tt = 16; const et = $ | J; const it = Q | tt; const ot = et | it; const nt = ['x', 'y']; const st = ['clientX', 'clientY']; function rt(t, e) { const i = this; this.manager = t, this.callback = e, this.element = t.element, this.target = t.options.inputTarget, this.domHandler = function (e) { k(t.options.enable, [t]) && i.handler(e); }, this.init(); } function at(t) { let e; const i = t.options.inputClass; return e = i || (B ? Ot : j ? zt : F ? jt : kt), new e(t, ht); } function ht(t, e, i) { const o = i.pointers.length; const n = i.changedPointers.length; const s = e & U && o - n === 0; const r = e & (X | Z) && o - n === 0; i.isFirst = !!s, i.isFinal = !!r, s && (t.session = {}), i.eventType = e, dt(t, i), t.emit('hammer.input', i), t.recognize(i), t.session.prevInput = i; } function dt(t, e) { const i = t.session; const o = e.pointers; const n = o.length; i.firstInput || (i.firstInput = ct(e)), n > 1 && !i.firstMultiple ? i.firstMultiple = ct(e) : n === 1 && (i.firstMultiple = !1); const s = i.firstInput; const r = i.firstMultiple; const a = r ? r.center : s.center; const h = e.center = pt(o); e.timeStamp = f(), e.deltaTime = e.timeStamp - s.timeStamp, e.angle = gt(a, h), e.distance = vt(a, h), lt(i, e), e.offsetDirection = mt(e.deltaX, e.deltaY); const d = ft(e.deltaTime, e.deltaX, e.deltaY); e.overallVelocityX = d.x, e.overallVelocityY = d.y, e.overallVelocity = p(d.x) > p(d.y) ? d.x : d.y, e.scale = r ? bt(r.pointers, o) : 1, e.rotation = r ? yt(r.pointers, o) : 0, e.maxPointers = i.prevInput ? e.pointers.length > i.prevInput.maxPointers ? e.pointers.length : i.prevInput.maxPointers : e.pointers.length, ut(i, e); let l = t.element; M(e.srcEvent.target, l) && (l = e.srcEvent.target), e.target = l; } function lt(t, e) { const i = e.center; let o = t.offsetDelta || {}; let n = t.prevDelta || {}; const s = t.prevInput || {}; e.eventType !== U && s.eventType !== X || (n = t.prevDelta = { x: s.deltaX || 0, y: s.deltaY || 0 }, o = t.offsetDelta = { x: i.x, y: i.y }), e.deltaX = n.x + (i.x - o.x), e.deltaY = n.y + (i.y - o.y); } function ut(t, e) { let i; let o; let n; let s; const r = t.lastInterval || e; const h = e.timeStamp - r.timeStamp; if (e.eventType != Z && (h > V || r.velocity === a)) { const d = e.deltaX - r.deltaX; const l = e.deltaY - r.deltaY; const u = ft(h, d, l); o = u.x, n = u.y, i = p(u.x) > p(u.y) ? u.x : u.y, s = mt(d, l), t.lastInterval = e; } else i = r.velocity, o = r.velocityX, n = r.velocityY, s = r.direction; e.velocity = i, e.velocityX = o, e.velocityY = n, e.direction = s; } function ct(t) {
          const e = []; let i = 0; while (i < t.pointers.length)e[i] = { clientX: c(t.pointers[i].clientX), clientY: c(t.pointers[i].clientY) }, i++; return {
            timeStamp: f(), pointers: e, center: pt(e), deltaX: t.deltaX, deltaY: t.deltaY,
          };
        } function pt(t) { const e = t.length; if (e === 1) return { x: c(t[0].clientX), y: c(t[0].clientY) }; let i = 0; let o = 0; let n = 0; while (n < e)i += t[n].clientX, o += t[n].clientY, n++; return { x: c(i / e), y: c(o / e) }; } function ft(t, e, i) { return { x: e / t || 0, y: i / t || 0 }; } function mt(t, e) { return t === e ? K : p(t) >= p(e) ? t < 0 ? $ : J : e < 0 ? Q : tt; } function vt(t, e, i) { i || (i = nt); const o = e[i[0]] - t[i[0]]; const n = e[i[1]] - t[i[1]]; return Math.sqrt(o * o + n * n); } function gt(t, e, i) { i || (i = nt); const o = e[i[0]] - t[i[0]]; const n = e[i[1]] - t[i[1]]; return 180 * Math.atan2(n, o) / Math.PI; } function yt(t, e) { return gt(e[1], e[0], st) + gt(t[1], t[0], st); } function bt(t, e) { return vt(e[0], e[1], st) / vt(t[0], t[1], st); }rt.prototype = { handler() {}, init() { this.evEl && S(this.element, this.evEl, this.domHandler), this.evTarget && S(this.target, this.evTarget, this.domHandler), this.evWin && S(z(this.element), this.evWin, this.domHandler); }, destroy() { this.evEl && C(this.element, this.evEl, this.domHandler), this.evTarget && C(this.target, this.evTarget, this.domHandler), this.evWin && C(z(this.element), this.evWin, this.domHandler); } }; const _t = { mousedown: U, mousemove: q, mouseup: X }; const wt = 'mousedown'; const xt = 'mousemove mouseup'; function kt() { this.evEl = wt, this.evWin = xt, this.pressed = !1, rt.apply(this, arguments); }w(kt, rt, {
          handler(t) {
            let e = _t[t.type]; e & U && t.button === 0 && (this.pressed = !0), e & q && t.which !== 1 && (e = X), this.pressed && (e & X && (this.pressed = !1), this.callback(this.manager, e, {
              pointers: [t], changedPointers: [t], pointerType: Y, srcEvent: t,
            }));
          },
        }); const Dt = {
          pointerdown: U, pointermove: q, pointerup: X, pointercancel: Z, pointerout: Z,
        }; const St = {
          2: H, 3: W, 4: Y, 5: G,
        }; let Ct = 'pointerdown'; let Mt = 'pointermove pointerup pointercancel'; function Ot() { this.evEl = Ct, this.evWin = Mt, rt.apply(this, arguments), this.store = this.manager.session.pointerEvents = []; }n.MSPointerEvent && !n.PointerEvent && (Ct = 'MSPointerDown', Mt = 'MSPointerMove MSPointerUp MSPointerCancel'), w(Ot, rt, {
          handler(t) {
            const e = this.store; let i = !1; const o = t.type.toLowerCase().replace('ms', ''); const n = Dt[o]; const s = St[t.pointerType] || t.pointerType; const r = s == H; let a = T(e, t.pointerId, 'pointerId'); n & U && (t.button === 0 || r) ? a < 0 && (e.push(t), a = e.length - 1) : n & (X | Z) && (i = !0), a < 0 || (e[a] = t, this.callback(this.manager, n, {
              pointers: e, changedPointers: [t], pointerType: s, srcEvent: t,
            }), i && e.splice(a, 1));
          },
        }); const Et = {
          touchstart: U, touchmove: q, touchend: X, touchcancel: Z,
        }; const Tt = 'touchstart'; const Pt = 'touchstart touchmove touchend touchcancel'; function It() { this.evTarget = Tt, this.evWin = Pt, this.started = !1, rt.apply(this, arguments); } function Nt(t, e) { let i = P(t.touches); const o = P(t.changedTouches); return e & (X | Z) && (i = I(i.concat(o), 'identifier', !0)), [i, o]; }w(It, rt, {
          handler(t) {
            const e = Et[t.type]; if (e === U && (this.started = !0), this.started) {
              const i = Nt.call(this, t, e); e & (X | Z) && i[0].length - i[1].length === 0 && (this.started = !1), this.callback(this.manager, e, {
                pointers: i[0], changedPointers: i[1], pointerType: H, srcEvent: t,
              });
            }
          },
        }); const Rt = {
          touchstart: U, touchmove: q, touchend: X, touchcancel: Z,
        }; const At = 'touchstart touchmove touchend touchcancel'; function zt() { this.evTarget = At, this.targetIds = {}, rt.apply(this, arguments); } function Lt(t, e) { const i = P(t.touches); const o = this.targetIds; if (e & (U | q) && i.length === 1) return o[i[0].identifier] = !0, [i, i]; let n; let s; const r = P(t.changedTouches); const a = []; const h = this.target; if (s = i.filter(t => M(t.target, h)), e === U) { n = 0; while (n < s.length)o[s[n].identifier] = !0, n++; }n = 0; while (n < r.length)o[r[n].identifier] && a.push(r[n]), e & (X | Z) && delete o[r[n].identifier], n++; return a.length ? [I(s.concat(a), 'identifier', !0), a] : void 0; }w(zt, rt, {
          handler(t) {
            const e = Rt[t.type]; const i = Lt.call(this, t, e); i && this.callback(this.manager, e, {
              pointers: i[0], changedPointers: i[1], pointerType: H, srcEvent: t,
            });
          },
        }); const Ft = 2500; const Bt = 25; function jt() { rt.apply(this, arguments); const t = x(this.handler, this); this.touch = new zt(this.manager, t), this.mouse = new kt(this.manager, t), this.primaryTouch = null, this.lastTouches = []; } function Ht(t, e) { t & U ? (this.primaryTouch = e.changedPointers[0].identifier, Wt.call(this, e)) : t & (X | Z) && Wt.call(this, e); } function Wt(t) { const e = t.changedPointers[0]; if (e.identifier === this.primaryTouch) { const i = { x: e.clientX, y: e.clientY }; this.lastTouches.push(i); const o = this.lastTouches; const n = function () { const t = o.indexOf(i); t > -1 && o.splice(t, 1); }; setTimeout(n, Ft); } } function Yt(t) { for (let e = t.srcEvent.clientX, i = t.srcEvent.clientY, o = 0; o < this.lastTouches.length; o++) { const n = this.lastTouches[o]; const s = Math.abs(e - n.x); const r = Math.abs(i - n.y); if (s <= Bt && r <= Bt) return !0; } return !1; }w(jt, rt, { handler(t, e, i) { const o = i.pointerType == H; const n = i.pointerType == Y; if (!(n && i.sourceCapabilities && i.sourceCapabilities.firesTouchEvents)) { if (o)Ht.call(this, e, i); else if (n && Yt.call(this, i)) return; this.callback(t, e, i); } }, destroy() { this.touch.destroy(), this.mouse.destroy(); } }); const Gt = N(l.style, 'touchAction'); const Vt = Gt !== a; const Ut = 'compute'; const qt = 'auto'; const Xt = 'manipulation'; const Zt = 'none'; const Kt = 'pan-x'; const $t = 'pan-y'; const Jt = ee(); function Qt(t, e) { this.manager = t, this.set(e); } function te(t) { if (O(t, Zt)) return Zt; const e = O(t, Kt); const i = O(t, $t); return e && i ? Zt : e || i ? e ? Kt : $t : O(t, Xt) ? Xt : qt; } function ee() { if (!Vt) return !1; const t = {}; const e = n.CSS && n.CSS.supports; return ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach((i) => { t[i] = !e || n.CSS.supports('touch-action', i); }), t; }Qt.prototype = {
          set(t) { t == Ut && (t = this.compute()), Vt && this.manager.element.style && Jt[t] && (this.manager.element.style[Gt] = t), this.actions = t.toLowerCase().trim(); }, update() { this.set(this.manager.options.touchAction); }, compute() { let t = []; return g(this.manager.recognizers, (e) => { k(e.options.enable, [e]) && (t = t.concat(e.getTouchAction())); }), te(t.join(' ')); }, preventDefaults(t) { const e = t.srcEvent; const i = t.offsetDirection; if (this.manager.session.prevented)e.preventDefault(); else { const o = this.actions; const n = O(o, Zt) && !Jt[Zt]; const s = O(o, $t) && !Jt[$t]; const r = O(o, Kt) && !Jt[Kt]; if (n) { const a = t.pointers.length === 1; const h = t.distance < 2; const d = t.deltaTime < 250; if (a && h && d) return; } if (!r || !s) return n || s && i & et || r && i & it ? this.preventSrc(e) : void 0; } }, preventSrc(t) { this.manager.session.prevented = !0, t.preventDefault(); },
        }; const ie = 1; const oe = 2; const ne = 4; const se = 8; const re = se; const ae = 16; const he = 32; function de(t) { this.options = h({}, this.defaults, t || {}), this.id = A(), this.manager = null, this.options.enable = D(this.options.enable, !0), this.state = ie, this.simultaneous = {}, this.requireFail = []; } function le(t) { return t & ae ? 'cancel' : t & se ? 'end' : t & ne ? 'move' : t & oe ? 'start' : ''; } function ue(t) { return t == tt ? 'down' : t == Q ? 'up' : t == $ ? 'left' : t == J ? 'right' : ''; } function ce(t, e) { const i = e.manager; return i ? i.get(t) : t; } function pe() { de.apply(this, arguments); } function fe() { pe.apply(this, arguments), this.pX = null, this.pY = null; } function me() { pe.apply(this, arguments); } function ve() { de.apply(this, arguments), this._timer = null, this._input = null; } function ge() { pe.apply(this, arguments); } function ye() { pe.apply(this, arguments); } function be() { de.apply(this, arguments), this.pTime = !1, this.pCenter = !1, this._timer = null, this._input = null, this.count = 0; } function _e(t, e) { return e = e || {}, e.recognizers = D(e.recognizers, _e.defaults.preset), new ke(t, e); }de.prototype = {
          defaults: {}, set(t) { return h(this.options, t), this.manager && this.manager.touchAction.update(), this; }, recognizeWith(t) { if (v(t, 'recognizeWith', this)) return this; const e = this.simultaneous; return t = ce(t, this), e[t.id] || (e[t.id] = t, t.recognizeWith(this)), this; }, dropRecognizeWith(t) { return v(t, 'dropRecognizeWith', this) ? this : (t = ce(t, this), delete this.simultaneous[t.id], this); }, requireFailure(t) { if (v(t, 'requireFailure', this)) return this; const e = this.requireFail; return t = ce(t, this), T(e, t) === -1 && (e.push(t), t.requireFailure(this)), this; }, dropRequireFailure(t) { if (v(t, 'dropRequireFailure', this)) return this; t = ce(t, this); const e = T(this.requireFail, t); return e > -1 && this.requireFail.splice(e, 1), this; }, hasRequireFailures() { return this.requireFail.length > 0; }, canRecognizeWith(t) { return !!this.simultaneous[t.id]; }, emit(t) { const e = this; const i = this.state; function o(i) { e.manager.emit(i, t); }i < se && o(e.options.event + le(i)), o(e.options.event), t.additionalEvent && o(t.additionalEvent), i >= se && o(e.options.event + le(i)); }, tryEmit(t) { if (this.canEmit()) return this.emit(t); this.state = he; }, canEmit() { let t = 0; while (t < this.requireFail.length) { if (!(this.requireFail[t].state & (he | ie))) return !1; t++; } return !0; }, recognize(t) { const e = h({}, t); if (!k(this.options.enable, [this, e])) return this.reset(), void (this.state = he); this.state & (re | ae | he) && (this.state = ie), this.state = this.process(e), this.state & (oe | ne | se | ae) && this.tryEmit(e); }, process(t) {}, getTouchAction() {}, reset() {},
        }, w(pe, de, { defaults: { pointers: 1 }, attrTest(t) { const e = this.options.pointers; return e === 0 || t.pointers.length === e; }, process(t) { const e = this.state; const i = t.eventType; const o = e & (oe | ne); const n = this.attrTest(t); return o && (i & Z || !n) ? e | ae : o || n ? i & X ? e | se : e & oe ? e | ne : oe : he; } }), w(fe, pe, {
          defaults: {
            event: 'pan', threshold: 10, pointers: 1, direction: ot,
          },
          getTouchAction() { const t = this.options.direction; const e = []; return t & et && e.push($t), t & it && e.push(Kt), e; },
          directionTest(t) { const e = this.options; let i = !0; let o = t.distance; let n = t.direction; const s = t.deltaX; const r = t.deltaY; return n & e.direction || (e.direction & et ? (n = s === 0 ? K : s < 0 ? $ : J, i = s != this.pX, o = Math.abs(t.deltaX)) : (n = r === 0 ? K : r < 0 ? Q : tt, i = r != this.pY, o = Math.abs(t.deltaY))), t.direction = n, i && o > e.threshold && n & e.direction; },
          attrTest(t) { return pe.prototype.attrTest.call(this, t) && (this.state & oe || !(this.state & oe) && this.directionTest(t)); },
          emit(t) { this.pX = t.deltaX, this.pY = t.deltaY; const e = ue(t.direction); e && (t.additionalEvent = this.options.event + e), this._super.emit.call(this, t); },
        }), w(me, pe, {
          defaults: { event: 'pinch', threshold: 0, pointers: 2 }, getTouchAction() { return [Zt]; }, attrTest(t) { return this._super.attrTest.call(this, t) && (Math.abs(t.scale - 1) > this.options.threshold || this.state & oe); }, emit(t) { if (t.scale !== 1) { const e = t.scale < 1 ? 'in' : 'out'; t.additionalEvent = this.options.event + e; } this._super.emit.call(this, t); },
        }), w(ve, de, {
          defaults: {
            event: 'press', pointers: 1, time: 251, threshold: 9,
          },
          getTouchAction() { return [qt]; },
          process(t) { const e = this.options; const i = t.pointers.length === e.pointers; const o = t.distance < e.threshold; const n = t.deltaTime > e.time; if (this._input = t, !o || !i || t.eventType & (X | Z) && !n) this.reset(); else if (t.eventType & U) this.reset(), this._timer = m(function () { this.state = re, this.tryEmit(); }, e.time, this); else if (t.eventType & X) return re; return he; },
          reset() { clearTimeout(this._timer); },
          emit(t) { this.state === re && (t && t.eventType & X ? this.manager.emit(`${this.options.event}up`, t) : (this._input.timeStamp = f(), this.manager.emit(this.options.event, this._input))); },
        }), w(ge, pe, { defaults: { event: 'rotate', threshold: 0, pointers: 2 }, getTouchAction() { return [Zt]; }, attrTest(t) { return this._super.attrTest.call(this, t) && (Math.abs(t.rotation) > this.options.threshold || this.state & oe); } }), w(ye, pe, {
          defaults: {
            event: 'swipe', threshold: 10, velocity: 0.3, direction: et | it, pointers: 1,
          },
          getTouchAction() { return fe.prototype.getTouchAction.call(this); },
          attrTest(t) { let e; const i = this.options.direction; return i & (et | it) ? e = t.overallVelocity : i & et ? e = t.overallVelocityX : i & it && (e = t.overallVelocityY), this._super.attrTest.call(this, t) && i & t.offsetDirection && t.distance > this.options.threshold && t.maxPointers == this.options.pointers && p(e) > this.options.velocity && t.eventType & X; },
          emit(t) { const e = ue(t.offsetDirection); e && this.manager.emit(this.options.event + e, t), this.manager.emit(this.options.event, t); },
        }), w(be, de, {
          defaults: {
            event: 'tap', pointers: 1, taps: 1, interval: 300, time: 250, threshold: 9, posThreshold: 10,
          },
          getTouchAction() { return [Xt]; },
          process(t) { const e = this.options; const i = t.pointers.length === e.pointers; const o = t.distance < e.threshold; const n = t.deltaTime < e.time; if (this.reset(), t.eventType & U && this.count === 0) return this.failTimeout(); if (o && n && i) { if (t.eventType != X) return this.failTimeout(); const s = !this.pTime || t.timeStamp - this.pTime < e.interval; const r = !this.pCenter || vt(this.pCenter, t.center) < e.posThreshold; this.pTime = t.timeStamp, this.pCenter = t.center, r && s ? this.count += 1 : this.count = 1, this._input = t; const a = this.count % e.taps; if (a === 0) return this.hasRequireFailures() ? (this._timer = m(function () { this.state = re, this.tryEmit(); }, e.interval, this), oe) : re; } return he; },
          failTimeout() { return this._timer = m(function () { this.state = he; }, this.options.interval, this), he; },
          reset() { clearTimeout(this._timer); },
          emit() { this.state == re && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input)); },
        }), _e.VERSION = '2.0.7', _e.defaults = {
          domEvents: !1,
          touchAction: Ut,
          enable: !0,
          inputTarget: null,
          inputClass: null,
          preset: [[ge, { enable: !1 }], [me, { enable: !1 }, ['rotate']], [ye, { direction: et }], [fe, { direction: et }, ['swipe']], [be], [be, { event: 'doubletap', taps: 2 }, ['tap']], [ve]],
          cssProps: {
            userSelect: 'none', touchSelect: 'none', touchCallout: 'none', contentZooming: 'none', userDrag: 'none', tapHighlightColor: 'rgba(0,0,0,0)',
          },
        }; const we = 1; const xe = 2; function ke(t, e) { this.options = h({}, _e.defaults, e || {}), this.options.inputTarget = this.options.inputTarget || t, this.handlers = {}, this.session = {}, this.recognizers = [], this.oldCssProps = {}, this.element = t, this.input = at(this), this.touchAction = new Qt(this, this.options.touchAction), De(this, !0), g(this.options.recognizers, function (t) { const e = this.add(new t[0](t[1])); t[2] && e.recognizeWith(t[2]), t[3] && e.requireFailure(t[3]); }, this); } function De(t, e) { let i; const o = t.element; o.style && (g(t.options.cssProps, (n, s) => { i = N(o.style, s), e ? (t.oldCssProps[i] = o.style[i], o.style[i] = n) : o.style[i] = t.oldCssProps[i] || ''; }), e || (t.oldCssProps = {})); } function Se(t, e) { const i = s.createEvent('Event'); i.initEvent(t, !0, !0), i.gesture = e, e.target.dispatchEvent(i); }ke.prototype = {
          set(t) { return h(this.options, t), t.touchAction && this.touchAction.update(), t.inputTarget && (this.input.destroy(), this.input.target = t.inputTarget, this.input.init()), this; }, stop(t) { this.session.stopped = t ? xe : we; }, recognize(t) { const e = this.session; if (!e.stopped) { let i; this.touchAction.preventDefaults(t); const o = this.recognizers; let n = e.curRecognizer; (!n || n && n.state & re) && (n = e.curRecognizer = null); let s = 0; while (s < o.length)i = o[s], e.stopped === xe || n && i != n && !i.canRecognizeWith(n) ? i.reset() : i.recognize(t), !n && i.state & (oe | ne | se) && (n = e.curRecognizer = i), s++; } }, get(t) { if (t instanceof de) return t; for (let e = this.recognizers, i = 0; i < e.length; i++) if (e[i].options.event == t) return e[i]; return null; }, add(t) { if (v(t, 'add', this)) return this; const e = this.get(t.options.event); return e && this.remove(e), this.recognizers.push(t), t.manager = this, this.touchAction.update(), t; }, remove(t) { if (v(t, 'remove', this)) return this; if (t = this.get(t), t) { const e = this.recognizers; const i = T(e, t); i !== -1 && (e.splice(i, 1), this.touchAction.update()); } return this; }, on(t, e) { if (t !== a && e !== a) { const i = this.handlers; return g(E(t), (t) => { i[t] = i[t] || [], i[t].push(e); }), this; } }, off(t, e) { if (t !== a) { const i = this.handlers; return g(E(t), (t) => { e ? i[t] && i[t].splice(T(i[t], e), 1) : delete i[t]; }), this; } }, emit(t, e) { this.options.domEvents && Se(t, e); const i = this.handlers[t] && this.handlers[t].slice(); if (i && i.length) { e.type = t, e.preventDefault = function () { e.srcEvent.preventDefault(); }; let o = 0; while (o < i.length)i[o](e), o++; } }, destroy() { this.element && De(this, !1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null; },
        }, h(_e, {
          INPUT_START: U, INPUT_MOVE: q, INPUT_END: X, INPUT_CANCEL: Z, STATE_POSSIBLE: ie, STATE_BEGAN: oe, STATE_CHANGED: ne, STATE_ENDED: se, STATE_RECOGNIZED: re, STATE_CANCELLED: ae, STATE_FAILED: he, DIRECTION_NONE: K, DIRECTION_LEFT: $, DIRECTION_RIGHT: J, DIRECTION_UP: Q, DIRECTION_DOWN: tt, DIRECTION_HORIZONTAL: et, DIRECTION_VERTICAL: it, DIRECTION_ALL: ot, Manager: ke, Input: rt, TouchAction: Qt, TouchInput: zt, MouseInput: kt, PointerEventInput: Ot, TouchMouseInput: jt, SingleTouchInput: It, Recognizer: de, AttrRecognizer: pe, Tap: be, Pan: fe, Swipe: ye, Pinch: me, Rotate: ge, Press: ve, on: S, off: C, each: g, merge: _, extend: b, assign: h, inherit: w, bindFn: x, prefixed: N,
        }); const Ce = typeof n !== 'undefined' ? n : typeof self !== 'undefined' ? self : {}; Ce.Hammer = _e, o = function () { return _e; }.call(e, i, e, t), o === a || (t.exports = o);
      }(window, document));
    }, function (t, e, i) {
      e.util = i(2), e.DOMutil = i(14), e.DataSet = i(11), e.DataView = i(12), e.Queue = i(43), e.Timeline = i(178), e.Graph2d = i(180), e.timeline = {
        Core: i(65),
        DateUtil: i(36),
        Range: i(64),
        stack: i(100),
        TimeStep: i(66),
        components: {
          items: {
            Item: i(38), BackgroundItem: i(103), BoxItem: i(101), PointItem: i(102), RangeItem: i(70),
          },
          BackgroundGroup: i(69),
          Component: i(16),
          CurrentTime: i(67),
          CustomTime: i(46),
          DataAxis: i(107),
          DataScale: i(108),
          GraphGroup: i(109),
          Group: i(68),
          ItemSet: i(99),
          Legend: i(112),
          LineGraph: i(106),
          TimeAxis: i(45),
        },
      }, e.moment = i(9), e.Hammer = i(10), e.keycharm = i(35);
    }, function (t, e, i) {
      const o = i(9); const n = i(2); const s = i(11); const r = i(12); const a = i(64); const h = i(65); const d = i(45); const l = i(67); const u = i(46); const c = i(99); const p = i(15).printStyle; const f = i(105).allOptions; const m = i(105).configureOptions; const v = i(71).default; const g = i(15).default; function y(t, e, i, h) {
        if (!(this instanceof y)) throw new SyntaxError('Constructor must be called with the new operator'); if (!(Array.isArray(i) || i instanceof s || i instanceof r) && i instanceof Object) { const u = h; h = i, i = u; }h && h.throttleRedraw && console.warn('Timeline option "throttleRedraw" is DEPRICATED and no longer supported. It will be removed in the next MAJOR release.'); const p = this; if (this.defaultOptions = {
          start: null, end: null, autoResize: !0, orientation: { axis: 'bottom', item: 'bottom' }, moment: o, width: null, height: null, maxHeight: null, minHeight: null,
        }, this.options = n.deepExtend({}, this.defaultOptions), this._create(t), !h || h && typeof h.rtl === 'undefined') { this.dom.root.style.visibility = 'hidden'; let f; let m = this.dom.root; while (!f && m)f = window.getComputedStyle(m, null).direction, m = m.parentElement; this.options.rtl = f && f.toLowerCase() == 'rtl'; } else this.options.rtl = h.rtl; this.options.rollingMode = h && h.rollingMode, this.options.onInitialDrawComplete = h && h.onInitialDrawComplete, this.components = [], this.body = {
          dom: this.dom,
          domProps: this.props,
          emitter: { on: this.on.bind(this), off: this.off.bind(this), emit: this.emit.bind(this) },
          hiddenDates: [],
          util: {
            getScale() { return p.timeAxis.step.scale; }, getStep() { return p.timeAxis.step.step; }, toScreen: p._toScreen.bind(p), toGlobalScreen: p._toGlobalScreen.bind(p), toTime: p._toTime.bind(p), toGlobalTime: p._toGlobalTime.bind(p),
          },
        }, this.range = new a(this.body, this.options), this.components.push(this.range), this.body.range = this.range, this.timeAxis = new d(this.body, this.options), this.timeAxis2 = null, this.components.push(this.timeAxis), this.currentTime = new l(this.body, this.options), this.components.push(this.currentTime), this.itemSet = new c(this.body, this.options), this.components.push(this.itemSet), this.itemsData = null, this.groupsData = null, this.dom.root.onclick = function (t) { p.emit('click', p.getEventProperties(t)); }, this.dom.root.ondblclick = function (t) { p.emit('doubleClick', p.getEventProperties(t)); }, this.dom.root.oncontextmenu = function (t) { p.emit('contextmenu', p.getEventProperties(t)); }, this.dom.root.onmouseover = function (t) { p.emit('mouseOver', p.getEventProperties(t)); }, window.PointerEvent ? (this.dom.root.onpointerdown = function (t) { p.emit('mouseDown', p.getEventProperties(t)); }, this.dom.root.onpointermove = function (t) { p.emit('mouseMove', p.getEventProperties(t)); }, this.dom.root.onpointerup = function (t) { p.emit('mouseUp', p.getEventProperties(t)); }) : (this.dom.root.onmousemove = function (t) { p.emit('mouseMove', p.getEventProperties(t)); }, this.dom.root.onmousedown = function (t) { p.emit('mouseDown', p.getEventProperties(t)); }, this.dom.root.onmouseup = function (t) { p.emit('mouseUp', p.getEventProperties(t)); }), this.initialFitDone = !1, this.on('changed', function () { if (this.itemsData != null && !this.options.rollingMode) { if (!p.initialFitDone) if (p.initialFitDone = !0, void 0 != p.options.start || void 0 != p.options.end) { if (void 0 == p.options.start || void 0 == p.options.end) var t = p.getItemRange(); const e = void 0 != p.options.start ? p.options.start : t.min; const i = void 0 != p.options.end ? p.options.end : t.max; p.setWindow(e, i, { animation: !1 }); } else p.fit({ animation: !1 }); !p.initialDrawDone && p.initialRangeChangeDone && (p.initialDrawDone = !0, p.dom.root.style.visibility = 'visible', p.options.onInitialDrawComplete && setTimeout(() => p.options.onInitialDrawComplete(), 0)); } }), h && this.setOptions(h), i && this.setGroups(i), e && this.setItems(e), this._redraw();
      } function b(t) { return n.convert(t.data.start, 'Date').valueOf(); } function _(t) { const e = void 0 != t.data.end ? t.data.end : t.data.start; return n.convert(e, 'Date').valueOf(); } function w(t, e) { const i = t.props.leftContainer.height; const o = t.props.left.height; const n = e.parent; let s = n.top; let r = !0; const a = t.timeAxis.options.orientation.axis; const h = function () { return a == 'bottom' ? n.height - e.top - e.height : e.top; }; const d = -1 * t._getScrollTop(); const l = s + h(); const u = e.height; return l < d ? s + i <= s + h() + u && (s += h() - t.itemSet.options.margin.item.vertical) : l + u > d + i ? s += h() + u - i + t.itemSet.options.margin.item.vertical : r = !1, s = Math.min(s, o - i), { shouldScroll: r, scrollOffset: s, itemTop: l }; }y.prototype = new h(), y.prototype._createConfigurator = function () { return new v(this, this.dom.container, m); }, y.prototype.redraw = function () { this.itemSet && this.itemSet.markDirty({ refreshItems: !0 }), this._redraw(); }, y.prototype.setOptions = function (t) { const e = g.validate(t, f); if (!0 === e && console.log('%cErrors have been found in the supplied options object.', p), h.prototype.setOptions.call(this, t), 'type' in t && t.type !== this.options.type) { this.options.type = t.type; const i = this.itemsData; if (i) { const o = this.getSelection(); this.setItems(null), this.setItems(i), this.setSelection(o); } } }, y.prototype.setItems = function (t) { let e; e = t ? t instanceof s || t instanceof r ? t : new s(t, { type: { start: 'Date', end: 'Date' } }) : null, this.itemsData = e, this.itemSet && this.itemSet.setItems(e); }, y.prototype.setGroups = function (t) { let e; if (t) { const i = function (t) { return !1 !== t.visible; }; e = t instanceof s || t instanceof r ? new r(t, { filter: i }) : new s(t.filter(i)); } else e = null; this.groupsData = e, this.itemSet.setGroups(e); }, y.prototype.setData = function (t) { t && t.groups && this.setGroups(t.groups), t && t.items && this.setItems(t.items); }, y.prototype.setSelection = function (t, e) { this.itemSet && this.itemSet.setSelection(t), e && e.focus && this.focus(t, e); }, y.prototype.getSelection = function () { return this.itemSet && this.itemSet.getSelection() || []; }, y.prototype.focus = function (t, e) { if (this.itemsData && void 0 != t) { const i = Array.isArray(t) ? t : [t]; const o = this.itemsData.getDataSet().get(i, { type: { start: 'Date', end: 'Date' } }); let n = null; let s = null; if (o.forEach((t) => { const e = t.start.valueOf(); const i = 'end' in t ? t.end.valueOf() : t.start.valueOf(); (n === null || e < n) && (n = e), (s === null || i > s) && (s = i); }), n !== null && s !== null) { const r = this; const a = this.itemSet.items[i[0]]; let h = -1 * this._getScrollTop(); let d = null; const l = function (t, e, i) { const o = w(r, a); if (d || (d = o), d.itemTop != o.itemTop || d.shouldScroll) { d.itemTop != o.itemTop && o.shouldScroll && (d = o, h = -1 * r._getScrollTop()); const n = h; const s = d.scrollOffset; const l = i ? s : n + (s - n) * t; r._setScrollTop(-l), e || r._redraw(); } }; const u = function () { const t = w(r, a); t.shouldScroll && t.itemTop != d.itemTop && (r._setScrollTop(-t.scrollOffset), r._redraw()); }; const c = function () { u(), setTimeout(u, 100); }; const p = (n + s) / 2; const f = Math.max(this.range.end - this.range.start, 1.1 * (s - n)); const m = !e || void 0 === e.animation || e.animation; m || (d = { shouldScroll: !1, scrollOffset: -1, itemTop: -1 }), this.range.setRange(p - f / 2, p + f / 2, { animation: m }, c, l); } } }, y.prototype.fit = function (t, e) { let i; const o = !t || void 0 === t.animation || t.animation; const n = this.itemsData && this.itemsData.getDataSet(); n.length === 1 && void 0 === n.get()[0].end ? (i = this.getDataRange(), this.moveTo(i.min.valueOf(), { animation: o }, e)) : (i = this.getItemRange(), this.range.setRange(i.min, i.max, { animation: o }, e)); }, y.prototype.getItemRange = function () { const t = this.getDataRange(); let e = t.min !== null ? t.min.valueOf() : null; let i = t.max !== null ? t.max.valueOf() : null; let o = null; let s = null; if (e != null && i != null) { let r = i - e; r <= 0 && (r = 10); const a = r / this.props.center.width; const h = {}; let d = 0; n.forEach(this.itemSet.items, (t, e) => { if (t.groupShowing) { const i = !0; h[e] = t.redraw(i), d = h[e].length; } }); const l = d > 0; if (l) for (var u = 0; u < d; u++)n.forEach(h, (t) => { t[u](); }); if (n.forEach(this.itemSet.items, (t) => { let n; let r; const h = b(t); const d = _(t); this.options.rtl ? (n = h - (t.getWidthRight() + 10) * a, r = d + (t.getWidthLeft() + 10) * a) : (n = h - (t.getWidthLeft() + 10) * a, r = d + (t.getWidthRight() + 10) * a), n < e && (e = n, o = t), r > i && (i = r, s = t); }), o && s) { const c = o.getWidthLeft() + 10; const p = s.getWidthRight() + 10; const f = this.props.center.width - c - p; f > 0 && (this.options.rtl ? (e = b(o) - p * r / f, i = _(s) + c * r / f) : (e = b(o) - c * r / f, i = _(s) + p * r / f)); } } return { min: e != null ? new Date(e) : null, max: i != null ? new Date(i) : null }; }, y.prototype.getDataRange = function () { let t = null; let e = null; const i = this.itemsData && this.itemsData.getDataSet(); return i && i.forEach((i) => { const o = n.convert(i.start, 'Date').valueOf(); const s = n.convert(void 0 != i.end ? i.end : i.start, 'Date').valueOf(); (t === null || o < t) && (t = o), (e === null || s > e) && (e = s); }), { min: t != null ? new Date(t) : null, max: e != null ? new Date(e) : null }; }, y.prototype.getEventProperties = function (t) {
        let e; const i = t.center ? t.center.x : t.clientX; const o = t.center ? t.center.y : t.clientY; e = this.options.rtl ? n.getAbsoluteRight(this.dom.centerContainer) - i : i - n.getAbsoluteLeft(this.dom.centerContainer); const s = o - n.getAbsoluteTop(this.dom.centerContainer); const r = this.itemSet.itemFromTarget(t); const a = this.itemSet.groupFromTarget(t); const h = u.customTimeFromTarget(t); const d = this.itemSet.options.snap || null; const l = this.body.util.getScale(); const c = this.body.util.getStep(); const p = this._toTime(e); const f = d ? d(p, l, c) : p; const m = n.getTarget(t); let v = null; return r != null ? v = 'item' : h != null ? v = 'custom-time' : n.hasParent(m, this.timeAxis.dom.foreground) ? v = 'axis' : this.timeAxis2 && n.hasParent(m, this.timeAxis2.dom.foreground) ? v = 'axis' : n.hasParent(m, this.itemSet.dom.labelSet) ? v = 'group-label' : n.hasParent(m, this.currentTime.bar) ? v = 'current-time' : n.hasParent(m, this.dom.center) && (v = 'background'), {
          event: t, item: r ? r.id : null, group: a ? a.groupId : null, what: v, pageX: t.srcEvent ? t.srcEvent.pageX : t.pageX, pageY: t.srcEvent ? t.srcEvent.pageY : t.pageY, x: e, y: s, time: p, snappedTime: f,
        };
      }, y.prototype.toggleRollingMode = function () { this.range.rolling ? this.range.stopRolling() : (void 0 == this.options.rollingMode && this.setOptions(this.options), this.range.startRolling()); }, t.exports = y;
    }, function (t, e, i) {
      Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(19); const n = d(o); const s = i(0); const r = d(s); const a = i(1); const h = d(a); function d(t) { return t && t.__esModule ? t : { default: t }; } const l = i(10); const u = i(37); const c = i(2); const p = (function () {
        function t() {
          const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1; (0, r.default)(this, t), this.pixelRatio = e, this.generated = !1, this.centerCoordinates = { x: 144.5, y: 144.5 }, this.r = 289 * 0.49, this.color = {
            r: 255, g: 255, b: 255, a: 1,
          }, this.hueCircle = void 0, this.initialColor = {
            r: 255, g: 255, b: 255, a: 1,
          }, this.previousColor = void 0, this.applied = !1, this.updateCallback = function () {}, this.closeCallback = function () {}, this._create();
        } return (0, h.default)(t, [{ key: 'insertTo', value(t) { void 0 !== this.hammer && (this.hammer.destroy(), this.hammer = void 0), this.container = t, this.container.appendChild(this.frame), this._bindHammer(), this._setSize(); } }, { key: 'setUpdateCallback', value(t) { if (typeof t !== 'function') throw new Error('Function attempted to set as colorPicker update callback is not a function.'); this.updateCallback = t; } }, { key: 'setCloseCallback', value(t) { if (typeof t !== 'function') throw new Error('Function attempted to set as colorPicker closing callback is not a function.'); this.closeCallback = t; } }, {
          key: '_isColorString',
          value(t) {
            const e = {
              black: '#000000', navy: '#000080', darkblue: '#00008B', mediumblue: '#0000CD', blue: '#0000FF', darkgreen: '#006400', green: '#008000', teal: '#008080', darkcyan: '#008B8B', deepskyblue: '#00BFFF', darkturquoise: '#00CED1', mediumspringgreen: '#00FA9A', lime: '#00FF00', springgreen: '#00FF7F', aqua: '#00FFFF', cyan: '#00FFFF', midnightblue: '#191970', dodgerblue: '#1E90FF', lightseagreen: '#20B2AA', forestgreen: '#228B22', seagreen: '#2E8B57', darkslategray: '#2F4F4F', limegreen: '#32CD32', mediumseagreen: '#3CB371', turquoise: '#40E0D0', royalblue: '#4169E1', steelblue: '#4682B4', darkslateblue: '#483D8B', mediumturquoise: '#48D1CC', indigo: '#4B0082', darkolivegreen: '#556B2F', cadetblue: '#5F9EA0', cornflowerblue: '#6495ED', mediumaquamarine: '#66CDAA', dimgray: '#696969', slateblue: '#6A5ACD', olivedrab: '#6B8E23', slategray: '#708090', lightslategray: '#778899', mediumslateblue: '#7B68EE', lawngreen: '#7CFC00', chartreuse: '#7FFF00', aquamarine: '#7FFFD4', maroon: '#800000', purple: '#800080', olive: '#808000', gray: '#808080', skyblue: '#87CEEB', lightskyblue: '#87CEFA', blueviolet: '#8A2BE2', darkred: '#8B0000', darkmagenta: '#8B008B', saddlebrown: '#8B4513', darkseagreen: '#8FBC8F', lightgreen: '#90EE90', mediumpurple: '#9370D8', darkviolet: '#9400D3', palegreen: '#98FB98', darkorchid: '#9932CC', yellowgreen: '#9ACD32', sienna: '#A0522D', brown: '#A52A2A', darkgray: '#A9A9A9', lightblue: '#ADD8E6', greenyellow: '#ADFF2F', paleturquoise: '#AFEEEE', lightsteelblue: '#B0C4DE', powderblue: '#B0E0E6', firebrick: '#B22222', darkgoldenrod: '#B8860B', mediumorchid: '#BA55D3', rosybrown: '#BC8F8F', darkkhaki: '#BDB76B', silver: '#C0C0C0', mediumvioletred: '#C71585', indianred: '#CD5C5C', peru: '#CD853F', chocolate: '#D2691E', tan: '#D2B48C', lightgrey: '#D3D3D3', palevioletred: '#D87093', thistle: '#D8BFD8', orchid: '#DA70D6', goldenrod: '#DAA520', crimson: '#DC143C', gainsboro: '#DCDCDC', plum: '#DDA0DD', burlywood: '#DEB887', lightcyan: '#E0FFFF', lavender: '#E6E6FA', darksalmon: '#E9967A', violet: '#EE82EE', palegoldenrod: '#EEE8AA', lightcoral: '#F08080', khaki: '#F0E68C', aliceblue: '#F0F8FF', honeydew: '#F0FFF0', azure: '#F0FFFF', sandybrown: '#F4A460', wheat: '#F5DEB3', beige: '#F5F5DC', whitesmoke: '#F5F5F5', mintcream: '#F5FFFA', ghostwhite: '#F8F8FF', salmon: '#FA8072', antiquewhite: '#FAEBD7', linen: '#FAF0E6', lightgoldenrodyellow: '#FAFAD2', oldlace: '#FDF5E6', red: '#FF0000', fuchsia: '#FF00FF', magenta: '#FF00FF', deeppink: '#FF1493', orangered: '#FF4500', tomato: '#FF6347', hotpink: '#FF69B4', coral: '#FF7F50', darkorange: '#FF8C00', lightsalmon: '#FFA07A', orange: '#FFA500', lightpink: '#FFB6C1', pink: '#FFC0CB', gold: '#FFD700', peachpuff: '#FFDAB9', navajowhite: '#FFDEAD', moccasin: '#FFE4B5', bisque: '#FFE4C4', mistyrose: '#FFE4E1', blanchedalmond: '#FFEBCD', papayawhip: '#FFEFD5', lavenderblush: '#FFF0F5', seashell: '#FFF5EE', cornsilk: '#FFF8DC', lemonchiffon: '#FFFACD', floralwhite: '#FFFAF0', snow: '#FFFAFA', yellow: '#FFFF00', lightyellow: '#FFFFE0', ivory: '#FFFFF0', white: '#FFFFFF',
            }; if (typeof t === 'string') return e[t];
          }, 
        }, {
          key: 'setColor',
          value(t) {
            const e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]; if (t !== 'none') {
              let i = void 0; const o = this._isColorString(t); if (void 0 !== o && (t = o), !0 === c.isString(t)) {
                if (!0 === c.isValidRGB(t)) {
                  const s = t.substr(4).substr(0, t.length - 5).split(','); i = {
                    r: s[0], g: s[1], b: s[2], a: 1,
                  };
                } else if (!0 === c.isValidRGBA(t)) {
                  const r = t.substr(5).substr(0, t.length - 6).split(','); i = {
                    r: r[0], g: r[1], b: r[2], a: r[3],
                  };
                } else if (!0 === c.isValidHex(t)) {
                  const a = c.hexToRGB(t); i = {
                    r: a.r, g: a.g, b: a.b, a: 1,
                  };
                }
              } else if (t instanceof Object && void 0 !== t.r && void 0 !== t.g && void 0 !== t.b) {
                const h = void 0 !== t.a ? t.a : '1.0'; i = {
                  r: t.r, g: t.g, b: t.b, a: h,
                };
              } if (void 0 === i) throw new Error(`Unknown color passed to the colorPicker. Supported are strings: rgb, hex, rgba. Object: rgb ({r:r,g:g,b:b,[a:a]}). Supplied: ${(0, n.default)(t)}`); this._setColor(i, e);
            }
          }, 
        }, { key: 'show', value() { void 0 !== this.closeCallback && (this.closeCallback(), this.closeCallback = void 0), this.applied = !1, this.frame.style.display = 'block', this._generateHueCircle(); } }, { key: '_hide', value() { const t = this; const e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0]; !0 === e && (this.previousColor = c.extend({}, this.color)), !0 === this.applied && this.updateCallback(this.initialColor), this.frame.style.display = 'none', setTimeout(() => { void 0 !== t.closeCallback && (t.closeCallback(), t.closeCallback = void 0); }, 0); } }, { key: '_save', value() { this.updateCallback(this.color), this.applied = !1, this._hide(); } }, { key: '_apply', value() { this.applied = !0, this.updateCallback(this.color), this._updatePicker(this.color); } }, { key: '_loadLast', value() { void 0 !== this.previousColor ? this.setColor(this.previousColor, !1) : alert('There is no last color to load...'); } }, { key: '_setColor', value(t) { const e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]; !0 === e && (this.initialColor = c.extend({}, t)), this.color = t; const i = c.RGBToHSV(t.r, t.g, t.b); const o = 2 * Math.PI; const n = this.r * i.s; const s = this.centerCoordinates.x + n * Math.sin(o * i.h); const r = this.centerCoordinates.y + n * Math.cos(o * i.h); this.colorPickerSelector.style.left = `${s - 0.5 * this.colorPickerSelector.clientWidth}px`, this.colorPickerSelector.style.top = `${r - 0.5 * this.colorPickerSelector.clientHeight}px`, this._updatePicker(t); } }, { key: '_setOpacity', value(t) { this.color.a = t / 100, this._updatePicker(this.color); } }, { key: '_setBrightness', value(t) { const e = c.RGBToHSV(this.color.r, this.color.g, this.color.b); e.v = t / 100; const i = c.HSVToRGB(e.h, e.s, e.v); i.a = this.color.a, this.color = i, this._updatePicker(); } }, { key: '_updatePicker', value() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.color; const e = c.RGBToHSV(t.r, t.g, t.b); const i = this.colorPickerCanvas.getContext('2d'); void 0 === this.pixelRation && (this.pixelRatio = (window.devicePixelRatio || 1) / (i.webkitBackingStorePixelRatio || i.mozBackingStorePixelRatio || i.msBackingStorePixelRatio || i.oBackingStorePixelRatio || i.backingStorePixelRatio || 1)), i.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0); const o = this.colorPickerCanvas.clientWidth; const n = this.colorPickerCanvas.clientHeight; i.clearRect(0, 0, o, n), i.putImageData(this.hueCircle, 0, 0), i.fillStyle = `rgba(0,0,0,${1 - e.v })`, i.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r), i.fill(), this.brightnessRange.value = 100 * e.v, this.opacityRange.value = 100 * t.a, this.initialColorDiv.style.backgroundColor = `rgba(${this.initialColor.r },${this.initialColor.g },${this.initialColor.b },${this.initialColor.a })`, this.newColorDiv.style.backgroundColor = `rgba(${this.color.r },${this.color.g },${this.color.b },${this.color.a })`; } }, { key: '_setSize', value() { this.colorPickerCanvas.style.width = '100%', this.colorPickerCanvas.style.height = '100%', this.colorPickerCanvas.width = 289 * this.pixelRatio, this.colorPickerCanvas.height = 289 * this.pixelRatio; } }, { key: '_create', value() { if (this.frame = document.createElement('div'), this.frame.className = 'vis-color-picker', this.colorPickerDiv = document.createElement('div'), this.colorPickerSelector = document.createElement('div'), this.colorPickerSelector.className = 'vis-selector', this.colorPickerDiv.appendChild(this.colorPickerSelector), this.colorPickerCanvas = document.createElement('canvas'), this.colorPickerDiv.appendChild(this.colorPickerCanvas), this.colorPickerCanvas.getContext) { const t = this.colorPickerCanvas.getContext('2d'); this.pixelRatio = (window.devicePixelRatio || 1) / (t.webkitBackingStorePixelRatio || t.mozBackingStorePixelRatio || t.msBackingStorePixelRatio || t.oBackingStorePixelRatio || t.backingStorePixelRatio || 1), this.colorPickerCanvas.getContext('2d').setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0); } else { const e = document.createElement('DIV'); e.style.color = 'red', e.style.fontWeight = 'bold', e.style.padding = '10px', e.innerHTML = 'Error: your browser does not support HTML canvas', this.colorPickerCanvas.appendChild(e); } this.colorPickerDiv.className = 'vis-color', this.opacityDiv = document.createElement('div'), this.opacityDiv.className = 'vis-opacity', this.brightnessDiv = document.createElement('div'), this.brightnessDiv.className = 'vis-brightness', this.arrowDiv = document.createElement('div'), this.arrowDiv.className = 'vis-arrow', this.opacityRange = document.createElement('input'); try { this.opacityRange.type = 'range', this.opacityRange.min = '0', this.opacityRange.max = '100'; } catch (o) {} this.opacityRange.value = '100', this.opacityRange.className = 'vis-range', this.brightnessRange = document.createElement('input'); try { this.brightnessRange.type = 'range', this.brightnessRange.min = '0', this.brightnessRange.max = '100'; } catch (o) {} this.brightnessRange.value = '100', this.brightnessRange.className = 'vis-range', this.opacityDiv.appendChild(this.opacityRange), this.brightnessDiv.appendChild(this.brightnessRange); const i = this; this.opacityRange.onchange = function () { i._setOpacity(this.value); }, this.opacityRange.oninput = function () { i._setOpacity(this.value); }, this.brightnessRange.onchange = function () { i._setBrightness(this.value); }, this.brightnessRange.oninput = function () { i._setBrightness(this.value); }, this.brightnessLabel = document.createElement('div'), this.brightnessLabel.className = 'vis-label vis-brightness', this.brightnessLabel.innerHTML = 'brightness:', this.opacityLabel = document.createElement('div'), this.opacityLabel.className = 'vis-label vis-opacity', this.opacityLabel.innerHTML = 'opacity:', this.newColorDiv = document.createElement('div'), this.newColorDiv.className = 'vis-new-color', this.newColorDiv.innerHTML = 'new', this.initialColorDiv = document.createElement('div'), this.initialColorDiv.className = 'vis-initial-color', this.initialColorDiv.innerHTML = 'initial', this.cancelButton = document.createElement('div'), this.cancelButton.className = 'vis-button vis-cancel', this.cancelButton.innerHTML = 'cancel', this.cancelButton.onclick = this._hide.bind(this, !1), this.applyButton = document.createElement('div'), this.applyButton.className = 'vis-button vis-apply', this.applyButton.innerHTML = 'apply', this.applyButton.onclick = this._apply.bind(this), this.saveButton = document.createElement('div'), this.saveButton.className = 'vis-button vis-save', this.saveButton.innerHTML = 'save', this.saveButton.onclick = this._save.bind(this), this.loadButton = document.createElement('div'), this.loadButton.className = 'vis-button vis-load', this.loadButton.innerHTML = 'load last', this.loadButton.onclick = this._loadLast.bind(this), this.frame.appendChild(this.colorPickerDiv), this.frame.appendChild(this.arrowDiv), this.frame.appendChild(this.brightnessLabel), this.frame.appendChild(this.brightnessDiv), this.frame.appendChild(this.opacityLabel), this.frame.appendChild(this.opacityDiv), this.frame.appendChild(this.newColorDiv), this.frame.appendChild(this.initialColorDiv), this.frame.appendChild(this.cancelButton), this.frame.appendChild(this.applyButton), this.frame.appendChild(this.saveButton), this.frame.appendChild(this.loadButton); } }, { key: '_bindHammer', value() { const t = this; this.drag = {}, this.pinch = {}, this.hammer = new l(this.colorPickerCanvas), this.hammer.get('pinch').set({ enable: !0 }), u.onTouch(this.hammer, (e) => { t._moveSelector(e); }), this.hammer.on('tap', (e) => { t._moveSelector(e); }), this.hammer.on('panstart', (e) => { t._moveSelector(e); }), this.hammer.on('panmove', (e) => { t._moveSelector(e); }), this.hammer.on('panend', (e) => { t._moveSelector(e); }); } }, { key: '_generateHueCircle', value() { if (!1 === this.generated) { const t = this.colorPickerCanvas.getContext('2d'); void 0 === this.pixelRation && (this.pixelRatio = (window.devicePixelRatio || 1) / (t.webkitBackingStorePixelRatio || t.mozBackingStorePixelRatio || t.msBackingStorePixelRatio || t.oBackingStorePixelRatio || t.backingStorePixelRatio || 1)), t.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0); const e = this.colorPickerCanvas.clientWidth; const i = this.colorPickerCanvas.clientHeight; t.clearRect(0, 0, e, i); let o = void 0; let n = void 0; let s = void 0; let r = void 0; this.centerCoordinates = { x: 0.5 * e, y: 0.5 * i }, this.r = 0.49 * e; const a = 2 * Math.PI / 360; const h = 1 / 360; const d = 1 / this.r; let l = void 0; for (s = 0; s < 360; s++) for (r = 0; r < this.r; r++)o = this.centerCoordinates.x + r * Math.sin(a * s), n = this.centerCoordinates.y + r * Math.cos(a * s), l = c.HSVToRGB(s * h, r * d, 1), t.fillStyle = `rgb(${l.r },${l.g },${l.b })`, t.fillRect(o - 0.5, n - 0.5, 2, 2); t.strokeStyle = 'rgba(0,0,0,1)', t.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r), t.stroke(), this.hueCircle = t.getImageData(0, 0, e, i); } this.generated = !0; } }, { key: '_moveSelector', value(t) { const e = this.colorPickerDiv.getBoundingClientRect(); const i = t.center.x - e.left; const o = t.center.y - e.top; const n = 0.5 * this.colorPickerDiv.clientHeight; const s = 0.5 * this.colorPickerDiv.clientWidth; const r = i - s; const a = o - n; const h = Math.atan2(r, a); const d = 0.98 * Math.min(Math.sqrt(r * r + a * a), s); const l = Math.cos(h) * d + n; const u = Math.sin(h) * d + s; this.colorPickerSelector.style.top = `${l - 0.5 * this.colorPickerSelector.clientHeight}px`, this.colorPickerSelector.style.left = `${u - 0.5 * this.colorPickerSelector.clientWidth}px`; let p = h / (2 * Math.PI); p = p < 0 ? p + 1 : p; const f = d / this.r; const m = c.RGBToHSV(this.color.r, this.color.g, this.color.b); m.h = p, m.s = f; const v = c.HSVToRGB(m.h, m.s, m.v); v.a = this.color.a, this.color = v, this.initialColorDiv.style.backgroundColor = `rgba(${this.initialColor.r },${this.initialColor.g },${this.initialColor.b },${this.initialColor.a })`, this.newColorDiv.style.backgroundColor = `rgba(${this.color.r },${this.color.g },${this.color.b },${this.color.a })`; } }]), t;
      }()); e.default = p;
    }, function (t, e, i) {
      const o = i(9); const n = i(2); const s = i(11); const r = i(12); const a = i(64); const h = i(65); const d = i(45); const l = i(67); const u = i(46); const c = i(106); const p = i(15).printStyle; const f = i(113).allOptions; const m = i(113).configureOptions; const v = i(71).default; const g = i(15).default; function y(t, e, i, h) {
        if (!(Array.isArray(i) || i instanceof s || i instanceof r) && i instanceof Object) { const u = h; h = i, i = u; }h && h.throttleRedraw && console.warn('Graph2d option "throttleRedraw" is DEPRICATED and no longer supported. It will be removed in the next MAJOR release.'); const p = this; this.defaultOptions = {
          start: null, end: null, autoResize: !0, orientation: { axis: 'bottom', item: 'bottom' }, moment: o, width: null, height: null, maxHeight: null, minHeight: null,
        }, this.options = n.deepExtend({}, this.defaultOptions), this._create(t), this.components = [], this.body = {
          dom: this.dom,
          domProps: this.props,
          emitter: { on: this.on.bind(this), off: this.off.bind(this), emit: this.emit.bind(this) },
          hiddenDates: [],
          util: {
            toScreen: p._toScreen.bind(p), toGlobalScreen: p._toGlobalScreen.bind(p), toTime: p._toTime.bind(p), toGlobalTime: p._toGlobalTime.bind(p),
          },
        }, this.range = new a(this.body), this.components.push(this.range), this.body.range = this.range, this.timeAxis = new d(this.body), this.components.push(this.timeAxis), this.currentTime = new l(this.body), this.components.push(this.currentTime), this.linegraph = new c(this.body), this.components.push(this.linegraph), this.itemsData = null, this.groupsData = null, this.on('tap', (t) => { p.emit('click', p.getEventProperties(t)); }), this.on('doubletap', (t) => { p.emit('doubleClick', p.getEventProperties(t)); }), this.dom.root.oncontextmenu = function (t) { p.emit('contextmenu', p.getEventProperties(t)); }, h && this.setOptions(h), i && this.setGroups(i), e && this.setItems(e), this._redraw();
      }y.prototype = new h(), y.prototype.setOptions = function (t) { const e = g.validate(t, f); !0 === e && console.log('%cErrors have been found in the supplied options object.', p), h.prototype.setOptions.call(this, t); }, y.prototype.setItems = function (t) { let e; const i = this.itemsData == null; if (e = t ? t instanceof s || t instanceof r ? t : new s(t, { type: { start: 'Date', end: 'Date' } }) : null, this.itemsData = e, this.linegraph && this.linegraph.setItems(e), i) if (void 0 != this.options.start || void 0 != this.options.end) { const o = void 0 != this.options.start ? this.options.start : null; const n = void 0 != this.options.end ? this.options.end : null; this.setWindow(o, n, { animation: !1 }); } else this.fit({ animation: !1 }); }, y.prototype.setGroups = function (t) { let e; e = t ? t instanceof s || t instanceof r ? t : new s(t) : null, this.groupsData = e, this.linegraph.setGroups(e); }, y.prototype.getLegend = function (t, e, i) { return void 0 === e && (e = 15), void 0 === i && (i = 15), void 0 !== this.linegraph.groups[t] ? this.linegraph.groups[t].getLegend(e, i) : `cannot find group:'${t}'`; }, y.prototype.isGroupVisible = function (t) { return void 0 !== this.linegraph.groups[t] && (this.linegraph.groups[t].visible && (void 0 === this.linegraph.options.groups.visibility[t] || this.linegraph.options.groups.visibility[t] == 1)); }, y.prototype.getDataRange = function () { let t = null; let e = null; for (const i in this.linegraph.groups) if (this.linegraph.groups.hasOwnProperty(i) && this.linegraph.groups[i].visible == 1) for (let o = 0; o < this.linegraph.groups[i].itemsData.length; o++) { const s = this.linegraph.groups[i].itemsData[o]; const r = n.convert(s.x, 'Date').valueOf(); t = t == null ? r : t > r ? r : t, e = e == null ? r : e < r ? r : e; } return { min: t != null ? new Date(t) : null, max: e != null ? new Date(e) : null }; }, y.prototype.getEventProperties = function (t) {
        const e = t.center ? t.center.x : t.clientX; const i = t.center ? t.center.y : t.clientY; const o = e - n.getAbsoluteLeft(this.dom.centerContainer); const s = i - n.getAbsoluteTop(this.dom.centerContainer); const r = this._toTime(o); const a = u.customTimeFromTarget(t); const h = n.getTarget(t); let d = null; n.hasParent(h, this.timeAxis.dom.foreground) ? d = 'axis' : this.timeAxis2 && n.hasParent(h, this.timeAxis2.dom.foreground) ? d = 'axis' : n.hasParent(h, this.linegraph.yAxisLeft.dom.frame) ? d = 'data-axis' : n.hasParent(h, this.linegraph.yAxisRight.dom.frame) ? d = 'data-axis' : n.hasParent(h, this.linegraph.legendLeft.dom.frame) ? d = 'legend' : n.hasParent(h, this.linegraph.legendRight.dom.frame) ? d = 'legend' : a != null ? d = 'custom-time' : n.hasParent(h, this.currentTime.bar) ? d = 'current-time' : n.hasParent(h, this.dom.center) && (d = 'background'); const l = []; const c = this.linegraph.yAxisLeft; const p = this.linegraph.yAxisRight; return !c.hidden && this.itemsData.length > 0 && l.push(c.screenToValue(s)), !p.hidden && this.itemsData.length > 0 && l.push(p.screenToValue(s)), {
          event: t, what: d, pageX: t.srcEvent ? t.srcEvent.pageX : t.pageX, pageY: t.srcEvent ? t.srcEvent.pageY : t.pageY, x: o, y: s, time: r, value: l,
        };
      }, y.prototype._createConfigurator = function () { return new v(this, this.dom.container, m); }, t.exports = y;
    }, function (t, e, i) {
      e.util = i(2), e.DOMutil = i(14), e.DataSet = i(11), e.DataView = i(12), e.Queue = i(43), e.Network = i(182), e.network = {
        Images: i(116), dotparser: i(114), gephiParser: i(115), allOptions: i(122),
      }, e.network.convertDot = function (t) { return e.network.dotparser.DOTToGraph(t); }, e.network.convertGephi = function (t, i) { return e.network.gephiParser.parseGephi(t, i); }, e.moment = i(9), e.Hammer = i(10), e.keycharm = i(35);
    }, function (t, e, i) {
      i(183); const o = i(44); const n = i(2); const s = i(114); const r = i(115); const a = i(97); const h = i(184); const d = i(116).default; const l = i(186).default; const u = i(187).default; const c = i(214).default; const p = i(220).default; const f = i(227).default; const m = i(229).default; const v = i(230).default; const g = i(231).default; const y = i(232).default; const b = i(234).default; const _ = i(235).default; const w = i(237).default; const x = i(71).default; const k = i(15).default; const D = i(15); const S = D.printStyle; const C = i(122); const M = C.allOptions; const O = C.configureOptions; const E = i(238).default; function T(t, e, i) {
        const o = this; if (!(this instanceof T)) throw new SyntaxError('Constructor must be called with the new operator'); this.options = {}, this.defaultOptions = { locale: 'en', locales: h, clickToUse: !1 }, n.extend(this.options, this.defaultOptions), this.body = {
          container: t,
          nodes: {},
          nodeIndices: [],
          edges: {},
          edgeIndices: [],
          emitter: {
            on: this.on.bind(this), off: this.off.bind(this), emit: this.emit.bind(this), once: this.once.bind(this),
          },
          eventListeners: {
            onTap() {}, onTouch() {}, onDoubleTap() {}, onHold() {}, onDragStart() {}, onDrag() {}, onDragEnd() {}, onMouseWheel() {}, onPinch() {}, onMouseMove() {}, onRelease() {}, onContext() {},
          },
          data: { nodes: null, edges: null },
          functions: { createNode() {}, createEdge() {}, getPointer() {} },
          modules: {},
          view: { scale: 1, translation: { x: 0, y: 0 } },
        }, this.bindEventListeners(), this.images = new d((() => o.body.emitter.emit('_requestRedraw'))), this.groups = new l(), this.canvas = new v(this.body), this.selectionHandler = new b(this.body, this.canvas), this.interactionHandler = new y(this.body, this.canvas, this.selectionHandler), this.view = new g(this.body, this.canvas), this.renderer = new m(this.body, this.canvas), this.physics = new p(this.body), this.layoutEngine = new _(this.body), this.clustering = new f(this.body), this.manipulation = new w(this.body, this.canvas, this.selectionHandler), this.nodesHandler = new u(this.body, this.images, this.groups, this.layoutEngine), this.edgesHandler = new c(this.body, this.images, this.groups), this.body.modules.kamadaKawai = new E(this.body, 150, 0.05), this.body.modules.clustering = this.clustering, this.canvas._create(), this.setOptions(i), this.setData(e);
      }o(T.prototype), T.prototype.setOptions = function (t) {
        const e = this; if (void 0 !== t) {
          const i = k.validate(t, M); !0 === i && console.log('%cErrors have been found in the supplied options object.', S); const o = ['locale', 'locales', 'clickToUse']; if (n.selectiveDeepExtend(o, this.options, t), t = this.layoutEngine.setOptions(t.layout, t), this.canvas.setOptions(t), this.groups.setOptions(t.groups), this.nodesHandler.setOptions(t.nodes), this.edgesHandler.setOptions(t.edges), this.physics.setOptions(t.physics), this.manipulation.setOptions(t.manipulation, t, this.options), this.interactionHandler.setOptions(t.interaction), this.renderer.setOptions(t.interaction), this.selectionHandler.setOptions(t.interaction), void 0 !== t.groups && this.body.emitter.emit('refreshNodes'), 'configure' in t && (this.configurator || (this.configurator = new x(this, this.body.container, O, this.canvas.pixelRatio)), this.configurator.setOptions(t.configure)), this.configurator && !0 === this.configurator.options.enabled) {
            const s = {
              nodes: {}, edges: {}, layout: {}, interaction: {}, manipulation: {}, physics: {}, global: {},
            }; n.deepExtend(s.nodes, this.nodesHandler.options), n.deepExtend(s.edges, this.edgesHandler.options), n.deepExtend(s.layout, this.layoutEngine.options), n.deepExtend(s.interaction, this.selectionHandler.options), n.deepExtend(s.interaction, this.renderer.options), n.deepExtend(s.interaction, this.interactionHandler.options), n.deepExtend(s.manipulation, this.manipulation.options), n.deepExtend(s.physics, this.physics.options), n.deepExtend(s.global, this.canvas.options), n.deepExtend(s.global, this.options), this.configurator.setModuleOptions(s);
          } void 0 !== t.clickToUse ? !0 === t.clickToUse ? void 0 === this.activator && (this.activator = new a(this.canvas.frame), this.activator.on('change', () => { e.body.emitter.emit('activate'); })) : (void 0 !== this.activator && (this.activator.destroy(), delete this.activator), this.body.emitter.emit('activate')) : this.body.emitter.emit('activate'), this.canvas.setSize(), this.body.emitter.emit('startSimulation');
        }
      }, T.prototype._updateVisibleIndices = function () { const t = this.body.nodes; const e = this.body.edges; for (const i in this.body.nodeIndices = [], this.body.edgeIndices = [], t)t.hasOwnProperty(i) && (this.clustering._isClusteredNode(i) || !1 !== t[i].options.hidden || this.body.nodeIndices.push(t[i].id)); for (const o in e) if (e.hasOwnProperty(o)) { const n = e[o]; const s = t[n.fromId]; const r = t[n.toId]; const a = void 0 !== s && void 0 !== r; const h = !this.clustering._isClusteredEdge(o) && !1 === n.options.hidden && a && !1 === s.options.hidden && !1 === r.options.hidden; h && this.body.edgeIndices.push(n.id); } }, T.prototype.bindEventListeners = function () { const t = this; this.body.emitter.on('_dataChanged', () => { t.edgesHandler._updateState(), t.body.emitter.emit('_dataUpdated'); }), this.body.emitter.on('_dataUpdated', () => { t.clustering._updateState(), t._updateVisibleIndices(), t._updateValueRange(t.body.nodes), t._updateValueRange(t.body.edges), t.body.emitter.emit('startSimulation'), t.body.emitter.emit('_requestRedraw'); }); }, T.prototype.setData = function (t) { if (this.body.emitter.emit('resetPhysics'), this.body.emitter.emit('_resetData'), this.selectionHandler.unselectAll(), t && t.dot && (t.nodes || t.edges)) throw new SyntaxError('Data must contain either parameter "dot" or  parameter pair "nodes" and "edges", but not both.'); if (this.setOptions(t && t.options), t && t.dot) { console.log('The dot property has been deprecated. Please use the static convertDot method to convert DOT into vis.network format and use the normal data format with nodes and edges. This converter is used like this: var data = vis.network.convertDot(dotString);'); const e = s.DOTToGraph(t.dot); this.setData(e); } else if (t && t.gephi) { console.log('The gephi property has been deprecated. Please use the static convertGephi method to convert gephi into vis.network format and use the normal data format with nodes and edges. This converter is used like this: var data = vis.network.convertGephi(gephiJson);'); const i = r.parseGephi(t.gephi); this.setData(i); } else this.nodesHandler.setData(t && t.nodes, !0), this.edgesHandler.setData(t && t.edges, !0), this.body.emitter.emit('_dataChanged'), this.body.emitter.emit('_dataLoaded'), this.body.emitter.emit('initPhysics'); }, T.prototype.destroy = function () { for (const t in this.body.emitter.emit('destroy'), this.body.emitter.off(), this.off(), delete this.groups, delete this.canvas, delete this.selectionHandler, delete this.interactionHandler, delete this.view, delete this.renderer, delete this.physics, delete this.layoutEngine, delete this.clustering, delete this.manipulation, delete this.nodesHandler, delete this.edgesHandler, delete this.configurator, delete this.images, this.body.nodes) this.body.nodes.hasOwnProperty(t) && delete this.body.nodes[t]; for (const e in this.body.edges) this.body.edges.hasOwnProperty(e) && delete this.body.edges[e]; n.recursiveDOMDelete(this.body.container); }, T.prototype._updateValueRange = function (t) { let e; let i = void 0; let o = void 0; let n = 0; for (e in t) if (t.hasOwnProperty(e)) { const s = t[e].getValue(); void 0 !== s && (i = void 0 === i ? s : Math.min(s, i), o = void 0 === o ? s : Math.max(s, o), n += s); } if (void 0 !== i && void 0 !== o) for (e in t)t.hasOwnProperty(e) && t[e].setValueRange(i, o, n); }, T.prototype.isActive = function () { return !this.activator || this.activator.active; }, T.prototype.setSize = function () { return this.canvas.setSize.apply(this.canvas, arguments); }, T.prototype.canvasToDOM = function () { return this.canvas.canvasToDOM.apply(this.canvas, arguments); }, T.prototype.DOMtoCanvas = function () { return this.canvas.DOMtoCanvas.apply(this.canvas, arguments); }, T.prototype.findNode = function () { return this.clustering.findNode.apply(this.clustering, arguments); }, T.prototype.isCluster = function () { return this.clustering.isCluster.apply(this.clustering, arguments); }, T.prototype.openCluster = function () { return this.clustering.openCluster.apply(this.clustering, arguments); }, T.prototype.cluster = function () { return this.clustering.cluster.apply(this.clustering, arguments); }, T.prototype.getNodesInCluster = function () { return this.clustering.getNodesInCluster.apply(this.clustering, arguments); }, T.prototype.clusterByConnection = function () { return this.clustering.clusterByConnection.apply(this.clustering, arguments); }, T.prototype.clusterByHubsize = function () { return this.clustering.clusterByHubsize.apply(this.clustering, arguments); }, T.prototype.clusterOutliers = function () { return this.clustering.clusterOutliers.apply(this.clustering, arguments); }, T.prototype.getSeed = function () { return this.layoutEngine.getSeed.apply(this.layoutEngine, arguments); }, T.prototype.enableEditMode = function () { return this.manipulation.enableEditMode.apply(this.manipulation, arguments); }, T.prototype.disableEditMode = function () { return this.manipulation.disableEditMode.apply(this.manipulation, arguments); }, T.prototype.addNodeMode = function () { return this.manipulation.addNodeMode.apply(this.manipulation, arguments); }, T.prototype.editNode = function () { return this.manipulation.editNode.apply(this.manipulation, arguments); }, T.prototype.editNodeMode = function () { return console.log('Deprecated: Please use editNode instead of editNodeMode.'), this.manipulation.editNode.apply(this.manipulation, arguments); }, T.prototype.addEdgeMode = function () { return this.manipulation.addEdgeMode.apply(this.manipulation, arguments); }, T.prototype.editEdgeMode = function () { return this.manipulation.editEdgeMode.apply(this.manipulation, arguments); }, T.prototype.deleteSelected = function () { return this.manipulation.deleteSelected.apply(this.manipulation, arguments); }, T.prototype.getPositions = function () { return this.nodesHandler.getPositions.apply(this.nodesHandler, arguments); }, T.prototype.storePositions = function () { return this.nodesHandler.storePositions.apply(this.nodesHandler, arguments); }, T.prototype.moveNode = function () { return this.nodesHandler.moveNode.apply(this.nodesHandler, arguments); }, T.prototype.getBoundingBox = function () { return this.nodesHandler.getBoundingBox.apply(this.nodesHandler, arguments); }, T.prototype.getConnectedNodes = function (t) { return void 0 !== this.body.nodes[t] ? this.nodesHandler.getConnectedNodes.apply(this.nodesHandler, arguments) : this.edgesHandler.getConnectedNodes.apply(this.edgesHandler, arguments); }, T.prototype.getConnectedEdges = function () { return this.nodesHandler.getConnectedEdges.apply(this.nodesHandler, arguments); }, T.prototype.startSimulation = function () { return this.physics.startSimulation.apply(this.physics, arguments); }, T.prototype.stopSimulation = function () { return this.physics.stopSimulation.apply(this.physics, arguments); }, T.prototype.stabilize = function () { return this.physics.stabilize.apply(this.physics, arguments); }, T.prototype.getSelection = function () { return this.selectionHandler.getSelection.apply(this.selectionHandler, arguments); }, T.prototype.setSelection = function () { return this.selectionHandler.setSelection.apply(this.selectionHandler, arguments); }, T.prototype.getSelectedNodes = function () { return this.selectionHandler.getSelectedNodes.apply(this.selectionHandler, arguments); }, T.prototype.getSelectedEdges = function () { return this.selectionHandler.getSelectedEdges.apply(this.selectionHandler, arguments); }, T.prototype.getNodeAt = function () { const t = this.selectionHandler.getNodeAt.apply(this.selectionHandler, arguments); return void 0 !== t && void 0 !== t.id ? t.id : t; }, T.prototype.getEdgeAt = function () { const t = this.selectionHandler.getEdgeAt.apply(this.selectionHandler, arguments); return void 0 !== t && void 0 !== t.id ? t.id : t; }, T.prototype.selectNodes = function () { return this.selectionHandler.selectNodes.apply(this.selectionHandler, arguments); }, T.prototype.selectEdges = function () { return this.selectionHandler.selectEdges.apply(this.selectionHandler, arguments); }, T.prototype.unselectAll = function () { this.selectionHandler.unselectAll.apply(this.selectionHandler, arguments), this.redraw(); }, T.prototype.redraw = function () { return this.renderer.redraw.apply(this.renderer, arguments); }, T.prototype.getScale = function () { return this.view.getScale.apply(this.view, arguments); }, T.prototype.getViewPosition = function () { return this.view.getViewPosition.apply(this.view, arguments); }, T.prototype.fit = function () { return this.view.fit.apply(this.view, arguments); }, T.prototype.moveTo = function () { return this.view.moveTo.apply(this.view, arguments); }, T.prototype.focus = function () { return this.view.focus.apply(this.view, arguments); }, T.prototype.releaseNode = function () { return this.view.releaseNode.apply(this.view, arguments); }, T.prototype.getOptionsFromConfigurator = function () { let t = {}; return this.configurator && (t = this.configurator.getOptions.apply(this.configurator)), t; }, t.exports = T;
    }, function (t, e, i) { typeof CanvasRenderingContext2D !== 'undefined' && (CanvasRenderingContext2D.prototype.circle = function (t, e, i) { this.beginPath(), this.arc(t, e, i, 0, 2 * Math.PI, !1), this.closePath(); }, CanvasRenderingContext2D.prototype.square = function (t, e, i) { this.beginPath(), this.rect(t - i, e - i, 2 * i, 2 * i), this.closePath(); }, CanvasRenderingContext2D.prototype.triangle = function (t, e, i) { this.beginPath(), i *= 1.15, e += 0.275 * i; const o = 2 * i; const n = o / 2; const s = Math.sqrt(3) / 6 * o; const r = Math.sqrt(o * o - n * n); this.moveTo(t, e - (r - s)), this.lineTo(t + n, e + s), this.lineTo(t - n, e + s), this.lineTo(t, e - (r - s)), this.closePath(); }, CanvasRenderingContext2D.prototype.triangleDown = function (t, e, i) { this.beginPath(), i *= 1.15, e -= 0.275 * i; const o = 2 * i; const n = o / 2; const s = Math.sqrt(3) / 6 * o; const r = Math.sqrt(o * o - n * n); this.moveTo(t, e + (r - s)), this.lineTo(t + n, e - s), this.lineTo(t - n, e - s), this.lineTo(t, e + (r - s)), this.closePath(); }, CanvasRenderingContext2D.prototype.star = function (t, e, i) { this.beginPath(), i *= 0.82, e += 0.1 * i; for (let o = 0; o < 10; o++) { const n = o % 2 === 0 ? 1.3 * i : 0.5 * i; this.lineTo(t + n * Math.sin(2 * o * Math.PI / 10), e - n * Math.cos(2 * o * Math.PI / 10)); } this.closePath(); }, CanvasRenderingContext2D.prototype.diamond = function (t, e, i) { this.beginPath(), this.lineTo(t, e + i), this.lineTo(t + i, e), this.lineTo(t, e - i), this.lineTo(t - i, e), this.closePath(); }, CanvasRenderingContext2D.prototype.roundRect = function (t, e, i, o, n) { const s = Math.PI / 180; i - 2 * n < 0 && (n = i / 2), o - 2 * n < 0 && (n = o / 2), this.beginPath(), this.moveTo(t + n, e), this.lineTo(t + i - n, e), this.arc(t + i - n, e + n, n, 270 * s, 360 * s, !1), this.lineTo(t + i, e + o - n), this.arc(t + i - n, e + o - n, n, 0, 90 * s, !1), this.lineTo(t + n, e + o), this.arc(t + n, e + o - n, n, 90 * s, 180 * s, !1), this.lineTo(t, e + n), this.arc(t + n, e + n, n, 180 * s, 270 * s, !1), this.closePath(); }, CanvasRenderingContext2D.prototype.ellipse_vis = function (t, e, i, o) { const n = 0.5522848; const s = i / 2 * n; const r = o / 2 * n; const a = t + i; const h = e + o; const d = t + i / 2; const l = e + o / 2; this.beginPath(), this.moveTo(t, l), this.bezierCurveTo(t, l - r, d - s, e, d, e), this.bezierCurveTo(d + s, e, a, l - r, a, l), this.bezierCurveTo(a, l + r, d + s, h, d, h), this.bezierCurveTo(d - s, h, t, l + r, t, l), this.closePath(); }, CanvasRenderingContext2D.prototype.database = function (t, e, i, o) { const n = 1 / 3; const s = i; const r = o * n; const a = 0.5522848; const h = s / 2 * a; const d = r / 2 * a; const l = t + s; const u = e + r; const c = t + s / 2; const p = e + r / 2; const f = e + (o - r / 2); const m = e + o; this.beginPath(), this.moveTo(l, p), this.bezierCurveTo(l, p + d, c + h, u, c, u), this.bezierCurveTo(c - h, u, t, p + d, t, p), this.bezierCurveTo(t, p - d, c - h, e, c, e), this.bezierCurveTo(c + h, e, l, p - d, l, p), this.lineTo(l, f), this.bezierCurveTo(l, f + d, c + h, m, c, m), this.bezierCurveTo(c - h, m, t, f + d, t, f), this.lineTo(t, p); }, CanvasRenderingContext2D.prototype.dashedLine = function (t, e, i, o, n) { this.beginPath(), this.moveTo(t, e); const s = n.length; const r = i - t; const a = o - e; const h = a / r; let d = Math.sqrt(r * r + a * a); let l = 0; let u = !0; let c = 0; let p = n[0]; while (d >= 0.1)p = n[l++ % s], p > d && (p = d), c = Math.sqrt(p * p / (1 + h * h)), c = r < 0 ? -c : c, t += c, e += h * c, !0 === u ? this.lineTo(t, e) : this.moveTo(t, e), d -= p, u = !u; }, CanvasRenderingContext2D.prototype.hexagon = function (t, e, i) { this.beginPath(); const o = 6; const n = 2 * Math.PI / o; this.moveTo(t + i, e); for (let s = 1; s < o; s++) this.lineTo(t + i * Math.cos(n * s), e + i * Math.sin(n * s)); this.closePath(); }); }, function (t, e, i) {
      e.en = {
        edit: 'Edit', del: 'Delete selected', back: 'Back', addNode: 'Add Node', addEdge: 'Add Edge', editNode: 'Edit Node', editEdge: 'Edit Edge', addDescription: 'Click in an empty space to place a new node.', edgeDescription: 'Click on a node and drag the edge to another node to connect them.', editEdgeDescription: 'Click on the control points and drag them to a node to connect to it.', createEdgeError: 'Cannot link edges to a cluster.', deleteClusterError: 'Clusters cannot be deleted.', editClusterError: 'Clusters cannot be edited.',
      }, e.en_EN = e.en, e.en_US = e.en, e.de = {
        edit: 'Editieren', del: 'Lsche Auswahl', back: 'Zurck', addNode: 'Knoten hinzufgen', addEdge: 'Kante hinzufgen', editNode: 'Knoten editieren', editEdge: 'Kante editieren', addDescription: 'Klicke auf eine freie Stelle, um einen neuen Knoten zu plazieren.', edgeDescription: 'Klicke auf einen Knoten und ziehe die Kante zu einem anderen Knoten, um diese zu verbinden.', editEdgeDescription: 'Klicke auf die Verbindungspunkte und ziehe diese auf einen Knoten, um sie zu verbinden.', createEdgeError: 'Es ist nicht mglich, Kanten mit Clustern zu verbinden.', deleteClusterError: 'Cluster knnen nicht gelscht werden.', editClusterError: 'Cluster knnen nicht editiert werden.',
      }, e.de_DE = e.de, e.es = {
        edit: 'Editar', del: 'Eliminar seleccin', back: 'tras', addNode: 'Aadir nodo', addEdge: 'Aadir arista', editNode: 'Editar nodo', editEdge: 'Editar arista', addDescription: 'Haga clic en un lugar vaco para colocar un nuevo nodo.', edgeDescription: 'Haga clic en un nodo y arrastre la arista hacia otro nodo para conectarlos.', editEdgeDescription: 'Haga clic en un punto de control y arrastrelo a un nodo para conectarlo.', createEdgeError: 'No se puede conectar una arista a un grupo.', deleteClusterError: 'No es posible eliminar grupos.', editClusterError: 'No es posible editar grupos.',
      }, e.es_ES = e.es, e.it = {
        edit: 'Modifica', del: 'Cancella la selezione', back: 'Indietro', addNode: 'Aggiungi un nodo', addEdge: 'Aggiungi un vertice', editNode: 'Modifica il nodo', editEdge: 'Modifica il vertice', addDescription: 'Clicca per aggiungere un nuovo nodo', edgeDescription: 'Clicca su un nodo e trascinalo ad un altro nodo per connetterli.', editEdgeDescription: 'Clicca sui Punti di controllo e trascinali ad un nodo per connetterli.', createEdgeError: 'Non si possono collegare vertici ad un cluster', deleteClusterError: 'I cluster non possono essere cancellati', editClusterError: 'I clusters non possono essere modificati.',
      }, e.it_IT = e.it, e.nl = {
        edit: 'Wijzigen', del: 'Selectie verwijderen', back: 'Terug', addNode: 'Node toevoegen', addEdge: 'Link toevoegen', editNode: 'Node wijzigen', editEdge: 'Link wijzigen', addDescription: 'Klik op een leeg gebied om een nieuwe node te maken.', edgeDescription: 'Klik op een node en sleep de link naar een andere node om ze te verbinden.', editEdgeDescription: 'Klik op de verbindingspunten en sleep ze naar een node om daarmee te verbinden.', createEdgeError: 'Kan geen link maken naar een cluster.', deleteClusterError: 'Clusters kunnen niet worden verwijderd.', editClusterError: 'Clusters kunnen niet worden aangepast.',
      }, e.nl_NL = e.nl, e.nl_BE = e.nl, e['pt-br'] = {
        edit: 'Editar', del: 'Remover selecionado', back: 'Voltar', addNode: 'Adicionar n', addEdge: 'Adicionar aresta', editNode: 'Editar n', editEdge: 'Editar aresta', addDescription: 'Clique em um espao em branco para adicionar um novo n', edgeDescription: 'Clique em um n e arraste a aresta at outro n para conect-los', editEdgeDescription: 'Clique nos pontos de controle e os arraste para um n para conect-los', createEdgeError: 'No foi possvel linkar arestas a um cluster.', deleteClusterError: 'Clusters no puderam ser removidos.', editClusterError: 'Clusters no puderam ser editados.',
      }, e['pt-BR'] = e['pt-br'], e.pt_BR = e['pt-br'], e.pt_br = e['pt-br'], e.ru = {
        edit: '', del: ' ', back: '', addNode: ' ', addEdge: ' ', editNode: ' ', editEdge: ' ', addDescription: '   ,    .', edgeDescription: '        ,   .', editEdgeDescription: '        ,    .', createEdgeError: '    .', deleteClusterError: '    ', editClusterError: '   .',
      }, e.ru_RU = e.ru, e.cn = {
        edit: '', del: '', back: '', addNode: '', addEdge: '', editNode: '', editEdge: '', addDescription: '', edgeDescription: '', editEdgeDescription: '', createEdgeError: '', deleteClusterError: '', editClusterError: '',
      }, e.zh_CN = e.cn;
    }, function (t, e, i) { Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(0); const n = a(o); const s = i(1); const r = a(s); function a(t) { return t && t.__esModule ? t : { default: t }; } const h = (function () { function t() { (0, n.default)(this, t), this.NUM_ITERATIONS = 4, this.image = new Image(), this.canvas = document.createElement('canvas'); } return (0, r.default)(t, [{ key: 'init', value() { if (!this.initialized()) { this.src = this.image.src; const t = this.image.width; const e = this.image.height; this.width = t, this.height = e; const i = Math.floor(e / 2); const o = Math.floor(e / 4); const n = Math.floor(e / 8); const s = Math.floor(e / 16); const r = Math.floor(t / 2); const a = Math.floor(t / 4); const h = Math.floor(t / 8); const d = Math.floor(t / 16); this.canvas.width = 3 * a, this.canvas.height = i, this.coordinates = [[0, 0, r, i], [r, 0, a, o], [r, o, h, n], [5 * h, o, d, s]], this._fillMipMap(); } } }, { key: 'initialized', value() { return void 0 !== this.coordinates; } }, { key: '_fillMipMap', value() { const t = this.canvas.getContext('2d'); const e = this.coordinates[0]; t.drawImage(this.image, e[0], e[1], e[2], e[3]); for (let i = 1; i < this.NUM_ITERATIONS; i++) { const o = this.coordinates[i - 1]; const n = this.coordinates[i]; t.drawImage(this.canvas, o[0], o[1], o[2], o[3], n[0], n[1], n[2], n[3]); } } }, { key: 'drawImageAtPosition', value(t, e, i, o, n, s) { if (this.initialized()) if (e > 2) { e *= 0.5; let r = 0; while (e > 2 && r < this.NUM_ITERATIONS)e *= 0.5, r += 1; r >= this.NUM_ITERATIONS && (r = this.NUM_ITERATIONS - 1); const a = this.coordinates[r]; t.drawImage(this.canvas, a[0], a[1], a[2], a[3], i, o, n, s); } else t.drawImage(this.image, i, o, n, s); } }]), t; }()); e.default = h; }, function (t, e, i) {
      Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(0); const n = a(o); const s = i(1); const r = a(s); function a(t) { return t && t.__esModule ? t : { default: t }; } const h = i(2); const d = (function () {
        function t() {
          (0, n.default)(this, t), this.clear(), this.defaultIndex = 0, this.groupsArray = [], this.groupIndex = 0, this.defaultGroups = [{
            border: '#2B7CE9', background: '#97C2FC', highlight: { border: '#2B7CE9', background: '#D2E5FF' }, hover: { border: '#2B7CE9', background: '#D2E5FF' },
          }, {
            border: '#FFA500', background: '#FFFF00', highlight: { border: '#FFA500', background: '#FFFFA3' }, hover: { border: '#FFA500', background: '#FFFFA3' },
          }, {
            border: '#FA0A10', background: '#FB7E81', highlight: { border: '#FA0A10', background: '#FFAFB1' }, hover: { border: '#FA0A10', background: '#FFAFB1' },
          }, {
            border: '#41A906', background: '#7BE141', highlight: { border: '#41A906', background: '#A1EC76' }, hover: { border: '#41A906', background: '#A1EC76' },
          }, {
            border: '#E129F0', background: '#EB7DF4', highlight: { border: '#E129F0', background: '#F0B3F5' }, hover: { border: '#E129F0', background: '#F0B3F5' },
          }, {
            border: '#7C29F0', background: '#AD85E4', highlight: { border: '#7C29F0', background: '#D3BDF0' }, hover: { border: '#7C29F0', background: '#D3BDF0' },
          }, {
            border: '#C37F00', background: '#FFA807', highlight: { border: '#C37F00', background: '#FFCA66' }, hover: { border: '#C37F00', background: '#FFCA66' },
          }, {
            border: '#4220FB', background: '#6E6EFD', highlight: { border: '#4220FB', background: '#9B9BFD' }, hover: { border: '#4220FB', background: '#9B9BFD' },
          }, {
            border: '#FD5A77', background: '#FFC0CB', highlight: { border: '#FD5A77', background: '#FFD1D9' }, hover: { border: '#FD5A77', background: '#FFD1D9' },
          }, {
            border: '#4AD63A', background: '#C2FABC', highlight: { border: '#4AD63A', background: '#E6FFE3' }, hover: { border: '#4AD63A', background: '#E6FFE3' },
          }, {
            border: '#990000', background: '#EE0000', highlight: { border: '#BB0000', background: '#FF3333' }, hover: { border: '#BB0000', background: '#FF3333' },
          }, {
            border: '#FF6000', background: '#FF6000', highlight: { border: '#FF6000', background: '#FF6000' }, hover: { border: '#FF6000', background: '#FF6000' },
          }, {
            border: '#97C2FC', background: '#2B7CE9', highlight: { border: '#D2E5FF', background: '#2B7CE9' }, hover: { border: '#D2E5FF', background: '#2B7CE9' },
          }, {
            border: '#399605', background: '#255C03', highlight: { border: '#399605', background: '#255C03' }, hover: { border: '#399605', background: '#255C03' },
          }, {
            border: '#B70054', background: '#FF007E', highlight: { border: '#B70054', background: '#FF007E' }, hover: { border: '#B70054', background: '#FF007E' },
          }, {
            border: '#AD85E4', background: '#7C29F0', highlight: { border: '#D3BDF0', background: '#7C29F0' }, hover: { border: '#D3BDF0', background: '#7C29F0' },
          }, {
            border: '#4557FA', background: '#000EA1', highlight: { border: '#6E6EFD', background: '#000EA1' }, hover: { border: '#6E6EFD', background: '#000EA1' },
          }, {
            border: '#FFC0CB', background: '#FD5A77', highlight: { border: '#FFD1D9', background: '#FD5A77' }, hover: { border: '#FFD1D9', background: '#FD5A77' },
          }, {
            border: '#C2FABC', background: '#74D66A', highlight: { border: '#E6FFE3', background: '#74D66A' }, hover: { border: '#E6FFE3', background: '#74D66A' },
          }, {
            border: '#EE0000', background: '#990000', highlight: { border: '#FF3333', background: '#BB0000' }, hover: { border: '#FF3333', background: '#BB0000' },
          }], this.options = {}, this.defaultOptions = { useDefaultGroups: !0 }, h.extend(this.options, this.defaultOptions);
        } return (0, r.default)(t, [{ key: 'setOptions', value(t) { const e = ['useDefaultGroups']; if (void 0 !== t) for (const i in t) if (t.hasOwnProperty(i) && e.indexOf(i) === -1) { const o = t[i]; this.add(i, o); } } }, { key: 'clear', value() { this.groups = {}, this.groupsArray = []; } }, { key: 'get', value(t) { const e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]; let i = this.groups[t]; if (void 0 === i && e) if (!1 === this.options.useDefaultGroups && this.groupsArray.length > 0) { const o = this.groupIndex % this.groupsArray.length; this.groupIndex++, i = {}, i.color = this.groups[this.groupsArray[o]], this.groups[t] = i; } else { const n = this.defaultIndex % this.defaultGroups.length; this.defaultIndex++, i = {}, i.color = this.defaultGroups[n], this.groups[t] = i; } return i; } }, { key: 'add', value(t, e) { return this.groups[t] = e, this.groupsArray.push(t), e; } }]), t;
      }()); e.default = d;
    }, function (t, e, i) {
      Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(0); const n = a(o); const s = i(1); const r = a(s); function a(t) { return t && t.__esModule ? t : { default: t }; } const h = i(2); const d = i(11); const l = i(12); const u = i(47).default; const c = (function () {
        function t(e, i, o, s) {
          const r = this; if ((0, n.default)(this, t), this.body = e, this.images = i, this.groups = o, this.layoutEngine = s, this.body.functions.createNode = this.create.bind(this), this.nodesListeners = { add(t, e) { r.add(e.items); }, update(t, e) { r.update(e.items, e.data, e.oldData); }, remove(t, e) { r.remove(e.items); } }, this.defaultOptions = {
            borderWidth: 1,
            borderWidthSelected: 2,
            brokenImage: void 0,
            color: {
              border: '#2B7CE9', background: '#97C2FC', highlight: { border: '#2B7CE9', background: '#D2E5FF' }, hover: { border: '#2B7CE9', background: '#D2E5FF' },
            },
            fixed: { x: !1, y: !1 },
            font: {
              color: '#343434',
              size: 14,
              face: 'arial',
              background: 'none',
              strokeWidth: 0,
              strokeColor: '#ffffff',
              align: 'center',
              vadjust: 0,
              multi: !1,
              bold: { mod: 'bold' },
              boldital: { mod: 'bold italic' },
              ital: { mod: 'italic' },
              mono: {
                mod: '', size: 15, face: 'monospace', vadjust: 2,
              },
            },
            group: void 0,
            hidden: !1,
            icon: {
              face: 'FontAwesome', code: void 0, size: 50, color: '#2B7CE9',
            },
            image: void 0,
            label: void 0,
            labelHighlightBold: !0,
            level: void 0,
            margin: {
              top: 5, right: 5, bottom: 5, left: 5,
            },
            mass: 1,
            physics: !0,
            scaling: {
              min: 10,
              max: 30,
              label: {
                enabled: !1, min: 14, max: 30, maxVisible: 30, drawThreshold: 5,
              },
              customScalingFunction(t, e, i, o) { if (e === t) return 0.5; const n = 1 / (e - t); return Math.max(0, (o - t) * n); },
            },
            shadow: {
              enabled: !1, color: 'rgba(0,0,0,0.5)', size: 10, x: 5, y: 5,
            },
            shape: 'ellipse',
            shapeProperties: {
              borderDashes: !1, borderRadius: 6, interpolation: !0, useImageSize: !1, useBorderWithImage: !1,
            },
            size: 25,
            title: void 0,
            value: void 0,
            x: void 0,
            y: void 0,
          }, this.defaultOptions.mass <= 0) throw 'Internal error: mass in defaultOptions of NodesHandler may not be zero or negative'; this.options = h.bridgeObject(this.defaultOptions), this.bindEventListeners();
        } return (0, r.default)(t, [{ key: 'bindEventListeners', value() { const t = this; this.body.emitter.on('refreshNodes', this.refresh.bind(this)), this.body.emitter.on('refresh', this.refresh.bind(this)), this.body.emitter.on('destroy', () => { h.forEach(t.nodesListeners, (e, i) => { t.body.data.nodes && t.body.data.nodes.off(i, e); }), delete t.body.functions.createNode, delete t.nodesListeners.add, delete t.nodesListeners.update, delete t.nodesListeners.remove, delete t.nodesListeners; }); } }, { key: 'setOptions', value(t) { if (void 0 !== t) { if (u.parseOptions(this.options, t), void 0 !== t.shape) for (const e in this.body.nodes) this.body.nodes.hasOwnProperty(e) && this.body.nodes[e].updateShape(); if (void 0 !== t.font) for (const i in this.body.nodes) this.body.nodes.hasOwnProperty(i) && (this.body.nodes[i].updateLabelModule(), this.body.nodes[i].needsRefresh()); if (void 0 !== t.size) for (const o in this.body.nodes) this.body.nodes.hasOwnProperty(o) && this.body.nodes[o].needsRefresh(); void 0 === t.hidden && void 0 === t.physics || this.body.emitter.emit('_dataChanged'); } } }, { key: 'setData', value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; const i = this.body.data.nodes; if (t instanceof d || t instanceof l) this.body.data.nodes = t; else if (Array.isArray(t)) this.body.data.nodes = new d(), this.body.data.nodes.add(t); else { if (t) throw new TypeError('Array or DataSet expected'); this.body.data.nodes = new d(); } if (i && h.forEach(this.nodesListeners, (t, e) => { i.off(e, t); }), this.body.nodes = {}, this.body.data.nodes) { const o = this; h.forEach(this.nodesListeners, (t, e) => { o.body.data.nodes.on(e, t); }); const n = this.body.data.nodes.getIds(); this.add(n, !0); }!1 === e && this.body.emitter.emit('_dataChanged'); } }, { key: 'add', value(t) { for (var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], i = void 0, o = [], n = 0; n < t.length; n++) { i = t[n]; const s = this.body.data.nodes.get(i); const r = this.create(s); o.push(r), this.body.nodes[i] = r; } this.layoutEngine.positionInitially(o), !1 === e && this.body.emitter.emit('_dataChanged'); } }, { key: 'update', value(t, e, i) { for (var o = this.body.nodes, n = !1, s = 0; s < t.length; s++) { const r = t[s]; let a = o[r]; const h = e[s]; void 0 !== a ? a.setOptions(h) && (n = !0) : (n = !0, a = this.create(h), o[r] = a); }n || void 0 === i || (n = e.some((t, e) => { const o = i[e]; return o && o.level !== t.level; })), !0 === n ? this.body.emitter.emit('_dataChanged') : this.body.emitter.emit('_dataUpdated'); } }, { key: 'remove', value(t) { for (let e = this.body.nodes, i = 0; i < t.length; i++) { const o = t[i]; delete e[o]; } this.body.emitter.emit('_dataChanged'); } }, { key: 'create', value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : u; return new e(t, this.body, this.images, this.groups, this.options, this.defaultOptions); } }, { key: 'refresh', value() { const t = this; const e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]; h.forEach(this.body.nodes, (i, o) => { const n = t.body.data.nodes.get(o); void 0 !== n && (!0 === e && i.setOptions({ x: null, y: null }), i.setOptions({ fixed: !1 }), i.setOptions(n)); }); } }, { key: 'getPositions', value(t) { const e = {}; if (void 0 !== t) { if (!0 === Array.isArray(t)) { for (let i = 0; i < t.length; i++) if (void 0 !== this.body.nodes[t[i]]) { const o = this.body.nodes[t[i]]; e[t[i]] = { x: Math.round(o.x), y: Math.round(o.y) }; } } else if (void 0 !== this.body.nodes[t]) { const n = this.body.nodes[t]; e[t] = { x: Math.round(n.x), y: Math.round(n.y) }; } } else for (let s = 0; s < this.body.nodeIndices.length; s++) { const r = this.body.nodes[this.body.nodeIndices[s]]; e[this.body.nodeIndices[s]] = { x: Math.round(r.x), y: Math.round(r.y) }; } return e; } }, { key: 'storePositions', value() { const t = []; const e = this.body.data.nodes.getDataSet(); for (const i in e._data) if (e._data.hasOwnProperty(i)) { const o = this.body.nodes[i]; e._data[i].x == Math.round(o.x) && e._data[i].y == Math.round(o.y) || t.push({ id: o.id, x: Math.round(o.x), y: Math.round(o.y) }); }e.update(t); } }, { key: 'getBoundingBox', value(t) { if (void 0 !== this.body.nodes[t]) return this.body.nodes[t].shape.boundingBox; } }, { key: 'getConnectedNodes', value(t, e) { const i = []; if (void 0 !== this.body.nodes[t]) for (let o = this.body.nodes[t], n = {}, s = 0; s < o.edges.length; s++) { const r = o.edges[s]; e !== 'to' && r.toId == o.id ? void 0 === n[r.fromId] && (i.push(r.fromId), n[r.fromId] = !0) : e !== 'from' && r.fromId == o.id && void 0 === n[r.toId] && (i.push(r.toId), n[r.toId] = !0); } return i; } }, { key: 'getConnectedEdges', value(t) { const e = []; if (void 0 !== this.body.nodes[t]) for (let i = this.body.nodes[t], o = 0; o < i.edges.length; o++)e.push(i.edges[o].id); else console.log('NodeId provided for getConnectedEdges does not exist. Provided: ', t); return e; } }, { key: 'moveNode', value(t, e, i) { const o = this; void 0 !== this.body.nodes[t] ? (this.body.nodes[t].x = Number(e), this.body.nodes[t].y = Number(i), setTimeout(() => { o.body.emitter.emit('startSimulation'); }, 0)) : console.log('Node id supplied to moveNode does not exist. Provided: ', t); } }]), t;
      }()); e.default = c;
    }, function (t, e, i) { t.exports = { default: i(189), __esModule: !0 }; }, function (t, e, i) { i(49), i(60), t.exports = i(190); }, function (t, e, i) { const o = i(86); const n = i(13)('iterator'); const s = i(31); t.exports = i(7).isIterable = function (t) { const e = Object(t); return void 0 !== e[n] || '@@iterator' in e || s.hasOwnProperty(o(e)); }; }, function (t, e, i) {
      Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(0); const n = a(o); const s = i(1); const r = a(s); function a(t) { return t && t.__esModule ? t : { default: t }; } const h = i(192).default; const d = i(48).default; const
        l = (function () {
          function t(e, i, o, s) { const r = this; (0, n.default)(this, t), this.ctx = e, this.parent = i; const a = function (t, i) { if (void 0 === t) return 0; const n = r.parent.getFormattingValues(e, o, s, i); let a = 0; if (t !== '') { const h = r.ctx.measureText(t); a = h.width; } return { width: a, values: n }; }; this.lines = new h(a); } return (0, r.default)(t, [{ key: 'process', value(t) { if (!d.isValidLabel(t)) return this.lines.finalize(); const e = this.parent.fontOptions; t = t.replace(/\r\n/g, '\n'), t = t.replace(/\r/g, '\n'); const i = String(t).split('\n'); const o = i.length; if (e.multi) for (let n = 0; n < o; n++) { const s = this.splitBlocks(i[n], e.multi); if (void 0 !== s) if (s.length !== 0) { if (e.maxWdt > 0) for (let r = 0; r < s.length; r++) { const a = s[r].mod; const h = s[r].text; this.splitStringIntoLines(h, a, !0); } else for (let l = 0; l < s.length; l++) { const u = s[l].mod; const c = s[l].text; this.lines.append(c, u); } this.lines.newLine(); } else this.lines.newLine(''); } else if (e.maxWdt > 0) for (let p = 0; p < o; p++) this.splitStringIntoLines(i[p]); else for (let f = 0; f < o; f++) this.lines.newLine(i[f]); return this.lines.finalize(); } }, { key: 'decodeMarkupSystem', value(t) { let e = 'none'; return t === 'markdown' || t === 'md' ? e = 'markdown' : !0 !== t && t !== 'html' || (e = 'html'), e; } }, {
            key: 'splitHtmlBlocks',
            value(t) {
              const e = []; var i = {
                bold: !1, ital: !1, mono: !1, spacing: !1, position: 0, buffer: '', modStack: [], mod() { return this.modStack.length === 0 ? 'normal' : this.modStack[0]; }, modName() { return this.modStack.length === 0 ? 'normal' : this.modStack[0] === 'mono' ? 'mono' : i.bold && i.ital ? 'boldital' : i.bold ? 'bold' : i.ital ? 'ital' : void 0; }, emitBlock() { arguments.length > 0 && void 0 !== arguments[0] && arguments[0]; this.spacing && (this.add(' '), this.spacing = !1), this.buffer.length > 0 && (e.push({ text: this.buffer, mod: this.modName() }), this.buffer = ''); }, add(t) { t === ' ' && (i.spacing = !0), i.spacing && (this.buffer += ' ', this.spacing = !1), t != ' ' && (this.buffer += t); },
              }; while (i.position < t.length) { const o = t.charAt(i.position); /[ \t]/.test(o) ? i.mono ? i.add(o) : i.spacing = !0 : /</.test(o) ? i.mono || i.bold || !/<b>/.test(t.substr(i.position, 3)) ? i.mono || i.ital || !/<i>/.test(t.substr(i.position, 3)) ? !i.mono && /<code>/.test(t.substr(i.position, 6)) ? (i.emitBlock(), i.mono = !0, i.modStack.unshift('mono'), i.position += 5) : !i.mono && i.mod() === 'bold' && /<\/b>/.test(t.substr(i.position, 4)) ? (i.emitBlock(), i.bold = !1, i.modStack.shift(), i.position += 3) : !i.mono && i.mod() === 'ital' && /<\/i>/.test(t.substr(i.position, 4)) ? (i.emitBlock(), i.ital = !1, i.modStack.shift(), i.position += 3) : i.mod() === 'mono' && /<\/code>/.test(t.substr(i.position, 7)) ? (i.emitBlock(), i.mono = !1, i.modStack.shift(), i.position += 6) : i.add(o) : (i.emitBlock(), i.ital = !0, i.modStack.unshift('ital'), i.position += 2) : (i.emitBlock(), i.bold = !0, i.modStack.unshift('bold'), i.position += 2) : /&/.test(o) ? /&lt;/.test(t.substr(i.position, 4)) ? (i.add('<'), i.position += 3) : /&amp;/.test(t.substr(i.position, 5)) ? (i.add('&'), i.position += 4) : i.add('&') : i.add(o), i.position++; } return i.emitBlock(), e;
            }, 
          }, {
            key: 'splitMarkdownBlocks',
            value(t) {
              const e = []; var i = {
                bold: !1, ital: !1, mono: !1, beginable: !0, spacing: !1, position: 0, buffer: '', modStack: [], mod() { return this.modStack.length === 0 ? 'normal' : this.modStack[0]; }, modName() { return this.modStack.length === 0 ? 'normal' : this.modStack[0] === 'mono' ? 'mono' : i.bold && i.ital ? 'boldital' : i.bold ? 'bold' : i.ital ? 'ital' : void 0; }, emitBlock() { arguments.length > 0 && void 0 !== arguments[0] && arguments[0]; this.spacing && (this.add(' '), this.spacing = !1), this.buffer.length > 0 && (e.push({ text: this.buffer, mod: this.modName() }), this.buffer = ''); }, add(t) { t === ' ' && (i.spacing = !0), i.spacing && (this.buffer += ' ', this.spacing = !1), t != ' ' && (this.buffer += t); },
              }; while (i.position < t.length) { let o = t.charAt(i.position); /[ \t]/.test(o) ? (i.mono ? i.add(o) : i.spacing = !0, i.beginable = !0) : /\\/.test(o) ? i.position < t.length + 1 && (i.position++, o = t.charAt(i.position), / \t/.test(o) ? i.spacing = !0 : (i.add(o), i.beginable = !1)) : i.mono || i.bold || !i.beginable && !i.spacing || !/\*/.test(o) ? i.mono || i.ital || !i.beginable && !i.spacing || !/\_/.test(o) ? !i.mono && (i.beginable || i.spacing) && /`/.test(o) ? (i.emitBlock(), i.mono = !0, i.modStack.unshift('mono')) : !i.mono && i.mod() === 'bold' && /\*/.test(o) ? i.position === t.length - 1 || /[.,_` \t\n]/.test(t.charAt(i.position + 1)) ? (i.emitBlock(), i.bold = !1, i.modStack.shift()) : i.add(o) : !i.mono && i.mod() === 'ital' && /\_/.test(o) ? i.position === t.length - 1 || /[.,*` \t\n]/.test(t.charAt(i.position + 1)) ? (i.emitBlock(), i.ital = !1, i.modStack.shift()) : i.add(o) : i.mono && i.mod() === 'mono' && /`/.test(o) ? i.position === t.length - 1 || /[.,*_ \t\n]/.test(t.charAt(i.position + 1)) ? (i.emitBlock(), i.mono = !1, i.modStack.shift()) : i.add(o) : (i.add(o), i.beginable = !1) : (i.emitBlock(), i.ital = !0, i.modStack.unshift('ital')) : (i.emitBlock(), i.bold = !0, i.modStack.unshift('bold')), i.position++; } return i.emitBlock(), e;
            }, 
          }, { key: 'splitBlocks', value(t, e) { const i = this.decodeMarkupSystem(e); return i === 'none' ? [{ text: t, mod: 'normal' }] : i === 'markdown' ? this.splitMarkdownBlocks(t) : i === 'html' ? this.splitHtmlBlocks(t) : void 0; } }, { key: 'overMaxWidth', value(t) { const e = this.ctx.measureText(t).width; return this.lines.curWidth() + e > this.parent.fontOptions.maxWdt; } }, {
            key: 'getLongestFit',
            value(t) {
              let e = ''; let i = 0; while (i < t.length) {
                const o = e === '' ? '' : ' '; const 
                  n = e + o + t[i]; if (this.overMaxWidth(n)) break; e = n, i++;
              } return i;
            }, 
          }, { key: 'getLongestFitWord', value(t) { let e = 0; while (e < t.length) { if (this.overMaxWidth(t.slice(0, e))) break; e++; } return e; } }, {
            key: 'splitStringIntoLines',
            value(t) {
              const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'normal'; const 
                i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; t = t.replace(/^( +)/g, '$1\r'), t = t.replace(/([^\r][^ ]*)( +)/g, '$1\r$2\r'); let o = t.split('\r'); while (o.length > 0) { let n = this.getLongestFit(o); if (n === 0) { const s = o[0]; const r = this.getLongestFitWord(s); this.lines.newLine(s.slice(0, r), e), o[0] = s.slice(r); } else { let a = n; o[n - 1] === ' ' ? n-- : o[a] === ' ' && a++; const h = o.slice(0, n).join(''); n == o.length && i ? this.lines.append(h, e) : this.lines.newLine(h, e), o = o.slice(a); } }
            }, 
          }]), t;
        }()); e.default = l;
    }, function (t, e, i) { Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(90); const n = d(o); const s = i(0); const r = d(s); const a = i(1); const h = d(a); function d(t) { return t && t.__esModule ? t : { default: t }; } const l = (function () { function t(e) { (0, r.default)(this, t), this.measureText = e, this.current = 0, this.width = 0, this.height = 0, this.lines = []; } return (0, h.default)(t, [{ key: '_add', value(t, e) { const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 'normal'; void 0 === this.lines[t] && (this.lines[t] = { width: 0, height: 0, blocks: [] }); let o = e; void 0 !== e && e !== '' || (o = ' '); const s = this.measureText(o, i); const r = (0, n.default)({}, s.values); r.text = e, r.width = s.width, r.mod = i, void 0 !== e && e !== '' || (r.width = 0), this.lines[t].blocks.push(r), this.lines[t].width += r.width; } }, { key: 'curWidth', value() { const t = this.lines[this.current]; return void 0 === t ? 0 : t.width; } }, { key: 'append', value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'normal'; this._add(this.current, t, e); } }, { key: 'newLine', value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'normal'; this._add(this.current, t, e), this.current++; } }, { key: 'determineLineHeights', value() { for (let t = 0; t < this.lines.length; t++) { const e = this.lines[t]; let i = 0; if (void 0 !== e.blocks) for (let o = 0; o < e.blocks.length; o++) { const n = e.blocks[o]; i < n.height && (i = n.height); }e.height = i; } } }, { key: 'determineLabelSize', value() { for (var t = 0, e = 0, i = 0; i < this.lines.length; i++) { const o = this.lines[i]; o.width > t && (t = o.width), e += o.height; } this.width = t, this.height = e; } }, { key: 'removeEmptyBlocks', value() { for (var t = [], e = 0; e < this.lines.length; e++) { const i = this.lines[e]; if (i.blocks.length !== 0 && (e !== this.lines.length - 1 || i.width !== 0)) { const o = {}; (0, n.default)(o, i), o.blocks = []; for (var s = void 0, r = [], a = 0; a < i.blocks.length; a++) { const h = i.blocks[a]; h.width !== 0 ? r.push(h) : void 0 === s && (s = h); }r.length === 0 && void 0 !== s && r.push(s), o.blocks = r, t.push(o); } } return t; } }, { key: 'finalize', value() { this.determineLineHeights(), this.determineLabelSize(); const t = this.removeEmptyBlocks(); return { width: this.width, height: this.height, lines: t }; } }]), t; }()); e.default = l; }, function (t, e, i) { Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(3); const n = m(o); const s = i(0); const r = m(s); const a = i(1); const h = m(a); const d = i(4); const l = m(d); const u = i(5); const c = m(u); const p = i(23); const f = m(p); function m(t) { return t && t.__esModule ? t : { default: t }; } const v = (function (t) { function e(t, i, o) { (0, r.default)(this, e); const s = (0, l.default)(this, (e.__proto__ || (0, n.default)(e)).call(this, t, i, o)); return s._setMargins(o), s; } return (0, c.default)(e, t), (0, h.default)(e, [{ key: 'resize', value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.selected; const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.hover; if (this.needsRefresh(e, i)) { const o = this.getDimensionsFromLabel(t, e, i); this.width = o.width + this.margin.right + this.margin.left, this.height = o.height + this.margin.top + this.margin.bottom, this.radius = this.width / 2; } } }, { key: 'draw', value(t, e, i, o, n, s) { this.resize(t, o, n), this.left = e - this.width / 2, this.top = i - this.height / 2, this.initContextForDraw(t, s), t.roundRect(this.left, this.top, this.width, this.height, s.borderRadius), this.performFill(t, s), this.updateBoundingBox(e, i, t, o, n), this.labelModule.draw(t, this.left + this.textSize.width / 2 + this.margin.left, this.top + this.textSize.height / 2 + this.margin.top, o, n); } }, { key: 'updateBoundingBox', value(t, e, i, o, n) { this._updateBoundingBox(t, e, i, o, n); const s = this.options.shapeProperties.borderRadius; this._addBoundingBoxMargin(s); } }, { key: 'distanceToBorder', value(t, e) { this.resize(t); const i = this.options.borderWidth; return Math.min(Math.abs(this.width / 2 / Math.cos(e)), Math.abs(this.height / 2 / Math.sin(e))) + i; } }]), e; }(f.default)); e.default = v; }, function (t, e, i) { i(195), t.exports = i(7).Object.getPrototypeOf; }, function (t, e, i) { const o = i(41); const n = i(85); i(87)('getPrototypeOf', () => function (t) { return n(o(t)); }); }, function (t, e, i) { t.exports = { default: i(197), __esModule: !0 }; }, function (t, e, i) { i(198), t.exports = i(7).Object.setPrototypeOf; }, function (t, e, i) { const o = i(17); o(o.S, 'Object', { setPrototypeOf: i(199).set }); }, function (t, e, i) { const o = i(32); const n = i(27); const s = function (t, e) { if (n(t), !o(e) && e !== null) throw TypeError(`${e}: can't set as prototype!`); }; t.exports = { set: Object.setPrototypeOf || ('__proto__' in {} ? (function (t, e, o) { try { o = i(80)(Function.call, i(89).f(Object.prototype, '__proto__').set, 2), o(t, []), e = !(t instanceof Array); } catch (n) { e = !0; } return function (t, i) { return s(t, i), e ? t.__proto__ = i : o(t, i), t; }; }({}, !1)) : void 0), check: s }; }, function (t, e, i) { Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(3); const n = m(o); const s = i(0); const r = m(s); const a = i(1); const h = m(a); const d = i(4); const l = m(d); const u = i(5); const c = m(u); const p = i(73); const f = m(p); function m(t) { return t && t.__esModule ? t : { default: t }; } const v = (function (t) { function e(t, i, o) { (0, r.default)(this, e); const s = (0, l.default)(this, (e.__proto__ || (0, n.default)(e)).call(this, t, i, o)); return s._setMargins(o), s; } return (0, c.default)(e, t), (0, h.default)(e, [{ key: 'resize', value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.selected; const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.hover; if (this.needsRefresh(e, i)) { const o = this.getDimensionsFromLabel(t, e, i); const n = Math.max(o.width + this.margin.right + this.margin.left, o.height + this.margin.top + this.margin.bottom); this.options.size = n / 2, this.width = n, this.height = n, this.radius = this.width / 2; } } }, { key: 'draw', value(t, e, i, o, n, s) { this.resize(t, o, n), this.left = e - this.width / 2, this.top = i - this.height / 2, this._drawRawCircle(t, e, i, s), this.updateBoundingBox(e, i), this.labelModule.draw(t, this.left + this.textSize.width / 2 + this.margin.left, i, o, n); } }, { key: 'updateBoundingBox', value(t, e) { this.boundingBox.top = e - this.options.size, this.boundingBox.left = t - this.options.size, this.boundingBox.right = t + this.options.size, this.boundingBox.bottom = e + this.options.size; } }, { key: 'distanceToBorder', value(t, e) { return this.resize(t), 0.5 * this.width; } }]), e; }(f.default)); e.default = v; }, function (t, e, i) { Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(3); const n = m(o); const s = i(0); const r = m(s); const a = i(1); const h = m(a); const d = i(4); const l = m(d); const u = i(5); const c = m(u); const p = i(73); const f = m(p); function m(t) { return t && t.__esModule ? t : { default: t }; } const v = (function (t) { function e(t, i, o, s, a) { (0, r.default)(this, e); const h = (0, l.default)(this, (e.__proto__ || (0, n.default)(e)).call(this, t, i, o)); return h.setImages(s, a), h; } return (0, c.default)(e, t), (0, h.default)(e, [{ key: 'resize', value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.selected; const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.hover; const o = void 0 === this.imageObj.src || void 0 === this.imageObj.width || void 0 === this.imageObj.height; if (o) { const n = 2 * this.options.size; return this.width = n, this.height = n, void (this.radius = 0.5 * this.width); } this.needsRefresh(e, i) && this._resizeImage(); } }, { key: 'draw', value(t, e, i, o, n, s) { this.switchImages(o), this.resize(), this.left = e - this.width / 2, this.top = i - this.height / 2, this._drawRawCircle(t, e, i, s), t.save(), t.clip(), this._drawImageAtPosition(t, s), t.restore(), this._drawImageLabel(t, e, i, o, n), this.updateBoundingBox(e, i); } }, { key: 'updateBoundingBox', value(t, e) { this.boundingBox.top = e - this.options.size, this.boundingBox.left = t - this.options.size, this.boundingBox.right = t + this.options.size, this.boundingBox.bottom = e + this.options.size, this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left), this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width), this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelOffset); } }, { key: 'distanceToBorder', value(t, e) { return this.resize(t), 0.5 * this.width; } }]), e; }(f.default)); e.default = v; }, function (t, e, i) { Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(3); const n = m(o); const s = i(0); const r = m(s); const a = i(1); const h = m(a); const d = i(4); const l = m(d); const u = i(5); const c = m(u); const p = i(23); const f = m(p); function m(t) { return t && t.__esModule ? t : { default: t }; } const v = (function (t) { function e(t, i, o) { (0, r.default)(this, e); const s = (0, l.default)(this, (e.__proto__ || (0, n.default)(e)).call(this, t, i, o)); return s._setMargins(o), s; } return (0, c.default)(e, t), (0, h.default)(e, [{ key: 'resize', value(t, e, i) { if (this.needsRefresh(e, i)) { const o = this.getDimensionsFromLabel(t, e, i); const n = o.width + this.margin.right + this.margin.left; this.width = n, this.height = n, this.radius = this.width / 2; } } }, { key: 'draw', value(t, e, i, o, n, s) { this.resize(t, o, n), this.left = e - this.width / 2, this.top = i - this.height / 2, this.initContextForDraw(t, s), t.database(e - this.width / 2, i - this.height / 2, this.width, this.height), this.performFill(t, s), this.updateBoundingBox(e, i, t, o, n), this.labelModule.draw(t, this.left + this.textSize.width / 2 + this.margin.left, this.top + this.textSize.height / 2 + this.margin.top, o, n); } }, { key: 'distanceToBorder', value(t, e) { return this._distanceToBorder(t, e); } }]), e; }(f.default)); e.default = v; }, function (t, e, i) { Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(3); const n = m(o); const s = i(0); const r = m(s); const a = i(1); const h = m(a); const d = i(4); const l = m(d); const u = i(5); const c = m(u); const p = i(24); const f = m(p); function m(t) { return t && t.__esModule ? t : { default: t }; } const v = (function (t) { function e(t, i, o) { return (0, r.default)(this, e), (0, l.default)(this, (e.__proto__ || (0, n.default)(e)).call(this, t, i, o)); } return (0, c.default)(e, t), (0, h.default)(e, [{ key: 'draw', value(t, e, i, o, n, s) { this._drawShape(t, 'diamond', 4, e, i, o, n, s); } }, { key: 'distanceToBorder', value(t, e) { return this._distanceToBorder(t, e); } }]), e; }(f.default)); e.default = v; }, function (t, e, i) { Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(3); const n = m(o); const s = i(0); const r = m(s); const a = i(1); const h = m(a); const d = i(4); const l = m(d); const u = i(5); const c = m(u); const p = i(24); const f = m(p); function m(t) { return t && t.__esModule ? t : { default: t }; } const v = (function (t) { function e(t, i, o) { return (0, r.default)(this, e), (0, l.default)(this, (e.__proto__ || (0, n.default)(e)).call(this, t, i, o)); } return (0, c.default)(e, t), (0, h.default)(e, [{ key: 'draw', value(t, e, i, o, n, s) { this._drawShape(t, 'circle', 2, e, i, o, n, s); } }, { key: 'distanceToBorder', value(t, e) { return this.resize(t), this.options.size; } }]), e; }(f.default)); e.default = v; }, function (t, e, i) { Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(3); const n = m(o); const s = i(0); const r = m(s); const a = i(1); const h = m(a); const d = i(4); const l = m(d); const u = i(5); const c = m(u); const p = i(23); const f = m(p); function m(t) { return t && t.__esModule ? t : { default: t }; } const v = (function (t) { function e(t, i, o) { return (0, r.default)(this, e), (0, l.default)(this, (e.__proto__ || (0, n.default)(e)).call(this, t, i, o)); } return (0, c.default)(e, t), (0, h.default)(e, [{ key: 'resize', value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.selected; const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.hover; if (this.needsRefresh(e, i)) { const o = this.getDimensionsFromLabel(t, e, i); this.height = 2 * o.height, this.width = o.width + o.height, this.radius = 0.5 * this.width; } } }, { key: 'draw', value(t, e, i, o, n, s) { this.resize(t, o, n), this.left = e - 0.5 * this.width, this.top = i - 0.5 * this.height, this.initContextForDraw(t, s), t.ellipse_vis(this.left, this.top, this.width, this.height), this.performFill(t, s), this.updateBoundingBox(e, i, t, o, n), this.labelModule.draw(t, e, i, o, n); } }, { key: 'distanceToBorder', value(t, e) { this.resize(t); const i = 0.5 * this.width; const o = 0.5 * this.height; const n = Math.sin(e) * i; const s = Math.cos(e) * o; return i * o / Math.sqrt(n * n + s * s); } }]), e; }(f.default)); e.default = v; }, function (t, e, i) { Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(3); const n = m(o); const s = i(0); const r = m(s); const a = i(1); const h = m(a); const d = i(4); const l = m(d); const u = i(5); const c = m(u); const p = i(23); const f = m(p); function m(t) { return t && t.__esModule ? t : { default: t }; } const v = (function (t) { function e(t, i, o) { (0, r.default)(this, e); const s = (0, l.default)(this, (e.__proto__ || (0, n.default)(e)).call(this, t, i, o)); return s._setMargins(o), s; } return (0, c.default)(e, t), (0, h.default)(e, [{ key: 'resize', value(t, e, i) { this.needsRefresh(e, i) && (this.iconSize = { width: Number(this.options.icon.size), height: Number(this.options.icon.size) }, this.width = this.iconSize.width + this.margin.right + this.margin.left, this.height = this.iconSize.height + this.margin.top + this.margin.bottom, this.radius = 0.5 * this.width); } }, { key: 'draw', value(t, e, i, o, n, s) { if (this.resize(t, o, n), this.options.icon.size = this.options.icon.size || 50, this.left = e - this.width / 2, this.top = i - this.height / 2, this._icon(t, e, i, o, n, s), void 0 !== this.options.label) { const r = 5; this.labelModule.draw(t, this.left + this.iconSize.width / 2 + this.margin.left, i + this.height / 2 + r, o); } this.updateBoundingBox(e, i); } }, { key: 'updateBoundingBox', value(t, e) { if (this.boundingBox.top = e - 0.5 * this.options.icon.size, this.boundingBox.left = t - 0.5 * this.options.icon.size, this.boundingBox.right = t + 0.5 * this.options.icon.size, this.boundingBox.bottom = e + 0.5 * this.options.icon.size, void 0 !== this.options.label && this.labelModule.size.width > 0) { const i = 5; this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left), this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width), this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelModule.size.height + i); } } }, { key: '_icon', value(t, e, i, o, n, s) { const r = Number(this.options.icon.size); void 0 !== this.options.icon.code ? (t.font = `${(o ? 'bold ' : '') + r}px ${this.options.icon.face}`, t.fillStyle = this.options.icon.color || 'black', t.textAlign = 'center', t.textBaseline = 'middle', this.enableShadow(t, s), t.fillText(this.options.icon.code, e, i), this.disableShadow(t, s)) : console.error('When using the icon shape, you need to define the code in the icon options object. This can be done per node or globally.'); } }, { key: 'distanceToBorder', value(t, e) { return this._distanceToBorder(t, e); } }]), e; }(f.default)); e.default = v; }, function (t, e, i) { Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(3); const n = m(o); const s = i(0); const r = m(s); const a = i(1); const h = m(a); const d = i(4); const l = m(d); const u = i(5); const c = m(u); const p = i(73); const f = m(p); function m(t) { return t && t.__esModule ? t : { default: t }; } const v = (function (t) { function e(t, i, o, s, a) { (0, r.default)(this, e); const h = (0, l.default)(this, (e.__proto__ || (0, n.default)(e)).call(this, t, i, o)); return h.setImages(s, a), h; } return (0, c.default)(e, t), (0, h.default)(e, [{ key: 'resize', value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.selected; const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.hover; const o = void 0 === this.imageObj.src || void 0 === this.imageObj.width || void 0 === this.imageObj.height; if (o) { const n = 2 * this.options.size; return this.width = n, void (this.height = n); } this.needsRefresh(e, i) && this._resizeImage(); } }, { key: 'draw', value(t, e, i, o, n, s) { if (this.switchImages(o), this.resize(), this.left = e - this.width / 2, this.top = i - this.height / 2, !0 === this.options.shapeProperties.useBorderWithImage) { const r = this.options.borderWidth; const a = this.options.borderWidthSelected || 2 * this.options.borderWidth; const h = (o ? a : r) / this.body.view.scale; t.lineWidth = Math.min(this.width, h), t.beginPath(), t.strokeStyle = o ? this.options.color.highlight.border : n ? this.options.color.hover.border : this.options.color.border, t.fillStyle = o ? this.options.color.highlight.background : n ? this.options.color.hover.background : this.options.color.background, t.rect(this.left - 0.5 * t.lineWidth, this.top - 0.5 * t.lineWidth, this.width + t.lineWidth, this.height + t.lineWidth), t.fill(), this.performStroke(t, s), t.closePath(); } this._drawImageAtPosition(t, s), this._drawImageLabel(t, e, i, o, n), this.updateBoundingBox(e, i); } }, { key: 'updateBoundingBox', value(t, e) { this.resize(), this._updateBoundingBox(t, e), void 0 !== this.options.label && this.labelModule.size.width > 0 && (this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left), this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width), this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelOffset)); } }, { key: 'distanceToBorder', value(t, e) { return this._distanceToBorder(t, e); } }]), e; }(f.default)); e.default = v; }, function (t, e, i) { Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(3); const n = m(o); const s = i(0); const r = m(s); const a = i(1); const h = m(a); const d = i(4); const l = m(d); const u = i(5); const c = m(u); const p = i(24); const f = m(p); function m(t) { return t && t.__esModule ? t : { default: t }; } const v = (function (t) { function e(t, i, o) { return (0, r.default)(this, e), (0, l.default)(this, (e.__proto__ || (0, n.default)(e)).call(this, t, i, o)); } return (0, c.default)(e, t), (0, h.default)(e, [{ key: 'draw', value(t, e, i, o, n, s) { this._drawShape(t, 'square', 2, e, i, o, n, s); } }, { key: 'distanceToBorder', value(t, e) { return this._distanceToBorder(t, e); } }]), e; }(f.default)); e.default = v; }, function (t, e, i) { Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(3); const n = m(o); const s = i(0); const r = m(s); const a = i(1); const h = m(a); const d = i(4); const l = m(d); const u = i(5); const c = m(u); const p = i(24); const f = m(p); function m(t) { return t && t.__esModule ? t : { default: t }; } const v = (function (t) { function e(t, i, o) { return (0, r.default)(this, e), (0, l.default)(this, (e.__proto__ || (0, n.default)(e)).call(this, t, i, o)); } return (0, c.default)(e, t), (0, h.default)(e, [{ key: 'draw', value(t, e, i, o, n, s) { this._drawShape(t, 'hexagon', 4, e, i, o, n, s); } }, { key: 'distanceToBorder', value(t, e) { return this._distanceToBorder(t, e); } }]), e; }(f.default)); e.default = v; }, function (t, e, i) { Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(3); const n = m(o); const s = i(0); const r = m(s); const a = i(1); const h = m(a); const d = i(4); const l = m(d); const u = i(5); const c = m(u); const p = i(24); const f = m(p); function m(t) { return t && t.__esModule ? t : { default: t }; } const v = (function (t) { function e(t, i, o) { return (0, r.default)(this, e), (0, l.default)(this, (e.__proto__ || (0, n.default)(e)).call(this, t, i, o)); } return (0, c.default)(e, t), (0, h.default)(e, [{ key: 'draw', value(t, e, i, o, n, s) { this._drawShape(t, 'star', 4, e, i, o, n, s); } }, { key: 'distanceToBorder', value(t, e) { return this._distanceToBorder(t, e); } }]), e; }(f.default)); e.default = v; }, function (t, e, i) { Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(3); const n = m(o); const s = i(0); const r = m(s); const a = i(1); const h = m(a); const d = i(4); const l = m(d); const u = i(5); const c = m(u); const p = i(23); const f = m(p); function m(t) { return t && t.__esModule ? t : { default: t }; } const v = (function (t) { function e(t, i, o) { (0, r.default)(this, e); const s = (0, l.default)(this, (e.__proto__ || (0, n.default)(e)).call(this, t, i, o)); return s._setMargins(o), s; } return (0, c.default)(e, t), (0, h.default)(e, [{ key: 'resize', value(t, e, i) { this.needsRefresh(e, i) && (this.textSize = this.labelModule.getTextSize(t, e, i), this.width = this.textSize.width + this.margin.right + this.margin.left, this.height = this.textSize.height + this.margin.top + this.margin.bottom, this.radius = 0.5 * this.width); } }, { key: 'draw', value(t, e, i, o, n, s) { this.resize(t, o, n), this.left = e - this.width / 2, this.top = i - this.height / 2, this.enableShadow(t, s), this.labelModule.draw(t, this.left + this.textSize.width / 2 + this.margin.left, this.top + this.textSize.height / 2 + this.margin.top, o, n), this.disableShadow(t, s), this.updateBoundingBox(e, i, t, o, n); } }, { key: 'distanceToBorder', value(t, e) { return this._distanceToBorder(t, e); } }]), e; }(f.default)); e.default = v; }, function (t, e, i) { Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(3); const n = m(o); const s = i(0); const r = m(s); const a = i(1); const h = m(a); const d = i(4); const l = m(d); const u = i(5); const c = m(u); const p = i(24); const f = m(p); function m(t) { return t && t.__esModule ? t : { default: t }; } const v = (function (t) { function e(t, i, o) { return (0, r.default)(this, e), (0, l.default)(this, (e.__proto__ || (0, n.default)(e)).call(this, t, i, o)); } return (0, c.default)(e, t), (0, h.default)(e, [{ key: 'draw', value(t, e, i, o, n, s) { this._drawShape(t, 'triangle', 3, e, i, o, n, s); } }, { key: 'distanceToBorder', value(t, e) { return this._distanceToBorder(t, e); } }]), e; }(f.default)); e.default = v; }, function (t, e, i) { Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(3); const n = m(o); const s = i(0); const r = m(s); const a = i(1); const h = m(a); const d = i(4); const l = m(d); const u = i(5); const c = m(u); const p = i(24); const f = m(p); function m(t) { return t && t.__esModule ? t : { default: t }; } const v = (function (t) { function e(t, i, o) { return (0, r.default)(this, e), (0, l.default)(this, (e.__proto__ || (0, n.default)(e)).call(this, t, i, o)); } return (0, c.default)(e, t), (0, h.default)(e, [{ key: 'draw', value(t, e, i, o, n, s) { this._drawShape(t, 'triangleDown', 3, e, i, o, n, s); } }, { key: 'distanceToBorder', value(t, e) { return this._distanceToBorder(t, e); } }]), e; }(f.default)); e.default = v; }, function (t, e, i) {
      Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(0); const n = a(o); const s = i(1); const r = a(s); function a(t) { return t && t.__esModule ? t : { default: t }; } const h = i(2); const d = i(11); const l = i(12); const u = i(74).default; const c = (function () {
        function t(e, i, o) {
          const s = this; (0, n.default)(this, t), this.body = e, this.images = i, this.groups = o, this.body.functions.createEdge = this.create.bind(this), this.edgesListeners = { add(t, e) { s.add(e.items); }, update(t, e) { s.update(e.items); }, remove(t, e) { s.remove(e.items); } }, this.options = {}, this.defaultOptions = {
            arrows: { to: { enabled: !1, scaleFactor: 1, type: 'arrow' }, middle: { enabled: !1, scaleFactor: 1, type: 'arrow' }, from: { enabled: !1, scaleFactor: 1, type: 'arrow' } },
            arrowStrikethrough: !0,
            color: {
              color: '#848484', highlight: '#848484', hover: '#848484', inherit: 'from', opacity: 1,
            },
            dashes: !1,
            font: {
              color: '#343434',
              size: 14,
              face: 'arial',
              background: 'none',
              strokeWidth: 2,
              strokeColor: '#ffffff',
              align: 'horizontal',
              multi: !1,
              vadjust: 0,
              bold: { mod: 'bold' },
              boldital: { mod: 'bold italic' },
              ital: { mod: 'italic' },
              mono: {
                mod: '', size: 15, face: 'courier new', vadjust: 2,
              },
            },
            hidden: !1,
            hoverWidth: 1.5,
            label: void 0,
            labelHighlightBold: !0,
            length: void 0,
            physics: !0,
            scaling: {
              min: 1,
              max: 15,
              label: {
                enabled: !0, min: 14, max: 30, maxVisible: 30, drawThreshold: 5,
              },
              customScalingFunction(t, e, i, o) { if (e === t) return 0.5; const n = 1 / (e - t); return Math.max(0, (o - t) * n); },
            },
            selectionWidth: 1.5,
            selfReferenceSize: 20,
            shadow: {
              enabled: !1, color: 'rgba(0,0,0,0.5)', size: 10, x: 5, y: 5,
            },
            smooth: {
              enabled: !0, type: 'dynamic', forceDirection: 'none', roundness: 0.5,
            },
            title: void 0,
            width: 1,
            value: void 0,
          }, h.deepExtend(this.options, this.defaultOptions), this.bindEventListeners();
        } return (0, r.default)(t, [{ key: 'bindEventListeners', value() { const t = this; this.body.emitter.on('_forceDisableDynamicCurves', function (e) { const i = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]; e === 'dynamic' && (e = 'continuous'); let o = !1; for (const n in t.body.edges) if (t.body.edges.hasOwnProperty(n)) { const s = t.body.edges[n]; const r = t.body.data.edges._data[n]; if (void 0 !== r) { const a = r.smooth; void 0 !== a && !0 === a.enabled && a.type === 'dynamic' && (void 0 === e ? s.setOptions({ smooth: !1 }) : s.setOptions({ smooth: { type: e } }), o = !0); } }!0 === i && !0 === o && t.body.emitter.emit('_dataChanged'); }), this.body.emitter.on('_dataUpdated', () => { t.reconnectEdges(); }), this.body.emitter.on('refreshEdges', this.refresh.bind(this)), this.body.emitter.on('refresh', this.refresh.bind(this)), this.body.emitter.on('destroy', () => { h.forEach(t.edgesListeners, (e, i) => { t.body.data.edges && t.body.data.edges.off(i, e); }), delete t.body.functions.createEdge, delete t.edgesListeners.add, delete t.edgesListeners.update, delete t.edgesListeners.remove, delete t.edgesListeners; }); } }, { key: 'setOptions', value(t) { if (void 0 !== t) { u.parseOptions(this.options, t, !0, this.defaultOptions, !0); let e = !1; if (void 0 !== t.smooth) for (const i in this.body.edges) this.body.edges.hasOwnProperty(i) && (e = this.body.edges[i].updateEdgeType() || e); if (void 0 !== t.font) for (const o in this.body.edges) this.body.edges.hasOwnProperty(o) && this.body.edges[o].updateLabelModule(); void 0 === t.hidden && void 0 === t.physics && !0 !== e || this.body.emitter.emit('_dataChanged'); } } }, { key: 'setData', value(t) { const e = this; const i = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; const o = this.body.data.edges; if (t instanceof d || t instanceof l) this.body.data.edges = t; else if (Array.isArray(t)) this.body.data.edges = new d(), this.body.data.edges.add(t); else { if (t) throw new TypeError('Array or DataSet expected'); this.body.data.edges = new d(); } if (o && h.forEach(this.edgesListeners, (t, e) => { o.off(e, t); }), this.body.edges = {}, this.body.data.edges) { h.forEach(this.edgesListeners, (t, i) => { e.body.data.edges.on(i, t); }); const n = this.body.data.edges.getIds(); this.add(n, !0); } this.body.emitter.emit('_adjustEdgesForHierarchicalLayout'), !1 === i && this.body.emitter.emit('_dataChanged'); } }, { key: 'add', value(t) { for (var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], i = this.body.edges, o = this.body.data.edges, n = 0; n < t.length; n++) { const s = t[n]; const r = i[s]; r && r.disconnect(); const a = o.get(s, { showInternalIds: !0 }); i[s] = this.create(a); } this.body.emitter.emit('_adjustEdgesForHierarchicalLayout'), !1 === e && this.body.emitter.emit('_dataChanged'); } }, { key: 'update', value(t) { for (var e = this.body.edges, i = this.body.data.edges, o = !1, n = 0; n < t.length; n++) { const s = t[n]; const r = i.get(s); const a = e[s]; void 0 !== a ? (a.disconnect(), o = a.setOptions(r) || o, a.connect()) : (this.body.edges[s] = this.create(r), o = !0); }!0 === o ? (this.body.emitter.emit('_adjustEdgesForHierarchicalLayout'), this.body.emitter.emit('_dataChanged')) : this.body.emitter.emit('_dataUpdated'); } }, { key: 'remove', value(t) { const e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]; if (t.length !== 0) { const i = this.body.edges; h.forEach(t, (t) => { const e = i[t]; void 0 !== e && e.remove(); }), e && this.body.emitter.emit('_dataChanged'); } } }, { key: 'refresh', value() { const t = this; h.forEach(this.body.edges, (e, i) => { const o = t.body.data.edges._data[i]; void 0 !== o && e.setOptions(o); }); } }, { key: 'create', value(t) { return new u(t, this.body, this.options, this.defaultOptions); } }, { key: 'reconnectEdges', value() { let t; const e = this.body.nodes; const i = this.body.edges; for (t in e)e.hasOwnProperty(t) && (e[t].edges = []); for (t in i) if (i.hasOwnProperty(t)) { const o = i[t]; o.from = null, o.to = null, o.connect(); } } }, { key: 'getConnectedNodes', value(t) { const e = []; if (void 0 !== this.body.edges[t]) { const i = this.body.edges[t]; void 0 !== i.fromId && e.push(i.fromId), void 0 !== i.toId && e.push(i.toId); } return e; } }, { key: '_updateState', value() { this._addMissingEdges(), this._removeInvalidEdges(); } }, { key: '_removeInvalidEdges', value() { const t = this; const e = []; h.forEach(this.body.edges, (i, o) => { const n = t.body.nodes[i.toId]; const s = t.body.nodes[i.fromId]; void 0 !== n && !0 === n.isCluster || void 0 !== s && !0 === s.isCluster || void 0 !== n && void 0 !== s || e.push(o); }), this.remove(e, !1); } }, { key: '_addMissingEdges', value() { const t = this.body.edges; const e = this.body.data.edges; const i = []; e.forEach((e, o) => { const n = t[o]; void 0 === n && i.push(o); }), this.add(i, !0); } }]), t;
      }()); e.default = c;
    }, function (t, e, i) { Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(30); const n = g(o); const s = i(3); const r = g(s); const a = i(0); const h = g(a); const d = i(1); const l = g(d); const u = i(4); const c = g(u); const p = i(5); const f = g(p); const m = i(216); const v = g(m); function g(t) { return t && t.__esModule ? t : { default: t }; } const y = (function (t) { function e(t, i, o) { return (0, h.default)(this, e), (0, c.default)(this, (e.__proto__ || (0, r.default)(e)).call(this, t, i, o)); } return (0, f.default)(e, t), (0, l.default)(e, [{ key: '_line', value(t, e, i) { const o = i[0]; const n = i[1]; this._bezierCurve(t, e, o, n); } }, { key: '_getViaCoordinates', value() { const t = this.from.x - this.to.x; const e = this.from.y - this.to.y; let i = void 0; let o = void 0; let n = void 0; let s = void 0; const r = this.options.smooth.roundness; return (Math.abs(t) > Math.abs(e) || !0 === this.options.smooth.forceDirection || this.options.smooth.forceDirection === 'horizontal') && this.options.smooth.forceDirection !== 'vertical' ? (o = this.from.y, s = this.to.y, i = this.from.x - r * t, n = this.to.x + r * t) : (o = this.from.y - r * e, s = this.to.y + r * e, i = this.from.x, n = this.to.x), [{ x: i, y: o }, { x: n, y: s }]; } }, { key: 'getViaNode', value() { return this._getViaCoordinates(); } }, { key: '_findBorderPosition', value(t, e) { return this._findBorderPositionBezier(t, e); } }, { key: '_getDistanceToEdge', value(t, e, i, o, s, r) { const a = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : this._getViaCoordinates(); const h = (0, n.default)(a, 2); const d = h[0]; const l = h[1]; return this._getDistanceToBezierEdge(t, e, i, o, s, r, d, l); } }, { key: 'getPoint', value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this._getViaCoordinates(); const i = (0, n.default)(e, 2); const o = i[0]; const s = i[1]; const r = t; const a = []; a[0] = Math.pow(1 - r, 3), a[1] = 3 * r * Math.pow(1 - r, 2), a[2] = 3 * Math.pow(r, 2) * (1 - r), a[3] = Math.pow(r, 3); const h = a[0] * this.fromPoint.x + a[1] * o.x + a[2] * s.x + a[3] * this.toPoint.x; const d = a[0] * this.fromPoint.y + a[1] * o.y + a[2] * s.y + a[3] * this.toPoint.y; return { x: h, y: d }; } }]), e; }(v.default)); e.default = y; }, function (t, e, i) { Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(3); const n = m(o); const s = i(0); const r = m(s); const a = i(1); const h = m(a); const d = i(4); const l = m(d); const u = i(5); const c = m(u); const p = i(75); const f = m(p); function m(t) { return t && t.__esModule ? t : { default: t }; } const v = (function (t) { function e(t, i, o) { return (0, r.default)(this, e), (0, l.default)(this, (e.__proto__ || (0, n.default)(e)).call(this, t, i, o)); } return (0, c.default)(e, t), (0, h.default)(e, [{ key: '_getDistanceToBezierEdge', value(t, e, i, o, n, s, r, a) { let h = 1e9; let d = void 0; let l = void 0; let u = void 0; let c = void 0; let p = void 0; let f = t; let m = e; const v = [0, 0, 0, 0]; for (l = 1; l < 10; l++)u = 0.1 * l, v[0] = Math.pow(1 - u, 3), v[1] = 3 * u * Math.pow(1 - u, 2), v[2] = 3 * Math.pow(u, 2) * (1 - u), v[3] = Math.pow(u, 3), c = v[0] * t + v[1] * r.x + v[2] * a.x + v[3] * i, p = v[0] * e + v[1] * r.y + v[2] * a.y + v[3] * o, l > 0 && (d = this._getDistanceToLine(f, m, c, p, n, s), h = d < h ? d : h), f = c, m = p; return h; } }]), e; }(f.default)); e.default = v; }, function (t, e, i) {
      Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(30); const n = g(o); const s = i(3); const r = g(s); const a = i(0); const h = g(a); const d = i(1); const l = g(d); const u = i(4); const c = g(u); const p = i(5); const f = g(p); const m = i(75); const v = g(m); function g(t) { return t && t.__esModule ? t : { default: t }; } const y = (function (t) {
        function e(t, i, o) { (0, h.default)(this, e); const n = (0, c.default)(this, (e.__proto__ || (0, r.default)(e)).call(this, t, i, o)); return n._boundFunction = function () { n.positionBezierNode(); }, n.body.emitter.on('_repositionBezierNodes', n._boundFunction), n; } return (0, f.default)(e, t), (0, l.default)(e, [{ key: 'setOptions', value(t) { let e = !1; this.options.physics !== t.physics && (e = !0), this.options = t, this.id = this.options.id, this.from = this.body.nodes[this.options.from], this.to = this.body.nodes[this.options.to], this.setupSupportNode(), this.connect(), !0 === e && (this.via.setOptions({ physics: this.options.physics }), this.positionBezierNode()); } }, { key: 'connect', value() { this.from = this.body.nodes[this.options.from], this.to = this.body.nodes[this.options.to], void 0 === this.from || void 0 === this.to || !1 === this.options.physics ? this.via.setOptions({ physics: !1 }) : this.from.id === this.to.id ? this.via.setOptions({ physics: !1 }) : this.via.setOptions({ physics: !0 }); } }, { key: 'cleanup', value() { return this.body.emitter.off('_repositionBezierNodes', this._boundFunction), void 0 !== this.via && (delete this.body.nodes[this.via.id], this.via = void 0, !0); } }, {
          key: 'setupSupportNode',
          value() {
            if (void 0 === this.via) {
              const t = `edgeId:${this.id}`; const e = this.body.functions.createNode({
                id: t, shape: 'circle', physics: !0, hidden: !0,
              }); this.body.nodes[t] = e, this.via = e, this.via.parentEdgeId = this.id, this.positionBezierNode();
            }
          }, 
        }, { key: 'positionBezierNode', value() { void 0 !== this.via && void 0 !== this.from && void 0 !== this.to ? (this.via.x = 0.5 * (this.from.x + this.to.x), this.via.y = 0.5 * (this.from.y + this.to.y)) : void 0 !== this.via && (this.via.x = 0, this.via.y = 0); } }, { key: '_line', value(t, e, i) { this._bezierCurve(t, e, i); } }, { key: 'getViaNode', value() { return this.via; } }, { key: 'getPoint', value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.via; const i = t; let o = void 0; let s = void 0; if (this.from === this.to) { const r = this._getCircleData(this.from); const a = (0, n.default)(r, 3); const h = a[0]; const d = a[1]; const l = a[2]; const u = 2 * Math.PI * (1 - i); o = h + l * Math.sin(u), s = d + l - l * (1 - Math.cos(u)); } else o = Math.pow(1 - i, 2) * this.fromPoint.x + 2 * i * (1 - i) * e.x + Math.pow(i, 2) * this.toPoint.x, s = Math.pow(1 - i, 2) * this.fromPoint.y + 2 * i * (1 - i) * e.y + Math.pow(i, 2) * this.toPoint.y; return { x: o, y: s }; } }, { key: '_findBorderPosition', value(t, e) { return this._findBorderPositionBezier(t, e, this.via); } }, { key: '_getDistanceToEdge', value(t, e, i, o, n, s) { return this._getDistanceToBezierEdge(t, e, i, o, n, s, this.via); } }]), e;
      }(v.default)); e.default = y;
    }, function (t, e, i) { Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(3); const n = m(o); const s = i(0); const r = m(s); const a = i(1); const h = m(a); const d = i(4); const l = m(d); const u = i(5); const c = m(u); const p = i(75); const f = m(p); function m(t) { return t && t.__esModule ? t : { default: t }; } const v = (function (t) { function e(t, i, o) { return (0, r.default)(this, e), (0, l.default)(this, (e.__proto__ || (0, n.default)(e)).call(this, t, i, o)); } return (0, c.default)(e, t), (0, h.default)(e, [{ key: '_line', value(t, e, i) { this._bezierCurve(t, e, i); } }, { key: 'getViaNode', value() { return this._getViaCoordinates(); } }, { key: '_getViaCoordinates', value() { let t = void 0; let e = void 0; const i = this.options.smooth.roundness; const o = this.options.smooth.type; let n = Math.abs(this.from.x - this.to.x); let s = Math.abs(this.from.y - this.to.y); if (o === 'discrete' || o === 'diagonalCross') { let r = void 0; let a = void 0; r = a = n <= s ? i * s : i * n, this.from.x > this.to.x && (r = -r), this.from.y >= this.to.y && (a = -a), t = this.from.x + r, e = this.from.y + a, o === 'discrete' && (n <= s ? t = n < i * s ? this.from.x : t : e = s < i * n ? this.from.y : e); } else if (o === 'straightCross') { let h = (1 - i) * n; let d = (1 - i) * s; n <= s ? (h = 0, this.from.y < this.to.y && (d = -d)) : (this.from.x < this.to.x && (h = -h), d = 0), t = this.to.x + h, e = this.to.y + d; } else if (o === 'horizontal') { let l = (1 - i) * n; this.from.x < this.to.x && (l = -l), t = this.to.x + l, e = this.from.y; } else if (o === 'vertical') { let u = (1 - i) * s; this.from.y < this.to.y && (u = -u), t = this.from.x, e = this.to.y + u; } else if (o === 'curvedCW') { n = this.to.x - this.from.x, s = this.from.y - this.to.y; const c = Math.sqrt(n * n + s * s); const p = Math.PI; const f = Math.atan2(s, n); const m = (f + (0.5 * i + 0.5) * p) % (2 * p); t = this.from.x + (0.5 * i + 0.5) * c * Math.sin(m), e = this.from.y + (0.5 * i + 0.5) * c * Math.cos(m); } else if (o === 'curvedCCW') { n = this.to.x - this.from.x, s = this.from.y - this.to.y; const v = Math.sqrt(n * n + s * s); const g = Math.PI; const y = Math.atan2(s, n); const b = (y + (0.5 * -i + 0.5) * g) % (2 * g); t = this.from.x + (0.5 * i + 0.5) * v * Math.sin(b), e = this.from.y + (0.5 * i + 0.5) * v * Math.cos(b); } else { let _ = void 0; let w = void 0; _ = w = n <= s ? i * s : i * n, this.from.x > this.to.x && (_ = -_), this.from.y >= this.to.y && (w = -w), t = this.from.x + _, e = this.from.y + w, n <= s ? t = this.from.x <= this.to.x ? this.to.x < t ? this.to.x : t : this.to.x > t ? this.to.x : t : e = this.from.y >= this.to.y ? this.to.y > e ? this.to.y : e : this.to.y < e ? this.to.y : e; } return { x: t, y: e }; } }, { key: '_findBorderPosition', value(t, e) { const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; return this._findBorderPositionBezier(t, e, i.via); } }, { key: '_getDistanceToEdge', value(t, e, i, o, n, s) { const r = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : this._getViaCoordinates(); return this._getDistanceToBezierEdge(t, e, i, o, n, s, r); } }, { key: 'getPoint', value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this._getViaCoordinates(); const i = t; const o = Math.pow(1 - i, 2) * this.fromPoint.x + 2 * i * (1 - i) * e.x + Math.pow(i, 2) * this.toPoint.x; const n = Math.pow(1 - i, 2) * this.fromPoint.y + 2 * i * (1 - i) * e.y + Math.pow(i, 2) * this.toPoint.y; return { x: o, y: n }; } }]), e; }(f.default)); e.default = v; }, function (t, e, i) { Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(3); const n = m(o); const s = i(0); const r = m(s); const a = i(1); const h = m(a); const d = i(4); const l = m(d); const u = i(5); const c = m(u); const p = i(118); const f = m(p); function m(t) { return t && t.__esModule ? t : { default: t }; } const v = (function (t) { function e(t, i, o) { return (0, r.default)(this, e), (0, l.default)(this, (e.__proto__ || (0, n.default)(e)).call(this, t, i, o)); } return (0, c.default)(e, t), (0, h.default)(e, [{ key: '_line', value(t, e) { t.beginPath(), t.moveTo(this.fromPoint.x, this.fromPoint.y), t.lineTo(this.toPoint.x, this.toPoint.y), this.enableShadow(t, e), t.stroke(), this.disableShadow(t, e); } }, { key: 'getViaNode', value() {} }, { key: 'getPoint', value(t) { return { x: (1 - t) * this.fromPoint.x + t * this.toPoint.x, y: (1 - t) * this.fromPoint.y + t * this.toPoint.y }; } }, { key: '_findBorderPosition', value(t, e) { let i = this.to; let o = this.from; t.id === this.from.id && (i = this.from, o = this.to); const n = Math.atan2(i.y - o.y, i.x - o.x); const s = i.x - o.x; const r = i.y - o.y; const a = Math.sqrt(s * s + r * r); const h = t.distanceToBorder(e, n); const d = (a - h) / a; const l = {}; return l.x = (1 - d) * o.x + d * i.x, l.y = (1 - d) * o.y + d * i.y, l; } }, { key: '_getDistanceToEdge', value(t, e, i, o, n, s) { return this._getDistanceToLine(t, e, i, o, n, s); } }]), e; }(f.default)); e.default = v; }, function (t, e, i) {
      Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(8); const n = d(o); const s = i(0); const r = d(s); const a = i(1); const h = d(a); function d(t) { return t && t.__esModule ? t : { default: t }; } const l = i(120).default; const u = i(221).default; const c = i(222).default; const p = i(223).default; const f = i(224).default; const m = i(121).default; const v = i(225).default; const g = i(226).default; const y = i(2); const b = i(119).default; const
        _ = (function () {
          function t(e) {
            (0, r.default)(this, t), this.body = e, this.physicsBody = {
              physicsNodeIndices: [], physicsEdgeIndices: [], forces: {}, velocities: {},
            }, this.physicsEnabled = !0, this.simulationInterval = 1e3 / 60, this.requiresTimeout = !0, this.previousStates = {}, this.referenceState = {}, this.freezeCache = {}, this.renderTimer = void 0, this.adaptiveTimestep = !1, this.adaptiveTimestepEnabled = !1, this.adaptiveCounter = 0, this.adaptiveInterval = 3, this.stabilized = !1, this.startedStabilization = !1, this.stabilizationIterations = 0, this.ready = !1, this.options = {}, this.defaultOptions = {
              enabled: !0,
              barnesHut: {
                theta: 0.5, gravitationalConstant: -2e3, centralGravity: 0.3, springLength: 95, springConstant: 0.04, damping: 0.09, avoidOverlap: 0,
              },
              forceAtlas2Based: {
                theta: 0.5, gravitationalConstant: -50, centralGravity: 0.01, springConstant: 0.08, springLength: 100, damping: 0.4, avoidOverlap: 0,
              },
              repulsion: {
                centralGravity: 0.2, springLength: 200, springConstant: 0.05, nodeDistance: 100, damping: 0.09, avoidOverlap: 0,
              },
              hierarchicalRepulsion: {
                centralGravity: 0, springLength: 100, springConstant: 0.01, nodeDistance: 120, damping: 0.09,
              },
              maxVelocity: 50,
              minVelocity: 0.75,
              solver: 'barnesHut',
              stabilization: {
                enabled: !0, iterations: 1e3, updateInterval: 50, onlyDynamicEdges: !1, fit: !0,
              },
              timestep: 0.5,
              adaptiveTimestep: !0,
            }, y.extend(this.options, this.defaultOptions), this.timestep = 0.5, this.layoutFailed = !1, this.bindEventListeners();
          } return (0, h.default)(t, [{ key: 'bindEventListeners', value() { const t = this; this.body.emitter.on('initPhysics', () => { t.initPhysics(); }), this.body.emitter.on('_layoutFailed', () => { t.layoutFailed = !0; }), this.body.emitter.on('resetPhysics', () => { t.stopSimulation(), t.ready = !1; }), this.body.emitter.on('disablePhysics', () => { t.physicsEnabled = !1, t.stopSimulation(); }), this.body.emitter.on('restorePhysics', () => { t.setOptions(t.options), !0 === t.ready && t.startSimulation(); }), this.body.emitter.on('startSimulation', () => { !0 === t.ready && t.startSimulation(); }), this.body.emitter.on('stopSimulation', () => { t.stopSimulation(); }), this.body.emitter.on('destroy', () => { t.stopSimulation(!1), t.body.emitter.off(); }), this.body.emitter.on('_dataChanged', () => { t.updatePhysicsData(); }); } }, { key: 'setOptions', value(t) { void 0 !== t && (!1 === t ? (this.options.enabled = !1, this.physicsEnabled = !1, this.stopSimulation()) : !0 === t ? (this.options.enabled = !0, this.physicsEnabled = !0, this.startSimulation()) : (this.physicsEnabled = !0, y.selectiveNotDeepExtend(['stabilization'], this.options, t), y.mergeOptions(this.options, t, 'stabilization'), void 0 === t.enabled && (this.options.enabled = !0), !1 === this.options.enabled && (this.physicsEnabled = !1, this.stopSimulation()), this.timestep = this.options.timestep)), this.init(); } }, { key: 'init', value() { let t; this.options.solver === 'forceAtlas2Based' ? (t = this.options.forceAtlas2Based, this.nodesSolver = new v(this.body, this.physicsBody, t), this.edgesSolver = new p(this.body, this.physicsBody, t), this.gravitySolver = new g(this.body, this.physicsBody, t)) : this.options.solver === 'repulsion' ? (t = this.options.repulsion, this.nodesSolver = new u(this.body, this.physicsBody, t), this.edgesSolver = new p(this.body, this.physicsBody, t), this.gravitySolver = new m(this.body, this.physicsBody, t)) : this.options.solver === 'hierarchicalRepulsion' ? (t = this.options.hierarchicalRepulsion, this.nodesSolver = new c(this.body, this.physicsBody, t), this.edgesSolver = new f(this.body, this.physicsBody, t), this.gravitySolver = new m(this.body, this.physicsBody, t)) : (t = this.options.barnesHut, this.nodesSolver = new l(this.body, this.physicsBody, t), this.edgesSolver = new p(this.body, this.physicsBody, t), this.gravitySolver = new m(this.body, this.physicsBody, t)), this.modelOptions = t; } }, { key: 'initPhysics', value() { !0 === this.physicsEnabled && !0 === this.options.enabled ? !0 === this.options.stabilization.enabled ? this.stabilize() : (this.stabilized = !1, this.ready = !0, this.body.emitter.emit('fit', {}, this.layoutFailed), this.startSimulation()) : (this.ready = !0, this.body.emitter.emit('fit')); } }, { key: 'startSimulation', value() { !0 === this.physicsEnabled && !0 === this.options.enabled ? (this.stabilized = !1, this.adaptiveTimestep = !1, this.body.emitter.emit('_resizeNodes'), void 0 === this.viewFunction && (this.viewFunction = this.simulationStep.bind(this), this.body.emitter.on('initRedraw', this.viewFunction), this.body.emitter.emit('_startRendering'))) : this.body.emitter.emit('_redraw'); } }, { key: 'stopSimulation', value() { const t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0]; this.stabilized = !0, !0 === t && this._emitStabilized(), void 0 !== this.viewFunction && (this.body.emitter.off('initRedraw', this.viewFunction), this.viewFunction = void 0, !0 === t && this.body.emitter.emit('_stopRendering')); } }, { key: 'simulationStep', value() { const t = Date.now(); this.physicsTick(); const e = Date.now() - t; (e < 0.4 * this.simulationInterval || !0 === this.runDoubleSpeed) && !1 === this.stabilized && (this.physicsTick(), this.runDoubleSpeed = !0), !0 === this.stabilized && this.stopSimulation(); } }, { key: '_emitStabilized', value() { const t = this; const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.stabilizationIterations; (this.stabilizationIterations > 1 || !0 === this.startedStabilization) && setTimeout(() => { t.body.emitter.emit('stabilized', { iterations: e }), t.startedStabilization = !1, t.stabilizationIterations = 0; }, 0); } }, { key: 'physicsStep', value() { this.gravitySolver.solve(), this.nodesSolver.solve(), this.edgesSolver.solve(), this.moveNodes(); } }, { key: 'adjustTimeStep', value() { const t = 1.2; !0 === this._evaluateStepQuality() ? this.timestep = t * this.timestep : this.timestep / t < this.options.timestep ? this.timestep = this.options.timestep : (this.adaptiveCounter = -1, this.timestep = Math.max(this.options.timestep, this.timestep / t)); } }, { key: 'physicsTick', value() { if (this._startStabilizing(), !0 !== this.stabilized) { if (!0 === this.adaptiveTimestep && !0 === this.adaptiveTimestepEnabled) { const t = this.adaptiveCounter % this.adaptiveInterval === 0; t ? (this.timestep = 2 * this.timestep, this.physicsStep(), this.revert(), this.timestep = 0.5 * this.timestep, this.physicsStep(), this.physicsStep(), this.adjustTimeStep()) : this.physicsStep(), this.adaptiveCounter += 1; } else this.timestep = this.options.timestep, this.physicsStep(); !0 === this.stabilized && this.revert(), this.stabilizationIterations++; } } }, { key: 'updatePhysicsData', value() { this.physicsBody.forces = {}, this.physicsBody.physicsNodeIndices = [], this.physicsBody.physicsEdgeIndices = []; const t = this.body.nodes; const e = this.body.edges; for (const i in t)t.hasOwnProperty(i) && !0 === t[i].options.physics && this.physicsBody.physicsNodeIndices.push(t[i].id); for (const o in e)e.hasOwnProperty(o) && !0 === e[o].options.physics && this.physicsBody.physicsEdgeIndices.push(e[o].id); for (let n = 0; n < this.physicsBody.physicsNodeIndices.length; n++) { const s = this.physicsBody.physicsNodeIndices[n]; this.physicsBody.forces[s] = { x: 0, y: 0 }, void 0 === this.physicsBody.velocities[s] && (this.physicsBody.velocities[s] = { x: 0, y: 0 }); } for (const r in this.physicsBody.velocities) void 0 === t[r] && delete this.physicsBody.velocities[r]; } }, { key: 'revert', value() { const t = (0, n.default)(this.previousStates); const e = this.body.nodes; const i = this.physicsBody.velocities; this.referenceState = {}; for (let o = 0; o < t.length; o++) { const s = t[o]; void 0 !== e[s] ? !0 === e[s].options.physics && (this.referenceState[s] = { positions: { x: e[s].x, y: e[s].y } }, i[s].x = this.previousStates[s].vx, i[s].y = this.previousStates[s].vy, e[s].x = this.previousStates[s].x, e[s].y = this.previousStates[s].y) : delete this.previousStates[s]; } } }, { key: '_evaluateStepQuality', value() { let t = void 0; let e = void 0; let i = void 0; const o = this.body.nodes; const n = this.referenceState; const s = 0.3; for (const r in this.referenceState) if (this.referenceState.hasOwnProperty(r) && void 0 !== o[r] && (t = o[r].x - n[r].positions.x, e = o[r].y - n[r].positions.y, i = Math.sqrt(Math.pow(t, 2) + Math.pow(e, 2)), i > s)) return !1; return !0; } }, { key: 'moveNodes', value() { for (var t = this.physicsBody.physicsNodeIndices, e = 0, i = 0, o = 5, n = 0; n < t.length; n++) { const s = t[n]; const r = this._performStep(s); e = Math.max(e, r), i += r; } this.adaptiveTimestepEnabled = i / t.length < o, this.stabilized = e < this.options.minVelocity; } }, { key: 'calculateComponentVelocity', value(t, e, i) { const o = this.modelOptions.damping * t; const n = (e - o) / i; t += n * this.timestep; const s = this.options.maxVelocity || 1e9; return Math.abs(t) > s && (t = t > 0 ? s : -s), t; } }, {
            key: '_performStep',
            value(t) {
              const e = this.body.nodes[t]; const i = this.physicsBody.forces[t]; const o = this.physicsBody.velocities[t]; this.previousStates[t] = {
                x: e.x, y: e.y, vx: o.x, vy: o.y,
              }, !1 === e.options.fixed.x ? (o.x = this.calculateComponentVelocity(o.x, i.x, e.options.mass), e.x += o.x * this.timestep) : (i.x = 0, o.x = 0), !1 === e.options.fixed.y ? (o.y = this.calculateComponentVelocity(o.y, i.y, e.options.mass), e.y += o.y * this.timestep) : (i.y = 0, o.y = 0); const n = Math.sqrt(Math.pow(o.x, 2) + Math.pow(o.y, 2)); return n;
            }, 
          }, { key: '_freezeNodes', value() { const t = this.body.nodes; for (const e in t) if (t.hasOwnProperty(e) && t[e].x && t[e].y) { const i = t[e].options.fixed; this.freezeCache[e] = { x: i.x, y: i.y }, i.x = !0, i.y = !0; } } }, { key: '_restoreFrozenNodes', value() { const t = this.body.nodes; for (const e in t)t.hasOwnProperty(e) && void 0 !== this.freezeCache[e] && (t[e].options.fixed.x = this.freezeCache[e].x, t[e].options.fixed.y = this.freezeCache[e].y); this.freezeCache = {}; } }, { key: 'stabilize', value() { const t = this; let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.options.stabilization.iterations; typeof e !== 'number' && (e = this.options.stabilization.iterations, console.log('The stabilize method needs a numeric amount of iterations. Switching to default: ', e)), this.physicsBody.physicsNodeIndices.length !== 0 ? (this.adaptiveTimestep = this.options.adaptiveTimestep, this.body.emitter.emit('_resizeNodes'), this.stopSimulation(), this.stabilized = !1, this.body.emitter.emit('_blockRedraw'), this.targetIterations = e, !0 === this.options.stabilization.onlyDynamicEdges && this._freezeNodes(), this.stabilizationIterations = 0, setTimeout(() => t._stabilizationBatch(), 0)) : this.ready = !0; } }, { key: '_startStabilizing', value() { return !0 !== this.startedStabilization && (this.body.emitter.emit('startStabilizing'), this.startedStabilization = !0, !0); } }, { key: '_stabilizationBatch', value() { const t = this; const e = function () { return !1 === t.stabilized && t.stabilizationIterations < t.targetIterations; }; const i = function () { t.body.emitter.emit('stabilizationProgress', { iterations: t.stabilizationIterations, total: t.targetIterations }); }; this._startStabilizing() && i(); let o = 0; while (e() && o < this.options.stabilization.updateInterval) this.physicsTick(), o++; i(), e() ? setTimeout(this._stabilizationBatch.bind(this), 0) : this._finalizeStabilization(); } }, { key: '_finalizeStabilization', value() { this.body.emitter.emit('_allowRedraw'), !0 === this.options.stabilization.fit && this.body.emitter.emit('fit'), !0 === this.options.stabilization.onlyDynamicEdges && this._restoreFrozenNodes(), this.body.emitter.emit('stabilizationIterationsDone'), this.body.emitter.emit('_requestRedraw'), !0 === this.stabilized ? this._emitStabilized() : this.startSimulation(), this.ready = !0; } }, {
            key: '_drawForces',
            value(t) {
              for (let e = 0; e < this.physicsBody.physicsNodeIndices.length; e++) {
                const i = this.physicsBody.physicsNodeIndices[e]; const o = this.body.nodes[i]; const n = this.physicsBody.forces[i]; const s = 20; const r = 0.03; const a = Math.sqrt(Math.pow(n.x, 2) + Math.pow(n.x, 2)); const h = Math.min(Math.max(5, a), 15); const d = 3 * h; const l = y.HSVToHex((180 - 180 * Math.min(1, Math.max(0, r * a))) / 360, 1, 1); const u = { x: o.x + s * n.x, y: o.y + s * n.y }; t.lineWidth = h, t.strokeStyle = l, t.beginPath(), t.moveTo(o.x, o.y), t.lineTo(u.x, u.y), t.stroke(); const c = Math.atan2(n.y, n.x); t.fillStyle = l, b.draw(t, {
                  type: 'arrow', point: u, angle: c, length: d,
                }), t.fill();
              }
            }, 
          }]), t;
        }()); e.default = _;
    }, function (t, e, i) { Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(0); const n = a(o); const s = i(1); const r = a(s); function a(t) { return t && t.__esModule ? t : { default: t }; } const h = (function () { function t(e, i, o) { (0, n.default)(this, t), this.body = e, this.physicsBody = i, this.setOptions(o); } return (0, r.default)(t, [{ key: 'setOptions', value(t) { this.options = t; } }, { key: 'solve', value() { for (var t, e, i, o, n, s, r, a, h = this.body.nodes, d = this.physicsBody.physicsNodeIndices, l = this.physicsBody.forces, u = this.options.nodeDistance, c = -2 / 3 / u, p = 4 / 3, f = 0; f < d.length - 1; f++) { r = h[d[f]]; for (let m = f + 1; m < d.length; m++)a = h[d[m]], t = a.x - r.x, e = a.y - r.y, i = Math.sqrt(t * t + e * e), i === 0 && (i = 0.1 * Math.random(), t = i), i < 2 * u && (s = i < 0.5 * u ? 1 : c * i + p, s /= i, o = t * s, n = e * s, l[r.id].x -= o, l[r.id].y -= n, l[a.id].x += o, l[a.id].y += n); } } }]), t; }()); e.default = h; }, function (t, e, i) { Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(0); const n = a(o); const s = i(1); const r = a(s); function a(t) { return t && t.__esModule ? t : { default: t }; } const h = (function () { function t(e, i, o) { (0, n.default)(this, t), this.body = e, this.physicsBody = i, this.setOptions(o); } return (0, r.default)(t, [{ key: 'setOptions', value(t) { this.options = t; } }, { key: 'solve', value() { let t; let e; let i; let o; let n; let s; let r; let a; let h; let d; const l = this.body.nodes; const u = this.physicsBody.physicsNodeIndices; const c = this.physicsBody.forces; const p = this.options.nodeDistance; for (h = 0; h < u.length - 1; h++) for (r = l[u[h]], d = h + 1; d < u.length; d++) if (a = l[u[d]], r.level === a.level) { t = a.x - r.x, e = a.y - r.y, i = Math.sqrt(t * t + e * e); const f = 0.05; s = i < p ? -Math.pow(f * i, 2) + Math.pow(f * p, 2) : 0, i === 0 ? i = 0.01 : s /= i, o = t * s, n = e * s, c[r.id].x -= o, c[r.id].y -= n, c[a.id].x += o, c[a.id].y += n; } } }]), t; }()); e.default = h; }, function (t, e, i) { Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(0); const n = a(o); const s = i(1); const r = a(s); function a(t) { return t && t.__esModule ? t : { default: t }; } const h = (function () { function t(e, i, o) { (0, n.default)(this, t), this.body = e, this.physicsBody = i, this.setOptions(o); } return (0, r.default)(t, [{ key: 'setOptions', value(t) { this.options = t; } }, { key: 'solve', value() { for (let t = void 0, e = void 0, i = this.physicsBody.physicsEdgeIndices, o = this.body.edges, n = void 0, s = void 0, r = void 0, a = 0; a < i.length; a++)e = o[i[a]], !0 === e.connected && e.toId !== e.fromId && void 0 !== this.body.nodes[e.toId] && void 0 !== this.body.nodes[e.fromId] && (void 0 !== e.edgeType.via ? (t = void 0 === e.options.length ? this.options.springLength : e.options.length, n = e.to, s = e.edgeType.via, r = e.from, this._calculateSpringForce(n, s, 0.5 * t), this._calculateSpringForce(s, r, 0.5 * t)) : (t = void 0 === e.options.length ? 1.5 * this.options.springLength : e.options.length, this._calculateSpringForce(e.from, e.to, t))); } }, { key: '_calculateSpringForce', value(t, e, i) { const o = t.x - e.x; const n = t.y - e.y; const s = Math.max(Math.sqrt(o * o + n * n), 0.01); const r = this.options.springConstant * (i - s) / s; const a = o * r; const h = n * r; void 0 !== this.physicsBody.forces[t.id] && (this.physicsBody.forces[t.id].x += a, this.physicsBody.forces[t.id].y += h), void 0 !== this.physicsBody.forces[e.id] && (this.physicsBody.forces[e.id].x -= a, this.physicsBody.forces[e.id].y -= h); } }]), t; }()); e.default = h; }, function (t, e, i) { Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(0); const n = a(o); const s = i(1); const r = a(s); function a(t) { return t && t.__esModule ? t : { default: t }; } const h = (function () { function t(e, i, o) { (0, n.default)(this, t), this.body = e, this.physicsBody = i, this.setOptions(o); } return (0, r.default)(t, [{ key: 'setOptions', value(t) { this.options = t; } }, { key: 'solve', value() { for (var t, e, i, o, n, s, r, a, h, d, l = this.body.edges, u = 0.5, c = this.physicsBody.physicsEdgeIndices, p = this.physicsBody.physicsNodeIndices, f = this.physicsBody.forces, m = 0; m < p.length; m++) { const v = p[m]; f[v].springFx = 0, f[v].springFy = 0; } for (let g = 0; g < c.length; g++)e = l[c[g]], !0 === e.connected && (t = void 0 === e.options.length ? this.options.springLength : e.options.length, i = e.from.x - e.to.x, o = e.from.y - e.to.y, a = Math.sqrt(i * i + o * o), a = a === 0 ? 0.01 : a, r = this.options.springConstant * (t - a) / a, n = i * r, s = o * r, e.to.level != e.from.level ? (void 0 !== f[e.toId] && (f[e.toId].springFx -= n, f[e.toId].springFy -= s), void 0 !== f[e.fromId] && (f[e.fromId].springFx += n, f[e.fromId].springFy += s)) : (void 0 !== f[e.toId] && (f[e.toId].x -= u * n, f[e.toId].y -= u * s), void 0 !== f[e.fromId] && (f[e.fromId].x += u * n, f[e.fromId].y += u * s))); r = 1; for (let y = 0; y < p.length; y++) { const b = p[y]; h = Math.min(r, Math.max(-r, f[b].springFx)), d = Math.min(r, Math.max(-r, f[b].springFy)), f[b].x += h, f[b].y += d; } for (var _ = 0, w = 0, x = 0; x < p.length; x++) { const k = p[x]; _ += f[k].x, w += f[k].y; } for (let D = _ / p.length, S = w / p.length, C = 0; C < p.length; C++) { const M = p[C]; f[M].x -= D, f[M].y -= S; } } }]), t; }()); e.default = h; }, function (t, e, i) { Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(3); const n = m(o); const s = i(0); const r = m(s); const a = i(1); const h = m(a); const d = i(4); const l = m(d); const u = i(5); const c = m(u); const p = i(120); const f = m(p); function m(t) { return t && t.__esModule ? t : { default: t }; } const v = (function (t) { function e(t, i, o) { return (0, r.default)(this, e), (0, l.default)(this, (e.__proto__ || (0, n.default)(e)).call(this, t, i, o)); } return (0, c.default)(e, t), (0, h.default)(e, [{ key: '_calculateForces', value(t, e, i, o, n) { t === 0 && (t = 0.1 * Math.random(), e = t), this.overlapAvoidanceFactor < 1 && o.shape.radius && (t = Math.max(0.1 + this.overlapAvoidanceFactor * o.shape.radius, t - o.shape.radius)); const s = o.edges.length + 1; const r = this.options.gravitationalConstant * n.mass * o.options.mass * s / Math.pow(t, 2); const a = e * r; const h = i * r; this.physicsBody.forces[o.id].x += a, this.physicsBody.forces[o.id].y += h; } }]), e; }(f.default)); e.default = v; }, function (t, e, i) { Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(3); const n = m(o); const s = i(0); const r = m(s); const a = i(1); const h = m(a); const d = i(4); const l = m(d); const u = i(5); const c = m(u); const p = i(121); const f = m(p); function m(t) { return t && t.__esModule ? t : { default: t }; } const v = (function (t) { function e(t, i, o) { return (0, r.default)(this, e), (0, l.default)(this, (e.__proto__ || (0, n.default)(e)).call(this, t, i, o)); } return (0, c.default)(e, t), (0, h.default)(e, [{ key: '_calculateForces', value(t, e, i, o, n) { if (t > 0) { const s = n.edges.length + 1; const r = this.options.centralGravity * s * n.options.mass; o[n.id].x = e * r, o[n.id].y = i * r; } } }]), e; }(f.default)); e.default = v; }, function (t, e, i) { Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(8); const n = u(o); const s = i(6); const r = u(s); const a = i(0); const h = u(a); const d = i(1); const l = u(d); function u(t) { return t && t.__esModule ? t : { default: t }; } const c = i(2); const p = i(76).default; const f = i(228).default; const m = i(74).default; const v = i(47).default; const g = (function () { function t(e) { const i = this; (0, h.default)(this, t), this.body = e, this.clusteredNodes = {}, this.clusteredEdges = {}, this.options = {}, this.defaultOptions = {}, c.extend(this.options, this.defaultOptions), this.body.emitter.on('_resetData', () => { i.clusteredNodes = {}, i.clusteredEdges = {}; }); } return (0, l.default)(t, [{ key: 'clusterByHubsize', value(t, e) { void 0 === t ? t = this._getHubSize() : (typeof t === 'undefined' ? 'undefined' : (0, r.default)(t)) === 'object' && (e = this._checkOptions(t), t = this._getHubSize()); for (var i = [], o = 0; o < this.body.nodeIndices.length; o++) { const n = this.body.nodes[this.body.nodeIndices[o]]; n.edges.length >= t && i.push(n.id); } for (let s = 0; s < i.length; s++) this.clusterByConnection(i[s], e, !0); this.body.emitter.emit('_dataChanged'); } }, { key: 'cluster', value() { const t = this; let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const i = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]; if (void 0 === e.joinCondition) throw new Error('Cannot call clusterByNodeData without a joinCondition function in the options.'); e = this._checkOptions(e); const o = {}; const n = {}; c.forEach(this.body.nodes, (i, s) => { const r = p.cloneOptions(i); !0 === e.joinCondition(r) && (o[s] = i, c.forEach(i.edges, (e) => { void 0 === t.clusteredEdges[e.id] && (n[e.id] = e); })); }), this._cluster(o, n, e, i); } }, { key: 'clusterByEdgeCount', value(t, e) { const i = this; const o = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]; e = this._checkOptions(e); for (var s = [], r = {}, a = void 0, h = void 0, d = void 0, l = function (o) { const l = {}; const u = {}; const v = i.body.nodeIndices[o]; const g = i.body.nodes[v]; if (void 0 === r[v]) { d = 0, h = []; for (let y = 0; y < g.edges.length; y++)a = g.edges[y], void 0 === i.clusteredEdges[a.id] && (a.toId !== a.fromId && d++, h.push(a)); if (d === t) { c = function (t) { if (void 0 === e.joinCondition || e.joinCondition === null) return !0; const i = p.cloneOptions(t); return e.joinCondition(i); }; for (var b = !0, _ = 0; _ < h.length; _++) { a = h[_]; const w = i._getConnectedId(a, v); if (!c(g)) { b = !1; break; }u[a.id] = a, l[v] = g, l[w] = i.body.nodes[w], r[v] = !0; } if ((0, n.default)(l).length > 0 && (0, n.default)(u).length > 0 && !0 === b) if (f = function () { for (let t = 0; t < s.length; ++t) for (const e in l) if (void 0 !== s[t].nodes[e]) return s[t]; }, m = f(), void 0 !== m) { for (const x in l) void 0 === m.nodes[x] && (m.nodes[x] = l[x]); for (const k in u) void 0 === m.edges[k] && (m.edges[k] = u[k]); } else s.push({ nodes: l, edges: u }); } } }, u = 0; u < this.body.nodeIndices.length; u++) { var c; var f; var m; l(u); } for (u = 0; u < s.length; u++) this._cluster(s[u].nodes, s[u].edges, e, !1); !0 === o && this.body.emitter.emit('_dataChanged'); } }, { key: 'clusterOutliers', value(t) { const e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]; this.clusterByEdgeCount(1, t, e); } }, { key: 'clusterBridges', value(t) { const e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]; this.clusterByEdgeCount(2, t, e); } }, { key: 'clusterByConnection', value(t, e) { const i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]; if (void 0 === t) throw new Error('No nodeId supplied to clusterByConnection!'); if (void 0 === this.body.nodes[t]) throw new Error('The nodeId given to clusterByConnection does not exist!'); const o = this.body.nodes[t]; e = this._checkOptions(e, o), void 0 === e.clusterNodeProperties.x && (e.clusterNodeProperties.x = o.x), void 0 === e.clusterNodeProperties.y && (e.clusterNodeProperties.y = o.y), void 0 === e.clusterNodeProperties.fixed && (e.clusterNodeProperties.fixed = {}, e.clusterNodeProperties.fixed.x = o.options.fixed.x, e.clusterNodeProperties.fixed.y = o.options.fixed.y); const s = {}; const r = {}; const a = o.id; const h = p.cloneOptions(o); s[a] = o; for (let d = 0; d < o.edges.length; d++) { const l = o.edges[d]; if (void 0 === this.clusteredEdges[l.id]) { const u = this._getConnectedId(l, a); if (void 0 === this.clusteredNodes[u]) if (u !== a) if (void 0 === e.joinCondition)r[l.id] = l, s[u] = this.body.nodes[u]; else { const c = p.cloneOptions(this.body.nodes[u]); !0 === e.joinCondition(h, c) && (r[l.id] = l, s[u] = this.body.nodes[u]); } else r[l.id] = l; } } const f = (0, n.default)(s).map(t => s[t].id); for (m in s) if (s.hasOwnProperty(m)) for (var m = s[m], v = 0; v < m.edges.length; v++) { const g = m.edges[v]; f.indexOf(this._getConnectedId(g, m.id)) > -1 && (r[g.id] = g); } this._cluster(s, r, e, i); } }, { key: '_createClusterEdges', value(t, e, i, o) { for (var s = void 0, r = void 0, a = void 0, h = void 0, d = void 0, l = void 0, u = (0, n.default)(t), c = [], p = 0; p < u.length; p++) { r = u[p], a = t[r]; for (let f = 0; f < a.edges.length; f++)s = a.edges[f], void 0 === this.clusteredEdges[s.id] && (s.toId == s.fromId ? e[s.id] = s : s.toId == r ? (h = i.id, d = s.fromId, l = d) : (h = s.toId, d = i.id, l = h), void 0 === t[l] && c.push({ edge: s, fromId: d, toId: h })); } for (var m = [], v = function (t) { for (let e = 0; e < m.length; e++) { const i = m[e]; const o = t.fromId === i.fromId && t.toId === i.toId; const n = t.fromId === i.toId && t.toId === i.fromId; if (o || n) return i; } return null; }, g = 0; g < c.length; g++) { const y = c[g]; const b = y.edge; let _ = v(y); _ === null ? (_ = this._createClusteredEdge(y.fromId, y.toId, b, o), m.push(_)) : _.clusteringEdgeReplacingIds.push(b.id), this.body.edges[b.id].edgeReplacedById = _.id, this._backupEdgeOptions(b), b.setOptions({ physics: !1 }); } } }, { key: '_checkOptions', value() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return void 0 === t.clusterEdgeProperties && (t.clusterEdgeProperties = {}), void 0 === t.clusterNodeProperties && (t.clusterNodeProperties = {}), t; } }, { key: '_cluster', value(t, e, i) { const o = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3]; const s = []; for (const r in t)t.hasOwnProperty(r) && void 0 !== this.clusteredNodes[r] && s.push(r); for (let a = 0; a < s.length; ++a) delete t[s[a]]; if ((0, n.default)(t).length != 0 && ((0, n.default)(t).length != 1 || i.clusterNodeProperties.allowSingleNodeCluster == 1)) { let h = c.deepExtend({}, i.clusterNodeProperties); if (void 0 !== i.processProperties) { const d = []; for (const l in t) if (t.hasOwnProperty(l)) { const u = p.cloneOptions(t[l]); d.push(u); } const m = []; for (const v in e) if (e.hasOwnProperty(v) && v.substr(0, 12) !== 'clusterEdge:') { const g = p.cloneOptions(e[v], 'edge'); m.push(g); } if (h = i.processProperties(h, d, m), !h) throw new Error('The processProperties function does not return properties!'); } void 0 === h.id && (h.id = `cluster:${c.randomUUID()}`); const y = h.id; void 0 === h.label && (h.label = 'cluster'); let b = void 0; void 0 === h.x && (b = this._getClusterPosition(t), h.x = b.x), void 0 === h.y && (void 0 === b && (b = this._getClusterPosition(t)), h.y = b.y), h.id = y; const _ = this.body.functions.createNode(h, f); _.containedNodes = t, _.containedEdges = e, _.clusterEdgeProperties = i.clusterEdgeProperties, this.body.nodes[h.id] = _, this._clusterEdges(t, e, h, i.clusterEdgeProperties), h.id = void 0, !0 === o && this.body.emitter.emit('_dataChanged'); } } }, { key: '_backupEdgeOptions', value(t) { void 0 === this.clusteredEdges[t.id] && (this.clusteredEdges[t.id] = { physics: t.options.physics }); } }, { key: '_restoreEdge', value(t) { const e = this.clusteredEdges[t.id]; void 0 !== e && (t.setOptions({ physics: e.physics }), delete this.clusteredEdges[t.id]); } }, { key: 'isCluster', value(t) { return void 0 !== this.body.nodes[t] ? !0 === this.body.nodes[t].isCluster : (console.log('Node does not exist.'), !1); } }, { key: '_getClusterPosition', value(t) { for (var e = (0, n.default)(t), i = t[e[0]].x, o = t[e[0]].x, s = t[e[0]].y, r = t[e[0]].y, a = void 0, h = 1; h < e.length; h++)a = t[e[h]], i = a.x < i ? a.x : i, o = a.x > o ? a.x : o, s = a.y < s ? a.y : s, r = a.y > r ? a.y : r; return { x: 0.5 * (i + o), y: 0.5 * (s + r) }; } }, { key: 'openCluster', value(t, e) { const i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]; if (void 0 === t) throw new Error('No clusterNodeId supplied to openCluster.'); const o = this.body.nodes[t]; if (void 0 === o) throw new Error('The clusterNodeId supplied to openCluster does not exist.'); if (!0 !== o.isCluster || void 0 === o.containedNodes || void 0 === o.containedEdges) throw new Error(`The node:${t} is not a valid cluster.`); const n = this.findNode(t); const s = n.indexOf(t) - 1; if (s >= 0) { const r = n[s]; const a = this.body.nodes[r]; return a._openChildCluster(t), delete this.body.nodes[t], void (!0 === i && this.body.emitter.emit('_dataChanged')); } const h = o.containedNodes; const d = o.containedEdges; if (void 0 !== e && void 0 !== e.releaseFunction && typeof e.releaseFunction === 'function') { const l = {}; const u = { x: o.x, y: o.y }; for (const p in h) if (h.hasOwnProperty(p)) { const f = this.body.nodes[p]; l[p] = { x: f.x, y: f.y }; } const m = e.releaseFunction(u, l); for (const v in h) if (h.hasOwnProperty(v)) { const g = this.body.nodes[v]; void 0 !== m[v] && (g.x = void 0 === m[v].x ? o.x : m[v].x, g.y = void 0 === m[v].y ? o.y : m[v].y); } } else c.forEach(h, (t) => { !1 === t.options.fixed.x && (t.x = o.x), !1 === t.options.fixed.y && (t.y = o.y); }); for (const y in h) if (h.hasOwnProperty(y)) { const b = this.body.nodes[y]; b.vx = o.vx, b.vy = o.vy, b.setOptions({ physics: !0 }), delete this.clusteredNodes[y]; } for (var _ = [], w = 0; w < o.edges.length; w++)_.push(o.edges[w]); for (let x = 0; x < _.length; x++) { for (var k = _[x], D = this._getConnectedId(k, t), S = this.clusteredNodes[D], C = 0; C < k.clusteringEdgeReplacingIds.length; C++) { const M = k.clusteringEdgeReplacingIds[C]; const O = this.body.edges[M]; if (void 0 !== O) if (void 0 !== S) { const E = this.body.nodes[S.clusterId]; E.containedEdges[O.id] = O, delete d[O.id]; let T = O.fromId; let P = O.toId; O.toId == D ? P = S.clusterId : T = S.clusterId, this._createClusteredEdge(T, P, O, E.clusterEdgeProperties, { hidden: !1, physics: !0 }); } else this._restoreEdge(O); }k.remove(); } for (const I in d)d.hasOwnProperty(I) && this._restoreEdge(d[I]); delete this.body.nodes[t], !0 === i && this.body.emitter.emit('_dataChanged'); } }, { key: 'getNodesInCluster', value(t) { const e = []; if (!0 === this.isCluster(t)) { const i = this.body.nodes[t].containedNodes; for (const o in i)i.hasOwnProperty(o) && e.push(this.body.nodes[o].id); } return e; } }, { key: 'findNode', value(t) { const e = []; const i = 100; let o = 0; let n = void 0; while (void 0 !== this.clusteredNodes[t] && o < i) { if (n = this.body.nodes[t], void 0 === n) return []; e.push(n.id), t = this.clusteredNodes[t].clusterId, o++; } return n = this.body.nodes[t], void 0 === n ? [] : (e.push(n.id), e.reverse(), e); } }, { key: 'updateClusteredNode', value(t, e) { if (void 0 === t) throw new Error('No clusteredNodeId supplied to updateClusteredNode.'); if (void 0 === e) throw new Error('No newOptions supplied to updateClusteredNode.'); if (void 0 === this.body.nodes[t]) throw new Error('The clusteredNodeId supplied to updateClusteredNode does not exist.'); this.body.nodes[t].setOptions(e), this.body.emitter.emit('_dataChanged'); } }, { key: 'updateEdge', value(t, e) { if (void 0 === t) throw new Error('No startEdgeId supplied to updateEdge.'); if (void 0 === e) throw new Error('No newOptions supplied to updateEdge.'); if (void 0 === this.body.edges[t]) throw new Error('The startEdgeId supplied to updateEdge does not exist.'); for (let i = this.getClusteredEdges(t), o = 0; o < i.length; o++) { const n = this.body.edges[i[o]]; n.setOptions(e); } this.body.emitter.emit('_dataChanged'); } }, { key: 'getClusteredEdges', value(t) { const e = []; const i = 100; let o = 0; while (void 0 !== t && void 0 !== this.body.edges[t] && o < i)e.push(this.body.edges[t].id), t = this.body.edges[t].edgeReplacedById, o++; return e.reverse(), e; } }, { key: 'getBaseEdge', value(t) { return this.getBaseEdges(t)[0]; } }, { key: 'getBaseEdges', value(t) { const e = [t]; const i = []; const o = []; const n = 100; let s = 0; while (e.length > 0 && s < n) { const r = e.pop(); if (void 0 !== r) { const a = this.body.edges[r]; if (void 0 !== a) { s++; const h = a.clusteringEdgeReplacingIds; if (void 0 === h)o.push(r); else for (let d = 0; d < h.length; ++d) { const l = h[d]; e.indexOf(h) === -1 && i.indexOf(h) === -1 && e.push(l); }i.push(r); } } } return o; } }, { key: '_getConnectedId', value(t, e) { return t.toId != e ? t.toId : (t.fromId, t.fromId); } }, { key: '_getHubSize', value() { for (var t = 0, e = 0, i = 0, o = 0, n = 0; n < this.body.nodeIndices.length; n++) { const s = this.body.nodes[this.body.nodeIndices[n]]; s.edges.length > o && (o = s.edges.length), t += s.edges.length, e += Math.pow(s.edges.length, 2), i += 1; }t /= i, e /= i; const r = e - Math.pow(t, 2); const a = Math.sqrt(r); let h = Math.floor(t + 2 * a); return h > o && (h = o), h; } }, { key: '_createClusteredEdge', value(t, e, i, o, n) { const s = p.cloneOptions(i, 'edge'); c.deepExtend(s, o), s.from = t, s.to = e, s.id = `clusterEdge:${c.randomUUID()}`, void 0 !== n && c.deepExtend(s, n); const r = this.body.functions.createEdge(s); return r.clusteringEdgeReplacingIds = [i.id], r.connect(), this.body.edges[r.id] = r, r; } }, { key: '_clusterEdges', value(t, e, i, o) { if (e instanceof m) { const n = e; const s = {}; s[n.id] = n, e = s; } if (t instanceof v) { const r = t; const a = {}; a[r.id] = r, t = a; } if (void 0 === i || i === null) throw new Error('_clusterEdges: parameter clusterNode required'); for (const h in void 0 === o && (o = i.clusterEdgeProperties), this._createClusterEdges(t, e, i, o), e) if (e.hasOwnProperty(h) && void 0 !== this.body.edges[h]) { const d = this.body.edges[h]; this._backupEdgeOptions(d), d.setOptions({ physics: !1 }); } for (const l in t)t.hasOwnProperty(l) && (this.clusteredNodes[l] = { clusterId: i.id, node: this.body.nodes[l] }, this.body.nodes[l].setOptions({ physics: !1 })); } }, { key: '_getClusterNodeForNode', value(t) { if (void 0 !== t) { const e = this.clusteredNodes[t]; if (void 0 !== e) { const i = e.clusterId; if (void 0 !== i) return this.body.nodes[i]; } } } }, { key: '_filter', value(t, e) { const i = []; return c.forEach(t, (t) => { e(t) && i.push(t); }), i; } }, { key: '_updateState', value() { const t = this; let e = void 0; const i = []; const o = []; const s = function (e) { c.forEach(t.body.nodes, (t) => { !0 === t.isCluster && e(t); }); }; for (e in this.clusteredNodes) if (this.clusteredNodes.hasOwnProperty(e)) { const r = this.body.nodes[e]; void 0 === r && i.push(e); }s((t) => { for (let e = 0; e < i.length; e++) delete t.containedNodes[i[e]]; }); for (let a = 0; a < i.length; a++) delete this.clusteredNodes[i[a]]; c.forEach(this.clusteredEdges, (e) => { const i = t.body.edges[e]; void 0 !== i && i.endPointsValid() || o.push(e); }), s((t) => { c.forEach(t.containedEdges, (t, e) => { t.endPointsValid() || o.indexOf(e) !== -1 || o.push(e); }); }), c.forEach(this.body.edges, (e, i) => { let n = !0; const s = e.clusteringEdgeReplacingIds; if (void 0 !== s) { let r = 0; c.forEach(s, (e) => { let i = t.body.edges[e]; void 0 !== i && i.endPointsValid() && (r += 1); }), n = r > 0; }e.endPointsValid() && n || o.push(i); }), s((e) => { c.forEach(o, (i) => { delete e.containedEdges[i], c.forEach(e.edges, (n, s) => { n.id !== i ? n.clusteringEdgeReplacingIds = t._filter(n.clusteringEdgeReplacingIds, function (t) { return -1 === o.indexOf(t) }):e.edges[s] = null }), e.edges = t._filter(e.edges, (t) => { return t!==null}); }); }), c.forEach(o, (e) => { delete t.clusteredEdges[e]; }), c.forEach(o, (e) => { delete t.body.edges[e]; }); const h = (0, n.default)(this.body.edges); c.forEach(h, (e) => { const i = t.body.edges[e]; const o = t._isClusteredNode(i.fromId) || t._isClusteredNode(i.toId); if (o !== t._isClusteredEdge(i.id)) { if (!o) throw new Error('remove edge from clustering not implemented!'); const n = t._getClusterNodeForNode(i.fromId); void 0 !== n && t._clusterEdges(t.body.nodes[i.fromId], i, n); const s = t._getClusterNodeForNode(i.toId); void 0 !== s && t._clusterEdges(t.body.nodes[i.toId], i, s); } }); let d = !1; let l = !0; const u = function () { const e = []; s((t) => { const i = (0, n.default)(t.containedNodes).length; const o = !0 === t.options.allowSingleNodeCluster; (o && i < 1 || !o && i < 2) && e.push(t.id); }); for (let i = 0; i < e.length; ++i)t.openCluster(e[i], {}, !1); l = e.length > 0, d = d || l; }; while (l)u(); d && this._updateState(); } }, { key: '_isClusteredNode', value(t) { return void 0 !== this.clusteredNodes[t]; } }, { key: '_isClusteredEdge', value(t) { return void 0 !== this.clusteredEdges[t]; } }]), t; }()); e.default = g; }, function (t, e, i) { Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(3); const n = p(o); const s = i(0); const r = p(s); const a = i(1); const h = p(a); const d = i(4); const l = p(d); const u = i(5); const c = p(u); function p(t) { return t && t.__esModule ? t : { default: t }; } const f = i(2); const m = i(47).default; const v = (function (t) { function e(t, i, o, s, a, h) { (0, r.default)(this, e); const d = (0, l.default)(this, (e.__proto__ || (0, n.default)(e)).call(this, t, i, o, s, a, h)); return d.isCluster = !0, d.containedNodes = {}, d.containedEdges = {}, d; } return (0, c.default)(e, t), (0, h.default)(e, [{ key: '_openChildCluster', value(t) { const e = this; const i = this.body.nodes[t]; if (void 0 === this.containedNodes[t]) throw new Error(`node with id: ${t} not in current cluster`); if (!i.isCluster) throw new Error(`node with id: ${t} is not a cluster`); delete this.containedNodes[t], f.forEach(i.edges, (t) => { delete e.containedEdges[t.id]; }), f.forEach(i.containedNodes, (t, i) => { e.containedNodes[i] = t; }), i.containedNodes = {}, f.forEach(i.containedEdges, (t, i) => { e.containedEdges[i] = t; }), i.containedEdges = {}, f.forEach(i.edges, (t) => { f.forEach(e.edges, (i) => { let o = i.clusteringEdgeReplacingIds.indexOf(t.id); o !== -1 && (f.forEach(t.clusteringEdgeReplacingIds, (t) => { i.clusteringEdgeReplacingIds.push(t), e.body.edges[t].edgeReplacedById = i.id }), i.clusteringEdgeReplacingIds.splice(o, 1)); }); }), i.edges = []; } }]), e; }(m)); e.default = v; }, function (t, e, i) {
      Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(0); const n = a(o); const s = i(1); const r = a(s); function a(t) { return t && t.__esModule ? t : { default: t }; } function h() { let t; void 0 !== window && (t = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame), window.requestAnimationFrame = void 0 === t ? function (t) { t(); } : t; } const d = i(2); const l = (function () {
        function t(e, i) { (0, n.default)(this, t), h(), this.body = e, this.canvas = i, this.redrawRequested = !1, this.renderTimer = void 0, this.requiresTimeout = !0, this.renderingActive = !1, this.renderRequests = 0, this.allowRedraw = !0, this.dragging = !1, this.options = {}, this.defaultOptions = { hideEdgesOnDrag: !1, hideNodesOnDrag: !1 }, d.extend(this.options, this.defaultOptions), this._determineBrowserMethod(), this.bindEventListeners(); } return (0, r.default)(t, [{ key: 'bindEventListeners', value() { const t = this; this.body.emitter.on('dragStart', () => { t.dragging = !0; }), this.body.emitter.on('dragEnd', () => { t.dragging = !1; }), this.body.emitter.on('_resizeNodes', () => { t._resizeNodes(); }), this.body.emitter.on('_redraw', () => { !1 === t.renderingActive && t._redraw(); }), this.body.emitter.on('_blockRedraw', () => { t.allowRedraw = !1; }), this.body.emitter.on('_allowRedraw', () => { t.allowRedraw = !0, t.redrawRequested = !1; }), this.body.emitter.on('_requestRedraw', this._requestRedraw.bind(this)), this.body.emitter.on('_startRendering', () => { t.renderRequests += 1, t.renderingActive = !0, t._startRendering(); }), this.body.emitter.on('_stopRendering', () => { t.renderRequests -= 1, t.renderingActive = t.renderRequests > 0, t.renderTimer = void 0; }), this.body.emitter.on('destroy', () => { t.renderRequests = 0, t.allowRedraw = !1, t.renderingActive = !1, !0 === t.requiresTimeout ? clearTimeout(t.renderTimer) : window.cancelAnimationFrame(t.renderTimer), t.body.emitter.off(); }); } }, { key: 'setOptions', value(t) { if (void 0 !== t) { const e = ['hideEdgesOnDrag', 'hideNodesOnDrag']; d.selectiveDeepExtend(e, this.options, t); } } }, { key: '_requestNextFrame', value(t, e) { if (typeof window !== 'undefined') { let i = void 0; const o = window; return !0 === this.requiresTimeout ? i = o.setTimeout(t, e) : o.requestAnimationFrame && (i = o.requestAnimationFrame(t)), i; } } }, { key: '_startRendering', value() { !0 === this.renderingActive && void 0 === this.renderTimer && (this.renderTimer = this._requestNextFrame(this._renderStep.bind(this), this.simulationInterval)); } }, { key: '_renderStep', value() { !0 === this.renderingActive && (this.renderTimer = void 0, !0 === this.requiresTimeout && this._startRendering(), this._redraw(), !1 === this.requiresTimeout && this._startRendering()); } }, { key: 'redraw', value() { this.body.emitter.emit('setSize'), this._redraw(); } }, { key: '_requestRedraw', value() { const t = this; !0 !== this.redrawRequested && !1 === this.renderingActive && !0 === this.allowRedraw && (this.redrawRequested = !0, this._requestNextFrame(() => { t._redraw(!1); }, 0)); } }, { key: '_redraw', value() { const t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]; if (!0 === this.allowRedraw) { this.body.emitter.emit('initRedraw'), this.redrawRequested = !1, this.canvas.frame.canvas.width !== 0 && this.canvas.frame.canvas.height !== 0 || this.canvas.setSize(), this.canvas.setTransform(); const e = this.canvas.getContext(); const i = this.canvas.frame.canvas.clientWidth; const o = this.canvas.frame.canvas.clientHeight; if (e.clearRect(0, 0, i, o), this.canvas.frame.clientWidth === 0) return; e.save(), e.translate(this.body.view.translation.x, this.body.view.translation.y), e.scale(this.body.view.scale, this.body.view.scale), e.beginPath(), this.body.emitter.emit('beforeDrawing', e), e.closePath(), !1 === t && (!1 === this.dragging || !0 === this.dragging && !1 === this.options.hideEdgesOnDrag) && this._drawEdges(e), (!1 === this.dragging || !0 === this.dragging && !1 === this.options.hideNodesOnDrag) && this._drawNodes(e, t), e.beginPath(), this.body.emitter.emit('afterDrawing', e), e.closePath(), e.restore(), !0 === t && e.clearRect(0, 0, i, o); } } }, { key: '_resizeNodes', value() { this.canvas.setTransform(); const t = this.canvas.getContext(); t.save(), t.translate(this.body.view.translation.x, this.body.view.translation.y), t.scale(this.body.view.scale, this.body.view.scale); const e = this.body.nodes; let i = void 0; for (const o in e)e.hasOwnProperty(o) && (i = e[o], i.resize(t), i.updateBoundingBox(t, i.selected)); t.restore(); } }, {
          key: '_drawNodes',
          value(t) {
            for (var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], i = this.body.nodes, o = this.body.nodeIndices, n = void 0, s = [], r = 20, a = this.canvas.DOMtoCanvas({ x: -r, y: -r }), h = this.canvas.DOMtoCanvas({ x: this.canvas.frame.canvas.clientWidth + r, y: this.canvas.frame.canvas.clientHeight + r }), d = {
                top: a.y, left: a.x, bottom: h.y, right: h.x,
              }, l = 0; l < o.length; l++)n = i[o[l]], n.isSelected() ? s.push(o[l]) : !0 === e ? n.draw(t) : !0 === n.isBoundingBoxOverlappingWith(d) ? n.draw(t) : n.updateBoundingBox(t, n.selected); for (let u = 0; u < s.length; u++)n = i[s[u]], n.draw(t);
          }, 
        }, { key: '_drawEdges', value(t) { for (let e = this.body.edges, i = this.body.edgeIndices, o = void 0, n = 0; n < i.length; n++)o = e[i[n]], !0 === o.connected && o.draw(t); } }, { key: '_determineBrowserMethod', value() { if (typeof window !== 'undefined') { const t = navigator.userAgent.toLowerCase(); this.requiresTimeout = !1, t.indexOf('msie 9.0') != -1 ? this.requiresTimeout = !0 : t.indexOf('safari') != -1 && t.indexOf('chrome') <= -1 && (this.requiresTimeout = !0); } else this.requiresTimeout = !0; } }]), t;
      }()); e.default = l;
    }, function (t, e, i) {
      Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(0); const n = a(o); const s = i(1); const r = a(s); function a(t) { return t && t.__esModule ? t : { default: t }; } const h = i(10); const d = i(37); const l = i(2); const u = (function () {
        function t(e) { (0, n.default)(this, t), this.body = e, this.pixelRatio = 1, this.resizeTimer = void 0, this.resizeFunction = this._onResize.bind(this), this.cameraState = {}, this.initialized = !1, this.canvasViewCenter = {}, this.options = {}, this.defaultOptions = { autoResize: !0, height: '100%', width: '100%' }, l.extend(this.options, this.defaultOptions), this.bindEventListeners(); } return (0, r.default)(t, [{ key: 'bindEventListeners', value() { const t = this; this.body.emitter.once('resize', (e) => { e.width !== 0 && (t.body.view.translation.x = 0.5 * e.width), e.height !== 0 && (t.body.view.translation.y = 0.5 * e.height); }), this.body.emitter.on('setSize', this.setSize.bind(this)), this.body.emitter.on('destroy', () => { t.hammerFrame.destroy(), t.hammer.destroy(), t._cleanUp(); }); } }, { key: 'setOptions', value(t) { const e = this; if (void 0 !== t) { const i = ['width', 'height', 'autoResize']; l.selectiveDeepExtend(i, this.options, t); }!0 === this.options.autoResize && (this._cleanUp(), this.resizeTimer = setInterval(() => { const t = e.setSize(); !0 === t && e.body.emitter.emit('_requestRedraw'); }, 1e3), this.resizeFunction = this._onResize.bind(this), l.addEventListener(window, 'resize', this.resizeFunction)); } }, { key: '_cleanUp', value() { void 0 !== this.resizeTimer && clearInterval(this.resizeTimer), l.removeEventListener(window, 'resize', this.resizeFunction), this.resizeFunction = void 0; } }, { key: '_onResize', value() { this.setSize(), this.body.emitter.emit('_redraw'); } }, { key: '_getCameraState', value() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.pixelRatio; !0 === this.initialized && (this.cameraState.previousWidth = this.frame.canvas.width / t, this.cameraState.previousHeight = this.frame.canvas.height / t, this.cameraState.scale = this.body.view.scale, this.cameraState.position = this.DOMtoCanvas({ x: 0.5 * this.frame.canvas.width / t, y: 0.5 * this.frame.canvas.height / t })); } }, { key: '_setCameraState', value() { if (void 0 !== this.cameraState.scale && this.frame.canvas.clientWidth !== 0 && this.frame.canvas.clientHeight !== 0 && this.pixelRatio !== 0 && this.cameraState.previousWidth > 0) { const t = this.frame.canvas.width / this.pixelRatio / this.cameraState.previousWidth; const e = this.frame.canvas.height / this.pixelRatio / this.cameraState.previousHeight; let i = this.cameraState.scale; t != 1 && e != 1 ? i = 0.5 * this.cameraState.scale * (t + e) : t != 1 ? i = this.cameraState.scale * t : e != 1 && (i = this.cameraState.scale * e), this.body.view.scale = i; const o = this.DOMtoCanvas({ x: 0.5 * this.frame.canvas.clientWidth, y: 0.5 * this.frame.canvas.clientHeight }); const n = { x: o.x - this.cameraState.position.x, y: o.y - this.cameraState.position.y }; this.body.view.translation.x += n.x * this.body.view.scale, this.body.view.translation.y += n.y * this.body.view.scale; } } }, { key: '_prepareValue', value(t) { if (typeof t === 'number') return `${t}px`; if (typeof t === 'string') { if (t.indexOf('%') !== -1 || t.indexOf('px') !== -1) return t; if (t.indexOf('%') === -1) return `${t}px`; } throw new Error(`Could not use the value supplied for width or height:${t}`); } }, { key: '_create', value() { while (this.body.container.hasChildNodes()) this.body.container.removeChild(this.body.container.firstChild); if (this.frame = document.createElement('div'), this.frame.className = 'vis-network', this.frame.style.position = 'relative', this.frame.style.overflow = 'hidden', this.frame.tabIndex = 900, this.frame.canvas = document.createElement('canvas'), this.frame.canvas.style.position = 'relative', this.frame.appendChild(this.frame.canvas), this.frame.canvas.getContext) this._setPixelRatio(), this.setTransform(); else { const t = document.createElement('DIV'); t.style.color = 'red', t.style.fontWeight = 'bold', t.style.padding = '10px', t.innerHTML = 'Error: your browser does not support HTML canvas', this.frame.canvas.appendChild(t); } this.body.container.appendChild(this.frame), this.body.view.scale = 1, this.body.view.translation = { x: 0.5 * this.frame.canvas.clientWidth, y: 0.5 * this.frame.canvas.clientHeight }, this._bindHammer(); } }, { key: '_bindHammer', value() { const t = this; void 0 !== this.hammer && this.hammer.destroy(), this.drag = {}, this.pinch = {}, this.hammer = new h(this.frame.canvas), this.hammer.get('pinch').set({ enable: !0 }), this.hammer.get('pan').set({ threshold: 5, direction: h.DIRECTION_ALL }), d.onTouch(this.hammer, (e) => { t.body.eventListeners.onTouch(e); }), this.hammer.on('tap', (e) => { t.body.eventListeners.onTap(e); }), this.hammer.on('doubletap', (e) => { t.body.eventListeners.onDoubleTap(e); }), this.hammer.on('press', (e) => { t.body.eventListeners.onHold(e); }), this.hammer.on('panstart', (e) => { t.body.eventListeners.onDragStart(e); }), this.hammer.on('panmove', (e) => { t.body.eventListeners.onDrag(e); }), this.hammer.on('panend', (e) => { t.body.eventListeners.onDragEnd(e); }), this.hammer.on('pinch', (e) => { t.body.eventListeners.onPinch(e); }), this.frame.canvas.addEventListener('mousewheel', (e) => { t.body.eventListeners.onMouseWheel(e); }), this.frame.canvas.addEventListener('DOMMouseScroll', (e) => { t.body.eventListeners.onMouseWheel(e); }), this.frame.canvas.addEventListener('mousemove', (e) => { t.body.eventListeners.onMouseMove(e); }), this.frame.canvas.addEventListener('contextmenu', (e) => { t.body.eventListeners.onContext(e); }), this.hammerFrame = new h(this.frame), d.onRelease(this.hammerFrame, (e) => { t.body.eventListeners.onRelease(e); }); } }, {
          key: 'setSize',
          value() {
            let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.options.width; let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.options.height; t = this._prepareValue(t), e = this._prepareValue(e); let i = !1; const o = this.frame.canvas.width; const n = this.frame.canvas.height; const s = this.pixelRatio; if (this._setPixelRatio(), t != this.options.width || e != this.options.height || this.frame.style.width != t || this.frame.style.height != e) this._getCameraState(s), this.frame.style.width = t, this.frame.style.height = e, this.frame.canvas.style.width = '100%', this.frame.canvas.style.height = '100%', this.frame.canvas.width = Math.round(this.frame.canvas.clientWidth * this.pixelRatio), this.frame.canvas.height = Math.round(this.frame.canvas.clientHeight * this.pixelRatio), this.options.width = t, this.options.height = e, this.canvasViewCenter = { x: 0.5 * this.frame.clientWidth, y: 0.5 * this.frame.clientHeight }, i = !0; else { const r = Math.round(this.frame.canvas.clientWidth * this.pixelRatio); const a = Math.round(this.frame.canvas.clientHeight * this.pixelRatio); this.frame.canvas.width === r && this.frame.canvas.height === a || this._getCameraState(s), this.frame.canvas.width !== r && (this.frame.canvas.width = r, i = !0), this.frame.canvas.height !== a && (this.frame.canvas.height = a, i = !0); } return !0 === i && (this.body.emitter.emit('resize', {
              width: Math.round(this.frame.canvas.width / this.pixelRatio), height: Math.round(this.frame.canvas.height / this.pixelRatio), oldWidth: Math.round(o / this.pixelRatio), oldHeight: Math.round(n / this.pixelRatio),
            }), this._setCameraState()), this.initialized = !0, i;
          }, 
        }, { key: 'getContext', value() { return this.frame.canvas.getContext('2d'); } }, { key: '_determinePixelRatio', value() { const t = this.getContext(); if (void 0 === t) throw new Error('Could not get canvax context'); let e = 1; typeof window !== 'undefined' && (e = window.devicePixelRatio || 1); const i = t.webkitBackingStorePixelRatio || t.mozBackingStorePixelRatio || t.msBackingStorePixelRatio || t.oBackingStorePixelRatio || t.backingStorePixelRatio || 1; return e / i; } }, { key: '_setPixelRatio', value() { this.pixelRatio = this._determinePixelRatio(); } }, { key: 'setTransform', value() { const t = this.getContext(); if (void 0 === t) throw new Error('Could not get canvax context'); t.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0); } }, { key: '_XconvertDOMtoCanvas', value(t) { return (t - this.body.view.translation.x) / this.body.view.scale; } }, { key: '_XconvertCanvasToDOM', value(t) { return t * this.body.view.scale + this.body.view.translation.x; } }, { key: '_YconvertDOMtoCanvas', value(t) { return (t - this.body.view.translation.y) / this.body.view.scale; } }, { key: '_YconvertCanvasToDOM', value(t) { return t * this.body.view.scale + this.body.view.translation.y; } }, { key: 'canvasToDOM', value(t) { return { x: this._XconvertCanvasToDOM(t.x), y: this._YconvertCanvasToDOM(t.y) }; } }, { key: 'DOMtoCanvas', value(t) { return { x: this._XconvertDOMtoCanvas(t.x), y: this._YconvertDOMtoCanvas(t.y) }; } }]), t;
      }()); e.default = u;
    }, function (t, e, i) { Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(0); const n = a(o); const s = i(1); const r = a(s); function a(t) { return t && t.__esModule ? t : { default: t }; } const h = i(2); const d = i(76).default; const l = (function () { function t(e, i) { const o = this; (0, n.default)(this, t), this.body = e, this.canvas = i, this.animationSpeed = 1 / this.renderRefreshRate, this.animationEasingFunction = 'easeInOutQuint', this.easingTime = 0, this.sourceScale = 0, this.targetScale = 0, this.sourceTranslation = 0, this.targetTranslation = 0, this.lockedOnNodeId = void 0, this.lockedOnNodeOffset = void 0, this.touchTime = 0, this.viewFunction = void 0, this.body.emitter.on('fit', this.fit.bind(this)), this.body.emitter.on('animationFinished', () => { o.body.emitter.emit('_stopRendering'); }), this.body.emitter.on('unlockNode', this.releaseNode.bind(this)); } return (0, r.default)(t, [{ key: 'setOptions', value() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; this.options = t; } }, { key: 'fit', value() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : { nodes: [] }; const e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; let i = void 0; let o = void 0; if (void 0 !== t.nodes && t.nodes.length !== 0 || (t.nodes = this.body.nodeIndices), !0 === e) { let n = 0; for (const s in this.body.nodes) if (this.body.nodes.hasOwnProperty(s)) { const r = this.body.nodes[s]; !0 === r.predefinedPosition && (n += 1); } if (n > 0.5 * this.body.nodeIndices.length) return void this.fit(t, !1); i = d.getRange(this.body.nodes, t.nodes); const a = this.body.nodeIndices.length; o = 12.662 / (a + 7.4147) + 0.0964822; const h = Math.min(this.canvas.frame.canvas.clientWidth / 600, this.canvas.frame.canvas.clientHeight / 600); o *= h; } else { this.body.emitter.emit('_resizeNodes'), i = d.getRange(this.body.nodes, t.nodes); const l = 1.1 * Math.abs(i.maxX - i.minX); const u = 1.1 * Math.abs(i.maxY - i.minY); const c = this.canvas.frame.canvas.clientWidth / l; const p = this.canvas.frame.canvas.clientHeight / u; o = c <= p ? c : p; }o > 1 ? o = 1 : o === 0 && (o = 1); const f = d.findCenter(i); const m = { position: f, scale: o, animation: t.animation }; this.moveTo(m); } }, { key: 'focus', value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; if (void 0 !== this.body.nodes[t]) { const i = { x: this.body.nodes[t].x, y: this.body.nodes[t].y }; e.position = i, e.lockedOnNode = t, this.moveTo(e); } else console.log(`Node: ${t} cannot be found.`); } }, { key: 'moveTo', value(t) { void 0 !== t ? (void 0 === t.offset && (t.offset = { x: 0, y: 0 }), void 0 === t.offset.x && (t.offset.x = 0), void 0 === t.offset.y && (t.offset.y = 0), void 0 === t.scale && (t.scale = this.body.view.scale), void 0 === t.position && (t.position = this.getViewPosition()), void 0 === t.animation && (t.animation = { duration: 0 }), !1 === t.animation && (t.animation = { duration: 0 }), !0 === t.animation && (t.animation = {}), void 0 === t.animation.duration && (t.animation.duration = 1e3), void 0 === t.animation.easingFunction && (t.animation.easingFunction = 'easeInOutQuad'), this.animateView(t)) : t = {}; } }, { key: 'animateView', value(t) { if (void 0 !== t) { this.animationEasingFunction = t.animation.easingFunction, this.releaseNode(), !0 === t.locked && (this.lockedOnNodeId = t.lockedOnNode, this.lockedOnNodeOffset = t.offset), this.easingTime != 0 && this._transitionRedraw(!0), this.sourceScale = this.body.view.scale, this.sourceTranslation = this.body.view.translation, this.targetScale = t.scale, this.body.view.scale = this.targetScale; const e = this.canvas.DOMtoCanvas({ x: 0.5 * this.canvas.frame.canvas.clientWidth, y: 0.5 * this.canvas.frame.canvas.clientHeight }); const i = { x: e.x - t.position.x, y: e.y - t.position.y }; this.targetTranslation = { x: this.sourceTranslation.x + i.x * this.targetScale + t.offset.x, y: this.sourceTranslation.y + i.y * this.targetScale + t.offset.y }, t.animation.duration === 0 ? void 0 != this.lockedOnNodeId ? (this.viewFunction = this._lockedRedraw.bind(this), this.body.emitter.on('initRedraw', this.viewFunction)) : (this.body.view.scale = this.targetScale, this.body.view.translation = this.targetTranslation, this.body.emitter.emit('_requestRedraw')) : (this.animationSpeed = 1 / (60 * t.animation.duration * 0.001) || 1 / 60, this.animationEasingFunction = t.animation.easingFunction, this.viewFunction = this._transitionRedraw.bind(this), this.body.emitter.on('initRedraw', this.viewFunction), this.body.emitter.emit('_startRendering')); } } }, { key: '_lockedRedraw', value() { const t = { x: this.body.nodes[this.lockedOnNodeId].x, y: this.body.nodes[this.lockedOnNodeId].y }; const e = this.canvas.DOMtoCanvas({ x: 0.5 * this.canvas.frame.canvas.clientWidth, y: 0.5 * this.canvas.frame.canvas.clientHeight }); const i = { x: e.x - t.x, y: e.y - t.y }; const o = this.body.view.translation; const n = { x: o.x + i.x * this.body.view.scale + this.lockedOnNodeOffset.x, y: o.y + i.y * this.body.view.scale + this.lockedOnNodeOffset.y }; this.body.view.translation = n; } }, { key: 'releaseNode', value() { void 0 !== this.lockedOnNodeId && void 0 !== this.viewFunction && (this.body.emitter.off('initRedraw', this.viewFunction), this.lockedOnNodeId = void 0, this.lockedOnNodeOffset = void 0); } }, { key: '_transitionRedraw', value() { const t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]; this.easingTime += this.animationSpeed, this.easingTime = !0 === t ? 1 : this.easingTime; const e = h.easingFunctions[this.animationEasingFunction](this.easingTime); this.body.view.scale = this.sourceScale + (this.targetScale - this.sourceScale) * e, this.body.view.translation = { x: this.sourceTranslation.x + (this.targetTranslation.x - this.sourceTranslation.x) * e, y: this.sourceTranslation.y + (this.targetTranslation.y - this.sourceTranslation.y) * e }, this.easingTime >= 1 && (this.body.emitter.off('initRedraw', this.viewFunction), this.easingTime = 0, void 0 != this.lockedOnNodeId && (this.viewFunction = this._lockedRedraw.bind(this), this.body.emitter.on('initRedraw', this.viewFunction)), this.body.emitter.emit('animationFinished')); } }, { key: 'getScale', value() { return this.body.view.scale; } }, { key: 'getViewPosition', value() { return this.canvas.DOMtoCanvas({ x: 0.5 * this.canvas.frame.canvas.clientWidth, y: 0.5 * this.canvas.frame.canvas.clientHeight }); } }]), t; }()); e.default = l; }, function (t, e, i) {
      Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(0); const n = a(o); const s = i(1); const r = a(s); function a(t) { return t && t.__esModule ? t : { default: t }; } const h = i(2); const d = i(233).default; const l = i(104).default; const u = (function () {
        function t(e, i, o) {
          (0, n.default)(this, t), this.body = e, this.canvas = i, this.selectionHandler = o, this.navigationHandler = new d(e, i), this.body.eventListeners.onTap = this.onTap.bind(this), this.body.eventListeners.onTouch = this.onTouch.bind(this), this.body.eventListeners.onDoubleTap = this.onDoubleTap.bind(this), this.body.eventListeners.onHold = this.onHold.bind(this), this.body.eventListeners.onDragStart = this.onDragStart.bind(this), this.body.eventListeners.onDrag = this.onDrag.bind(this), this.body.eventListeners.onDragEnd = this.onDragEnd.bind(this), this.body.eventListeners.onMouseWheel = this.onMouseWheel.bind(this), this.body.eventListeners.onPinch = this.onPinch.bind(this), this.body.eventListeners.onMouseMove = this.onMouseMove.bind(this), this.body.eventListeners.onRelease = this.onRelease.bind(this), this.body.eventListeners.onContext = this.onContext.bind(this), this.touchTime = 0, this.drag = {}, this.pinch = {}, this.popup = void 0, this.popupObj = void 0, this.popupTimer = void 0, this.body.functions.getPointer = this.getPointer.bind(this), this.options = {}, this.defaultOptions = {
            dragNodes: !0, dragView: !0, hover: !1, keyboard: { enabled: !1, speed: { x: 10, y: 10, zoom: 0.02 }, bindToWindow: !0 }, navigationButtons: !1, tooltipDelay: 300, zoomView: !0,
          }, h.extend(this.options, this.defaultOptions), this.bindEventListeners();
        } return (0, r.default)(t, [{ key: 'bindEventListeners', value() { const t = this; this.body.emitter.on('destroy', () => { clearTimeout(t.popupTimer), delete t.body.functions.getPointer; }); } }, { key: 'setOptions', value(t) { if (void 0 !== t) { const e = ['hideEdgesOnDrag', 'hideNodesOnDrag', 'keyboard', 'multiselect', 'selectable', 'selectConnectedEdges']; h.selectiveNotDeepExtend(e, this.options, t), h.mergeOptions(this.options, t, 'keyboard'), t.tooltip && (h.extend(this.options.tooltip, t.tooltip), t.tooltip.color && (this.options.tooltip.color = h.parseColor(t.tooltip.color))); } this.navigationHandler.setOptions(this.options); } }, { key: 'getPointer', value(t) { return { x: t.x - h.getAbsoluteLeft(this.canvas.frame.canvas), y: t.y - h.getAbsoluteTop(this.canvas.frame.canvas) }; } }, { key: 'onTouch', value(t) { (new Date()).valueOf() - this.touchTime > 50 && (this.drag.pointer = this.getPointer(t.center), this.drag.pinched = !1, this.pinch.scale = this.body.view.scale, this.touchTime = (new Date()).valueOf()); } }, { key: 'onTap', value(t) { const e = this.getPointer(t.center); const i = this.selectionHandler.options.multiselect && (t.changedPointers[0].ctrlKey || t.changedPointers[0].metaKey); this.checkSelectionChanges(e, t, i), this.selectionHandler._generateClickEvent('click', t, e); } }, { key: 'onDoubleTap', value(t) { const e = this.getPointer(t.center); this.selectionHandler._generateClickEvent('doubleClick', t, e); } }, { key: 'onHold', value(t) { const e = this.getPointer(t.center); const i = this.selectionHandler.options.multiselect; this.checkSelectionChanges(e, t, i), this.selectionHandler._generateClickEvent('click', t, e), this.selectionHandler._generateClickEvent('hold', t, e); } }, { key: 'onRelease', value(t) { if ((new Date()).valueOf() - this.touchTime > 10) { const e = this.getPointer(t.center); this.selectionHandler._generateClickEvent('release', t, e), this.touchTime = (new Date()).valueOf(); } } }, { key: 'onContext', value(t) { const e = this.getPointer({ x: t.clientX, y: t.clientY }); this.selectionHandler._generateClickEvent('oncontext', t, e); } }, { key: 'checkSelectionChanges', value(t, e) { const i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; const o = this.selectionHandler.getSelection(); let n = !1; n = !0 === i ? this.selectionHandler.selectAdditionalOnPoint(t) : this.selectionHandler.selectOnPoint(t); const s = this.selectionHandler.getSelection(); const r = this._determineDifference(o, s); const a = this._determineDifference(s, o); r.edges.length > 0 && (this.selectionHandler._generateClickEvent('deselectEdge', e, t, o), n = !0), r.nodes.length > 0 && (this.selectionHandler._generateClickEvent('deselectNode', e, t, o), n = !0), a.nodes.length > 0 && (this.selectionHandler._generateClickEvent('selectNode', e, t), n = !0), a.edges.length > 0 && (this.selectionHandler._generateClickEvent('selectEdge', e, t), n = !0), !0 === n && this.selectionHandler._generateClickEvent('select', e, t); } }, { key: '_determineDifference', value(t, e) { const i = function (t, e) { for (var i = [], o = 0; o < t.length; o++) { const n = t[o]; e.indexOf(n) === -1 && i.push(n); } return i; }; return { nodes: i(t.nodes, e.nodes), edges: i(t.edges, e.edges) }; } }, {
          key: 'onDragStart',
          value(t) {
            void 0 === this.drag.pointer && this.onTouch(t); const e = this.selectionHandler.getNodeAt(this.drag.pointer); if (this.drag.dragging = !0, this.drag.selection = [], this.drag.translation = h.extend({}, this.body.view.translation), this.drag.nodeId = void 0, void 0 !== e && !0 === this.options.dragNodes) {
              this.drag.nodeId = e.id, !1 === e.isSelected() && (this.selectionHandler.unselectAll(), this.selectionHandler.selectObject(e)), this.selectionHandler._generateClickEvent('dragStart', t, this.drag.pointer); const i = this.selectionHandler.selectionObj.nodes; for (const o in i) { if (i.hasOwnProperty(o)) {
 const n = i[o]; const s = {
                id: n.id, node: n, x: n.x, y: n.y, xFixed: n.options.fixed.x, yFixed: n.options.fixed.y, 
              }; n.options.fixed.x = !0, n.options.fixed.y = !0, this.drag.selection.push(s); 
} }
            } else this.selectionHandler._generateClickEvent('dragStart', t, this.drag.pointer, void 0, !0);
          }, 
        }, { key: 'onDrag', value(t) { const e = this; if (!0 !== this.drag.pinched) { this.body.emitter.emit('unlockNode'); const i = this.getPointer(t.center); const o = this.drag.selection; if (o && o.length && !0 === this.options.dragNodes) { this.selectionHandler._generateClickEvent('dragging', t, i); const n = i.x - this.drag.pointer.x; const s = i.y - this.drag.pointer.y; o.forEach((t) => { const i = t.node; !1 === t.xFixed && (i.x = e.canvas._XconvertDOMtoCanvas(e.canvas._XconvertCanvasToDOM(t.x) + n)), !1 === t.yFixed && (i.y = e.canvas._YconvertDOMtoCanvas(e.canvas._YconvertCanvasToDOM(t.y) + s)); }), this.body.emitter.emit('startSimulation'); } else if (!0 === this.options.dragView) { if (this.selectionHandler._generateClickEvent('dragging', t, i, void 0, !0), void 0 === this.drag.pointer) return void this.onDragStart(t); const r = i.x - this.drag.pointer.x; const a = i.y - this.drag.pointer.y; this.body.view.translation = { x: this.drag.translation.x + r, y: this.drag.translation.y + a }, this.body.emitter.emit('_requestRedraw'); } } } }, { key: 'onDragEnd', value(t) { this.drag.dragging = !1; const e = this.drag.selection; e && e.length ? (e.forEach((t) => { t.node.options.fixed.x = t.xFixed, t.node.options.fixed.y = t.yFixed; }), this.selectionHandler._generateClickEvent('dragEnd', t, this.getPointer(t.center)), this.body.emitter.emit('startSimulation')) : (this.selectionHandler._generateClickEvent('dragEnd', t, this.getPointer(t.center), void 0, !0), this.body.emitter.emit('_requestRedraw')); } }, { key: 'onPinch', value(t) { const e = this.getPointer(t.center); this.drag.pinched = !0, void 0 === this.pinch.scale && (this.pinch.scale = 1); const i = this.pinch.scale * t.scale; this.zoom(i, e); } }, { key: 'zoom', value(t, e) { if (!0 === this.options.zoomView) { const i = this.body.view.scale; t < 1e-5 && (t = 1e-5), t > 10 && (t = 10); let o = void 0; void 0 !== this.drag && !0 === this.drag.dragging && (o = this.canvas.DOMtoCanvas(this.drag.pointer)); const n = this.body.view.translation; const s = t / i; const r = (1 - s) * e.x + n.x * s; const a = (1 - s) * e.y + n.y * s; if (this.body.view.scale = t, this.body.view.translation = { x: r, y: a }, void 0 != o) { const h = this.canvas.canvasToDOM(o); this.drag.pointer.x = h.x, this.drag.pointer.y = h.y; } this.body.emitter.emit('_requestRedraw'), i < t ? this.body.emitter.emit('zoom', { direction: '+', scale: this.body.view.scale, pointer: e }) : this.body.emitter.emit('zoom', { direction: '-', scale: this.body.view.scale, pointer: e }); } } }, { key: 'onMouseWheel', value(t) { if (!0 === this.options.zoomView) { let e = 0; if (t.wheelDelta ? e = t.wheelDelta / 120 : t.detail && (e = -t.detail / 3), e !== 0) { let i = this.body.view.scale; let o = e / 10; e < 0 && (o /= 1 - o), i *= 1 + o; const n = this.getPointer({ x: t.clientX, y: t.clientY }); this.zoom(i, n); }t.preventDefault(); } } }, { key: 'onMouseMove', value(t) { const e = this; const i = this.getPointer({ x: t.clientX, y: t.clientY }); let o = !1; void 0 !== this.popup && (!1 === this.popup.hidden && this._checkHidePopup(i), !1 === this.popup.hidden && (o = !0, this.popup.setPosition(i.x + 3, i.y - 5), this.popup.show())), !1 === this.options.keyboard.bindToWindow && !0 === this.options.keyboard.enabled && this.canvas.frame.focus(), !1 === o && (void 0 !== this.popupTimer && (clearInterval(this.popupTimer), this.popupTimer = void 0), this.drag.dragging || (this.popupTimer = setTimeout(() => e._checkShowPopup(i), this.options.tooltipDelay))), !0 === this.options.hover && this.selectionHandler.hoverObject(t, i); } }, {
 key: '_checkShowPopup',
value(t) {
 const e = this.canvas._XconvertDOMtoCanvas(t.x); const i = this.canvas._YconvertDOMtoCanvas(t.y); const o = {
          left: e, top: i, right: e, bottom: i, 
        }; const n = void 0 === this.popupObj ? void 0 : this.popupObj.id; let s = !1; let r = 'node'; if (void 0 === this.popupObj) { for (var a = this.body.nodeIndices, h = this.body.nodes, d = void 0, u = [], c = 0; c < a.length; c++)d = h[a[c]], !0 === d.isOverlappingWith(o) && void 0 !== d.getTitle() && u.push(a[c]); u.length > 0 && (this.popupObj = h[u[u.length - 1]], s = !0); } if (void 0 === this.popupObj && !1 === s) { for (var p = this.body.edgeIndices, f = this.body.edges, m = void 0, v = [], g = 0; g < p.length; g++)m = f[p[g]], !0 === m.isOverlappingWith(o) && !0 === m.connected && void 0 !== m.getTitle() && v.push(p[g]); v.length > 0 && (this.popupObj = f[v[v.length - 1]], r = 'edge'); } void 0 !== this.popupObj ? this.popupObj.id !== n && (void 0 === this.popup && (this.popup = new l(this.canvas.frame)), this.popup.popupTargetType = r, this.popup.popupTargetId = this.popupObj.id, this.popup.setPosition(t.x + 3, t.y - 5), this.popup.setText(this.popupObj.getTitle()), this.popup.show(), this.body.emitter.emit('showPopup', this.popupObj.id)) : void 0 !== this.popup && (this.popup.hide(), this.body.emitter.emit('hidePopup')); 
} 
}, { key: '_checkHidePopup', value(t) { const e = this.selectionHandler._pointerToPositionObject(t); let i = !1; if (this.popup.popupTargetType === 'node') { if (void 0 !== this.body.nodes[this.popup.popupTargetId] && (i = this.body.nodes[this.popup.popupTargetId].isOverlappingWith(e), !0 === i)) { const o = this.selectionHandler.getNodeAt(t); i = void 0 !== o && o.id === this.popup.popupTargetId; } } else void 0 === this.selectionHandler.getNodeAt(t) && void 0 !== this.body.edges[this.popup.popupTargetId] && (i = this.body.edges[this.popup.popupTargetId].isOverlappingWith(e)); !1 === i && (this.popupObj = void 0, this.popup.hide(), this.body.emitter.emit('hidePopup')); } }]), t;
      }()); e.default = u;
    }, function (t, e, i) { Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(0); const n = a(o); const s = i(1); const r = a(s); function a(t) { return t && t.__esModule ? t : { default: t }; } const h = i(10); const d = i(37); const l = i(35); const u = (function () { function t(e, i) { const o = this; (0, n.default)(this, t), this.body = e, this.canvas = i, this.iconsCreated = !1, this.navigationHammers = [], this.boundFunctions = {}, this.touchTime = 0, this.activated = !1, this.body.emitter.on('activate', () => { o.activated = !0, o.configureKeyboardBindings(); }), this.body.emitter.on('deactivate', () => { o.activated = !1, o.configureKeyboardBindings(); }), this.body.emitter.on('destroy', () => { void 0 !== o.keycharm && o.keycharm.destroy(); }), this.options = {}; } return (0, r.default)(t, [{ key: 'setOptions', value(t) { void 0 !== t && (this.options = t, this.create()); } }, { key: 'create', value() { !0 === this.options.navigationButtons ? !1 === this.iconsCreated && this.loadNavigationElements() : !0 === this.iconsCreated && this.cleanNavigation(), this.configureKeyboardBindings(); } }, { key: 'cleanNavigation', value() { if (this.navigationHammers.length != 0) { for (let t = 0; t < this.navigationHammers.length; t++) this.navigationHammers[t].destroy(); this.navigationHammers = []; } this.navigationDOM && this.navigationDOM.wrapper && this.navigationDOM.wrapper.parentNode && this.navigationDOM.wrapper.parentNode.removeChild(this.navigationDOM.wrapper), this.iconsCreated = !1; } }, { key: 'loadNavigationElements', value() { const t = this; this.cleanNavigation(), this.navigationDOM = {}; const e = ['up', 'down', 'left', 'right', 'zoomIn', 'zoomOut', 'zoomExtends']; const i = ['_moveUp', '_moveDown', '_moveLeft', '_moveRight', '_zoomIn', '_zoomOut', '_fit']; this.navigationDOM.wrapper = document.createElement('div'), this.navigationDOM.wrapper.className = 'vis-navigation', this.canvas.frame.appendChild(this.navigationDOM.wrapper); for (let o = 0; o < e.length; o++) { this.navigationDOM[e[o]] = document.createElement('div'), this.navigationDOM[e[o]].className = `vis-button vis-${e[o]}`, this.navigationDOM.wrapper.appendChild(this.navigationDOM[e[o]]); const n = new h(this.navigationDOM[e[o]]); i[o] === '_fit' ? d.onTouch(n, this._fit.bind(this)) : d.onTouch(n, this.bindToRedraw.bind(this, i[o])), this.navigationHammers.push(n); } const s = new h(this.canvas.frame); d.onRelease(s, () => { t._stopMovement(); }), this.navigationHammers.push(s), this.iconsCreated = !0; } }, { key: 'bindToRedraw', value(t) { void 0 === this.boundFunctions[t] && (this.boundFunctions[t] = this[t].bind(this), this.body.emitter.on('initRedraw', this.boundFunctions[t]), this.body.emitter.emit('_startRendering')); } }, { key: 'unbindFromRedraw', value(t) { void 0 !== this.boundFunctions[t] && (this.body.emitter.off('initRedraw', this.boundFunctions[t]), this.body.emitter.emit('_stopRendering'), delete this.boundFunctions[t]); } }, { key: '_fit', value() { (new Date()).valueOf() - this.touchTime > 700 && (this.body.emitter.emit('fit', { duration: 700 }), this.touchTime = (new Date()).valueOf()); } }, { key: '_stopMovement', value() { for (const t in this.boundFunctions) this.boundFunctions.hasOwnProperty(t) && (this.body.emitter.off('initRedraw', this.boundFunctions[t]), this.body.emitter.emit('_stopRendering')); this.boundFunctions = {}; } }, { key: '_moveUp', value() { this.body.view.translation.y += this.options.keyboard.speed.y; } }, { key: '_moveDown', value() { this.body.view.translation.y -= this.options.keyboard.speed.y; } }, { key: '_moveLeft', value() { this.body.view.translation.x += this.options.keyboard.speed.x; } }, { key: '_moveRight', value() { this.body.view.translation.x -= this.options.keyboard.speed.x; } }, { key: '_zoomIn', value() { const t = this.body.view.scale; const e = this.body.view.scale * (1 + this.options.keyboard.speed.zoom); const i = this.body.view.translation; const o = e / t; const n = (1 - o) * this.canvas.canvasViewCenter.x + i.x * o; const s = (1 - o) * this.canvas.canvasViewCenter.y + i.y * o; this.body.view.scale = e, this.body.view.translation = { x: n, y: s }, this.body.emitter.emit('zoom', { direction: '+', scale: this.body.view.scale, pointer: null }); } }, { key: '_zoomOut', value() { const t = this.body.view.scale; const e = this.body.view.scale / (1 + this.options.keyboard.speed.zoom); const i = this.body.view.translation; const o = e / t; const n = (1 - o) * this.canvas.canvasViewCenter.x + i.x * o; const s = (1 - o) * this.canvas.canvasViewCenter.y + i.y * o; this.body.view.scale = e, this.body.view.translation = { x: n, y: s }, this.body.emitter.emit('zoom', { direction: '-', scale: this.body.view.scale, pointer: null }); } }, { key: 'configureKeyboardBindings', value() { const t = this; void 0 !== this.keycharm && this.keycharm.destroy(), !0 === this.options.keyboard.enabled && (!0 === this.options.keyboard.bindToWindow ? this.keycharm = l({ container: window, preventDefault: !0 }) : this.keycharm = l({ container: this.canvas.frame, preventDefault: !0 }), this.keycharm.reset(), !0 === this.activated && (this.keycharm.bind('up', () => { t.bindToRedraw('_moveUp'); }, 'keydown'), this.keycharm.bind('down', () => { t.bindToRedraw('_moveDown'); }, 'keydown'), this.keycharm.bind('left', () => { t.bindToRedraw('_moveLeft'); }, 'keydown'), this.keycharm.bind('right', () => { t.bindToRedraw('_moveRight'); }, 'keydown'), this.keycharm.bind('=', () => { t.bindToRedraw('_zoomIn'); }, 'keydown'), this.keycharm.bind('num+', () => { t.bindToRedraw('_zoomIn'); }, 'keydown'), this.keycharm.bind('num-', () => { t.bindToRedraw('_zoomOut'); }, 'keydown'), this.keycharm.bind('-', () => { t.bindToRedraw('_zoomOut'); }, 'keydown'), this.keycharm.bind('[', () => { t.bindToRedraw('_zoomOut'); }, 'keydown'), this.keycharm.bind(']', () => { t.bindToRedraw('_zoomIn'); }, 'keydown'), this.keycharm.bind('pageup', () => { t.bindToRedraw('_zoomIn'); }, 'keydown'), this.keycharm.bind('pagedown', () => { t.bindToRedraw('_zoomOut'); }, 'keydown'), this.keycharm.bind('up', () => { t.unbindFromRedraw('_moveUp'); }, 'keyup'), this.keycharm.bind('down', () => { t.unbindFromRedraw('_moveDown'); }, 'keyup'), this.keycharm.bind('left', () => { t.unbindFromRedraw('_moveLeft'); }, 'keyup'), this.keycharm.bind('right', () => { t.unbindFromRedraw('_moveRight'); }, 'keyup'), this.keycharm.bind('=', () => { t.unbindFromRedraw('_zoomIn'); }, 'keyup'), this.keycharm.bind('num+', () => { t.unbindFromRedraw('_zoomIn'); }, 'keyup'), this.keycharm.bind('num-', () => { t.unbindFromRedraw('_zoomOut'); }, 'keyup'), this.keycharm.bind('-', () => { t.unbindFromRedraw('_zoomOut'); }, 'keyup'), this.keycharm.bind('[', () => { t.unbindFromRedraw('_zoomOut'); }, 'keyup'), this.keycharm.bind(']', () => { t.unbindFromRedraw('_zoomIn'); }, 'keyup'), this.keycharm.bind('pageup', () => { t.unbindFromRedraw('_zoomIn'); }, 'keyup'), this.keycharm.bind('pagedown', () => { t.unbindFromRedraw('_zoomOut'); }, 'keyup'))); } }]), t; }()); e.default = u; }, function (t, e, i) {
      Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(0); const n = a(o); const s = i(1); const r = a(s); function a(t) { return t && t.__esModule ? t : { default: t }; } const h = i(47).default; const d = i(74).default; const l = i(2); const
        u = (function () {
          function t(e, i) {
            const o = this; (0, n.default)(this, t), this.body = e, this.canvas = i, this.selectionObj = { nodes: [], edges: [] }, this.hoverObj = { nodes: {}, edges: {} }, this.options = {}, this.defaultOptions = {
              multiselect: !1, selectable: !0, selectConnectedEdges: !0, hoverConnectedEdges: !0,
            }, l.extend(this.options, this.defaultOptions), this.body.emitter.on('_dataChanged', () => { o.updateSelection(); });
          } return (0, r.default)(t, [{ key: 'setOptions', value(t) { if (void 0 !== t) { const e = ['multiselect', 'hoverConnectedEdges', 'selectable', 'selectConnectedEdges']; l.selectiveDeepExtend(e, this.options, t); } } }, { key: 'selectOnPoint', value(t) { let e = !1; if (!0 === this.options.selectable) { const i = this.getNodeAt(t) || this.getEdgeAt(t); this.unselectAll(), void 0 !== i && (e = this.selectObject(i)), this.body.emitter.emit('_requestRedraw'); } return e; } }, { key: 'selectAdditionalOnPoint', value(t) { let e = !1; if (!0 === this.options.selectable) { const i = this.getNodeAt(t) || this.getEdgeAt(t); void 0 !== i && (e = !0, !0 === i.isSelected() ? this.deselectObject(i) : this.selectObject(i), this.body.emitter.emit('_requestRedraw')); } return e; } }, { key: '_initBaseEvent', value(t, e) { const i = {}; return i.pointer = { DOM: { x: e.x, y: e.y }, canvas: this.canvas.DOMtoCanvas(e) }, i.event = t, i; } }, { key: '_generateClickEvent', value(t, e, i, o) { const n = arguments.length > 4 && void 0 !== arguments[4] && arguments[4]; const s = this._initBaseEvent(e, i); if (!0 === n)s.nodes = [], s.edges = []; else { const r = this.getSelection(); s.nodes = r.nodes, s.edges = r.edges; } void 0 !== o && (s.previousSelection = o), t == 'click' && (s.items = this.getClickedItems(i)), this.body.emitter.emit(t, s); } }, { key: 'selectObject', value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.options.selectConnectedEdges; return void 0 !== t && (t instanceof h && !0 === e && this._selectConnectedEdges(t), t.select(), this._addToSelection(t), !0); } }, { key: 'deselectObject', value(t) { !0 === t.isSelected() && (t.selected = !1, this._removeFromSelection(t)); } }, { key: '_getAllNodesOverlappingWith', value(t) { for (var e = [], i = this.body.nodes, o = 0; o < this.body.nodeIndices.length; o++) { const n = this.body.nodeIndices[o]; i[n].isOverlappingWith(t) && e.push(n); } return e; } }, {
            key: '_pointerToPositionObject',
            value(t) {
              const e = this.canvas.DOMtoCanvas(t); return {
                left: e.x - 1, top: e.y + 1, right: e.x + 1, bottom: e.y - 1,
              };
            }, 
          }, { key: 'getNodeAt', value(t) { const e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]; const i = this._pointerToPositionObject(t); const o = this._getAllNodesOverlappingWith(i); return o.length > 0 ? !0 === e ? this.body.nodes[o[o.length - 1]] : o[o.length - 1] : void 0; } }, { key: '_getEdgesOverlappingWith', value(t, e) { for (let i = this.body.edges, o = 0; o < this.body.edgeIndices.length; o++) { const n = this.body.edgeIndices[o]; i[n].isOverlappingWith(t) && e.push(n); } } }, { key: '_getAllEdgesOverlappingWith', value(t) { const e = []; return this._getEdgesOverlappingWith(t, e), e; } }, { key: 'getEdgeAt', value(t) { for (var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i = this.canvas.DOMtoCanvas(t), o = 10, n = null, s = this.body.edges, r = 0; r < this.body.edgeIndices.length; r++) { const a = this.body.edgeIndices[r]; const h = s[a]; if (h.connected) { const d = h.from.x; const l = h.from.y; const u = h.to.x; const c = h.to.y; const p = h.edgeType.getDistanceToEdge(d, l, u, c, i.x, i.y); p < o && (n = a, o = p); } } return n !== null ? !0 === e ? this.body.edges[n] : n : void 0; } }, { key: '_addToSelection', value(t) { t instanceof h ? this.selectionObj.nodes[t.id] = t : this.selectionObj.edges[t.id] = t; } }, { key: '_addToHover', value(t) { t instanceof h ? this.hoverObj.nodes[t.id] = t : this.hoverObj.edges[t.id] = t; } }, { key: '_removeFromSelection', value(t) { t instanceof h ? (delete this.selectionObj.nodes[t.id], this._unselectConnectedEdges(t)) : delete this.selectionObj.edges[t.id]; } }, { key: 'unselectAll', value() { for (const t in this.selectionObj.nodes) this.selectionObj.nodes.hasOwnProperty(t) && this.selectionObj.nodes[t].unselect(); for (const e in this.selectionObj.edges) this.selectionObj.edges.hasOwnProperty(e) && this.selectionObj.edges[e].unselect(); this.selectionObj = { nodes: {}, edges: {} }; } }, { key: '_getSelectedNodeCount', value() { let t = 0; for (const e in this.selectionObj.nodes) this.selectionObj.nodes.hasOwnProperty(e) && (t += 1); return t; } }, { key: '_getSelectedNode', value() { for (const t in this.selectionObj.nodes) if (this.selectionObj.nodes.hasOwnProperty(t)) return this.selectionObj.nodes[t]; } }, { key: '_getSelectedEdge', value() { for (const t in this.selectionObj.edges) if (this.selectionObj.edges.hasOwnProperty(t)) return this.selectionObj.edges[t]; } }, { key: '_getSelectedEdgeCount', value() { let t = 0; for (const e in this.selectionObj.edges) this.selectionObj.edges.hasOwnProperty(e) && (t += 1); return t; } }, { key: '_getSelectedObjectCount', value() { let t = 0; for (const e in this.selectionObj.nodes) this.selectionObj.nodes.hasOwnProperty(e) && (t += 1); for (const i in this.selectionObj.edges) this.selectionObj.edges.hasOwnProperty(i) && (t += 1); return t; } }, { key: '_selectionIsEmpty', value() { for (const t in this.selectionObj.nodes) if (this.selectionObj.nodes.hasOwnProperty(t)) return !1; for (const e in this.selectionObj.edges) if (this.selectionObj.edges.hasOwnProperty(e)) return !1; return !0; } }, { key: '_clusterInSelection', value() { for (const t in this.selectionObj.nodes) if (this.selectionObj.nodes.hasOwnProperty(t) && this.selectionObj.nodes[t].clusterSize > 1) return !0; return !1; } }, { key: '_selectConnectedEdges', value(t) { for (let e = 0; e < t.edges.length; e++) { const i = t.edges[e]; i.select(), this._addToSelection(i); } } }, { key: '_hoverConnectedEdges', value(t) { for (let e = 0; e < t.edges.length; e++) { const i = t.edges[e]; i.hover = !0, this._addToHover(i); } } }, { key: '_unselectConnectedEdges', value(t) { for (let e = 0; e < t.edges.length; e++) { const i = t.edges[e]; i.unselect(), this._removeFromSelection(i); } } }, { key: 'emitBlurEvent', value(t, e, i) { const o = this._initBaseEvent(t, e); !0 === i.hover && (i.hover = !1, i instanceof h ? (o.node = i.id, this.body.emitter.emit('blurNode', o)) : (o.edge = i.id, this.body.emitter.emit('blurEdge', o))); } }, { key: 'emitHoverEvent', value(t, e, i) { const o = this._initBaseEvent(t, e); let n = !1; return !1 === i.hover && (i.hover = !0, this._addToHover(i), n = !0, i instanceof h ? (o.node = i.id, this.body.emitter.emit('hoverNode', o)) : (o.edge = i.id, this.body.emitter.emit('hoverEdge', o))), n; } }, { key: 'hoverObject', value(t, e) { let i = this.getNodeAt(e); void 0 === i && (i = this.getEdgeAt(e)); let o = !1; for (const n in this.hoverObj.nodes) this.hoverObj.nodes.hasOwnProperty(n) && (void 0 === i || i instanceof h && i.id != n || i instanceof d) && (this.emitBlurEvent(t, e, this.hoverObj.nodes[n]), delete this.hoverObj.nodes[n], o = !0); for (const s in this.hoverObj.edges) this.hoverObj.edges.hasOwnProperty(s) && (!0 === o ? (this.hoverObj.edges[s].hover = !1, delete this.hoverObj.edges[s]) : (void 0 === i || i instanceof d && i.id != s || i instanceof h && !i.hover) && (this.emitBlurEvent(t, e, this.hoverObj.edges[s]), delete this.hoverObj.edges[s], o = !0)); void 0 !== i && (o = o || this.emitHoverEvent(t, e, i), i instanceof h && !0 === this.options.hoverConnectedEdges && this._hoverConnectedEdges(i)), !0 === o && this.body.emitter.emit('_requestRedraw'); } }, { key: 'getSelection', value() { const t = this.getSelectedNodes(); const e = this.getSelectedEdges(); return { nodes: t, edges: e }; } }, { key: 'getSelectedNodes', value() { const t = []; if (!0 === this.options.selectable) for (const e in this.selectionObj.nodes) this.selectionObj.nodes.hasOwnProperty(e) && t.push(this.selectionObj.nodes[e].id); return t; } }, { key: 'getSelectedEdges', value() { const t = []; if (!0 === this.options.selectable) for (const e in this.selectionObj.edges) this.selectionObj.edges.hasOwnProperty(e) && t.push(this.selectionObj.edges[e].id); return t; } }, { key: 'setSelection', value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; let i = void 0; let o = void 0; if (!t || !t.nodes && !t.edges) throw 'Selection must be an object with nodes and/or edges properties'; if ((e.unselectAll || void 0 === e.unselectAll) && this.unselectAll(), t.nodes) for (i = 0; i < t.nodes.length; i++) { o = t.nodes[i]; const n = this.body.nodes[o]; if (!n) throw new RangeError(`Node with id "${o}" not found`); this.selectObject(n, e.highlightEdges); } if (t.edges) for (i = 0; i < t.edges.length; i++) { o = t.edges[i]; const s = this.body.edges[o]; if (!s) throw new RangeError(`Edge with id "${o}" not found`); this.selectObject(s); } this.body.emitter.emit('_requestRedraw'); } }, { key: 'selectNodes', value(t) { const e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]; if (!t || void 0 === t.length) throw 'Selection must be an array with ids'; this.setSelection({ nodes: t }, { highlightEdges: e }); } }, { key: 'selectEdges', value(t) { if (!t || void 0 === t.length) throw 'Selection must be an array with ids'; this.setSelection({ edges: t }); } }, { key: 'updateSelection', value() { for (const t in this.selectionObj.nodes) this.selectionObj.nodes.hasOwnProperty(t) && (this.body.nodes.hasOwnProperty(t) || delete this.selectionObj.nodes[t]); for (const e in this.selectionObj.edges) this.selectionObj.edges.hasOwnProperty(e) && (this.body.edges.hasOwnProperty(e) || delete this.selectionObj.edges[e]); } }, { key: 'getClickedItems', value(t) { for (var e = this.canvas.DOMtoCanvas(t), i = [], o = this.body.nodeIndices, n = this.body.nodes, s = o.length - 1; s >= 0; s--) { const r = n[o[s]]; const a = r.getItemsOnPoint(e); i.push(...a); } for (let h = this.body.edgeIndices, d = this.body.edges, l = h.length - 1; l >= 0; l--) { const u = d[h[l]]; const c = u.getItemsOnPoint(e); i.push(...c); } return i; } }]), t;
        }()); e.default = u;
    }, function (t, e, i) {
      Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(30); const n = p(o); const s = i(6); const r = p(s); const a = i(8); const h = p(a); const d = i(0); const l = p(d); const u = i(1); const c = p(u); function p(t) { return t && t.__esModule ? t : { default: t }; } const f = i(2); const m = i(76).default; const v = i(236); const g = v.HorizontalStrategy; const y = v.VerticalStrategy; const b = (function () {
 function t() { (0, l.default)(this, t), this.childrenReference = {}, this.parentReference = {}, this.trees = {}, this.distributionOrdering = {}, this.levels = {}, this.distributionIndex = {}, this.isTree = !1, this.treeIndex = -1; } return (0, c.default)(t, [{ key: 'addRelation', value(t, e) { void 0 === this.childrenReference[t] && (this.childrenReference[t] = []), this.childrenReference[t].push(e), void 0 === this.parentReference[e] && (this.parentReference[e] = []), this.parentReference[e].push(t); } }, { key: 'checkIfTree', value() { for (const t in this.parentReference) if (this.parentReference[t].length > 1) return void (this.isTree = !1); this.isTree = !0; } }, { key: 'numTrees', value() { return this.treeIndex + 1; } }, { key: 'setTreeIndex', value(t, e) { void 0 !== e && void 0 === this.trees[t.id] && (this.trees[t.id] = e, this.treeIndex = Math.max(e, this.treeIndex)); } }, { key: 'ensureLevel', value(t) { void 0 === this.levels[t] && (this.levels[t] = 0); } }, { key: 'getMaxLevel', value(t) { const e = this; const i = {}; const o = function t(o) { if (void 0 !== i[o]) return i[o]; let n = e.levels[o]; if (e.childrenReference[o]) { const s = e.childrenReference[o]; if (s.length > 0) for (let r = 0; r < s.length; r++)n = Math.max(n, t(s[r])); } return i[o] = n, n; }; return o(t); } }, { key: 'levelDownstream', value(t, e) { void 0 === this.levels[e.id] && (void 0 === this.levels[t.id] && (this.levels[t.id] = 0), this.levels[e.id] = this.levels[t.id] + 1); } }, { key: 'setMinLevelToZero', value(t) { let e = 1e9; for (const i in t)t.hasOwnProperty(i) && void 0 !== this.levels[i] && (e = Math.min(this.levels[i], e)); for (const o in t)t.hasOwnProperty(o) && void 0 !== this.levels[o] && (this.levels[o] -= e); } }, {
 key: 'getTreeSize',
value(t, e) {
 let i = 1e9; let o = -1e9; let n = 1e9; let s = -1e9; for (const r in this.trees) if (this.trees.hasOwnProperty(r) && this.trees[r] === e) { const a = t[r]; i = Math.min(a.x, i), o = Math.max(a.x, o), n = Math.min(a.y, n), s = Math.max(a.y, s); } return {
        min_x: i, max_x: o, min_y: n, max_y: s, 
      }; 
} 
}, { key: 'hasSameParent', value(t, e) { const i = this.parentReference[t.id]; const o = this.parentReference[e.id]; if (void 0 === i || void 0 === o) return !1; for (let n = 0; n < i.length; n++) for (let s = 0; s < o.length; s++) if (i[n] == o[s]) return !0; return !1; } }, { key: 'inSameSubNetwork', value(t, e) { return this.trees[t.id] === this.trees[e.id]; } }, { key: 'getLevels', value() { return (0, h.default)(this.distributionOrdering); } }, { key: 'addToOrdering', value(t, e) { void 0 === this.distributionOrdering[e] && (this.distributionOrdering[e] = []); let i = !1; const o = this.distributionOrdering[e]; for (const n in o) if (o[n] === t) { i = !0; break; }i || (this.distributionOrdering[e].push(t), this.distributionIndex[t.id] = this.distributionOrdering[e].length - 1); } }]), t; 
}()); const _ = (function () {
        function t(e) {
          (0, l.default)(this, t), this.body = e, this.initialRandomSeed = Math.round(1e6 * Math.random()), this.randomSeed = this.initialRandomSeed, this.setPhysics = !1, this.options = {}, this.optionsBackup = { physics: {} }, this.defaultOptions = {
            randomSeed: void 0,
            improvedLayout: !0,
            hierarchical: {
              enabled: !1, levelSeparation: 150, nodeSpacing: 100, treeSpacing: 200, blockShifting: !0, edgeMinimization: !0, parentCentralization: !0, direction: 'UD', sortMethod: 'hubsize',
            },
          }, f.extend(this.options, this.defaultOptions), this.bindEventListeners();
        } return (0, c.default)(t, [{ key: 'bindEventListeners', value() { const t = this; this.body.emitter.on('_dataChanged', () => { t.setupHierarchicalLayout(); }), this.body.emitter.on('_dataLoaded', () => { t.layoutNetwork(); }), this.body.emitter.on('_resetHierarchicalLayout', () => { t.setupHierarchicalLayout(); }), this.body.emitter.on('_adjustEdgesForHierarchicalLayout', () => { if (!0 === t.options.hierarchical.enabled) { const e = t.direction.curveType(); t.body.emitter.emit('_forceDisableDynamicCurves', e, !1); } }); } }, { key: 'setOptions', value(t, e) { if (void 0 !== t) { const i = this.options.hierarchical; const o = i.enabled; if (f.selectiveDeepExtend(['randomSeed', 'improvedLayout'], this.options, t), f.mergeOptions(this.options, t, 'hierarchical'), void 0 !== t.randomSeed && (this.initialRandomSeed = t.randomSeed), !0 === i.enabled) return !0 === o && this.body.emitter.emit('refresh', !0), i.direction === 'RL' || i.direction === 'DU' ? i.levelSeparation > 0 && (i.levelSeparation *= -1) : i.levelSeparation < 0 && (i.levelSeparation *= -1), this.setDirectionStrategy(), this.body.emitter.emit('_resetHierarchicalLayout'), this.adaptAllOptionsForHierarchicalLayout(e); if (!0 === o) return this.body.emitter.emit('refresh'), f.deepExtend(e, this.optionsBackup); } return e; } }, {
          key: 'adaptAllOptionsForHierarchicalLayout',
          value(t) {
            if (!0 === this.options.hierarchical.enabled) {
              const e = this.optionsBackup.physics; void 0 === t.physics || !0 === t.physics ? (t.physics = { enabled: void 0 === e.enabled || e.enabled, solver: 'hierarchicalRepulsion' }, e.enabled = void 0 === e.enabled || e.enabled, e.solver = e.solver || 'barnesHut') : (0, r.default)(t.physics) === 'object' ? (e.enabled = void 0 === t.physics.enabled || t.physics.enabled, e.solver = t.physics.solver || 'barnesHut', t.physics.solver = 'hierarchicalRepulsion') : !1 !== t.physics && (e.solver = 'barnesHut', t.physics = { solver: 'hierarchicalRepulsion' }); let i = this.direction.curveType(); if (void 0 === t.edges) this.optionsBackup.edges = { smooth: { enabled: !0, type: 'dynamic' } }, t.edges = { smooth: !1 }; else if (void 0 === t.edges.smooth) this.optionsBackup.edges = { smooth: { enabled: !0, type: 'dynamic' } }, t.edges.smooth = !1; else if (typeof t.edges.smooth === 'boolean') this.optionsBackup.edges = { smooth: t.edges.smooth }, t.edges.smooth = { enabled: t.edges.smooth, type: i }; else {
                const o = t.edges.smooth; void 0 !== o.type && o.type !== 'dynamic' && (i = o.type), this.optionsBackup.edges = {
                  smooth: void 0 === o.enabled || o.enabled, type: void 0 === o.type ? 'dynamic' : o.type, roundness: void 0 === o.roundness ? 0.5 : o.roundness, forceDirection: void 0 !== o.forceDirection && o.forceDirection,
                }, t.edges.smooth = {
                  enabled: void 0 === o.enabled || o.enabled, type: i, roundness: void 0 === o.roundness ? 0.5 : o.roundness, forceDirection: void 0 !== o.forceDirection && o.forceDirection,
                };
              } this.body.emitter.emit('_forceDisableDynamicCurves', i);
            } return t;
          }, 
        }, { key: 'seededRandom', value() { const t = 1e4 * Math.sin(this.randomSeed++); return t - Math.floor(t); } }, { key: 'positionInitially', value(t) { if (!0 !== this.options.hierarchical.enabled) { this.randomSeed = this.initialRandomSeed; for (let e = t.length + 50, i = 0; i < t.length; i++) { const o = t[i]; const n = 2 * Math.PI * this.seededRandom(); void 0 === o.x && (o.x = e * Math.cos(n)), void 0 === o.y && (o.y = e * Math.sin(n)); } } } }, {
          key: 'layoutNetwork',
          value() {
            if (!0 !== this.options.hierarchical.enabled && !0 === this.options.improvedLayout) {
              for (var t = this.body.nodeIndices, e = 0, i = 0; i < t.length; i++) { const o = this.body.nodes[t[i]]; !0 === o.predefinedPosition && (e += 1); } if (e < 0.5 * t.length) {
                const n = 10; let s = 0; const r = 150; const a = {
                  clusterNodeProperties: {
                    shape: 'ellipse', label: '', group: '', font: { multi: !1 },
                  },
                  clusterEdgeProperties: { label: '', font: { multi: !1 }, smooth: { enabled: !1 } }, 
                }; if (t.length > r) { const h = t.length; while (t.length > r && s <= n) { s += 1; const d = t.length; s % 3 === 0 ? this.body.modules.clustering.clusterBridges(a) : this.body.modules.clustering.clusterOutliers(a); const l = t.length; if (d == l && s % 3 !== 0) return this._declusterAll(), this.body.emitter.emit('_layoutFailed'), void console.info('This network could not be positioned by this version of the improved layout algorithm. Please disable improvedLayout for better performance.'); } this.body.modules.kamadaKawai.setOptions({ springLength: Math.max(150, 2 * h) }); }s > n && console.info("The clustering didn't succeed within the amount of interations allowed, progressing with partial result."), this.body.modules.kamadaKawai.solve(t, this.body.edgeIndices, !0), this._shiftToCenter(); for (let u = 70, c = 0; c < t.length; c++) { const p = this.body.nodes[t[c]]; !1 === p.predefinedPosition && (p.x += (0.5 - this.seededRandom()) * u, p.y += (0.5 - this.seededRandom()) * u); } this._declusterAll(), this.body.emitter.emit('_repositionBezierNodes');
              }
            }
          }, 
        }, { key: '_shiftToCenter', value() { for (let t = m.getRangeCore(this.body.nodes, this.body.nodeIndices), e = m.findCenter(t), i = 0; i < this.body.nodeIndices.length; i++) { const o = this.body.nodes[this.body.nodeIndices[i]]; o.x -= e.x, o.y -= e.y; } } }, { key: '_declusterAll', value() { let t = !0; while (!0 === t) { t = !1; for (let e = 0; e < this.body.nodeIndices.length; e++)!0 === this.body.nodes[this.body.nodeIndices[e]].isCluster && (t = !0, this.body.modules.clustering.openCluster(this.body.nodeIndices[e], {}, !1)); !0 === t && this.body.emitter.emit('_dataChanged'); } } }, { key: 'getSeed', value() { return this.initialRandomSeed; } }, { key: 'setupHierarchicalLayout', value() { if (!0 === this.options.hierarchical.enabled && this.body.nodeIndices.length > 0) { let t = void 0; let e = void 0; let i = !1; let o = !1; for (e in this.lastNodeOnLevel = {}, this.hierarchical = new b(), this.body.nodes) this.body.nodes.hasOwnProperty(e) && (t = this.body.nodes[e], void 0 !== t.options.level ? (i = !0, this.hierarchical.levels[e] = t.options.level) : o = !0); if (!0 === o && !0 === i) throw new Error('To use the hierarchical layout, nodes require either no predefined levels or levels have to be defined for all nodes.'); if (!0 === o) { const n = this.options.hierarchical.sortMethod; n === 'hubsize' ? this._determineLevelsByHubsize() : n === 'directed' ? this._determineLevelsDirected() : n === 'custom' && this._determineLevelsCustomCallback(); } for (const s in this.body.nodes) this.body.nodes.hasOwnProperty(s) && this.hierarchical.ensureLevel(s); const r = this._getDistribution(); this._generateMap(), this._placeNodesByHierarchy(r), this._condenseHierarchy(), this._shiftToCenter(); } } }, { key: '_condenseHierarchy', value() { const t = this; let e = !1; const i = {}; const o = function () { for (let e = r(), i = 0, o = 0; o < e.length - 1; o++) { const n = e[o].max - e[o + 1].min; i += n + t.options.hierarchical.treeSpacing, s(o + 1, i); } }; var s = function (e, i) { const o = t.hierarchical.trees; for (const n in o)o.hasOwnProperty(n) && o[n] === e && t.direction.shift(n, i); }; var r = function () { for (var e = [], i = 0; i < t.hierarchical.numTrees(); i++)e.push(t.direction.getTreeSize(i)); return e; }; const a = function e(i, o) { if (!o[i.id] && (o[i.id] = !0, t.hierarchical.childrenReference[i.id])) { const n = t.hierarchical.childrenReference[i.id]; if (n.length > 0) for (let s = 0; s < n.length; s++)e(t.body.nodes[n[s]], o); } }; const h = function (e) { const i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1e9; let o = 1e9; let s = 1e9; let r = 1e9; let a = -1e9; for (const h in e) if (e.hasOwnProperty(h)) { const d = t.body.nodes[h]; const l = t.hierarchical.levels[d.id]; const u = t.direction.getPosition(d); const c = t._getSpaceAroundNode(d, e); const p = (0, n.default)(c, 2); const f = p[0]; const m = p[1]; o = Math.min(f, o), s = Math.min(m, s), l <= i && (r = Math.min(u, r), a = Math.max(u, a)); } return [r, a, o, s]; }; const d = function (e, i) { const o = t.hierarchical.getMaxLevel(e.id); const n = t.hierarchical.getMaxLevel(i.id); return Math.min(o, n); }; const l = function (e, i, o) { for (let n = t.hierarchical, s = 0; s < i.length; s++) { const r = i[s]; const a = n.distributionOrdering[r]; if (a.length > 1) for (let h = 0; h < a.length - 1; h++) { const d = a[h]; const l = a[h + 1]; n.hasSameParent(d, l) && n.inSameSubNetwork(d, l) && e(d, l, o); } } }; const u = function (i, o) { const n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; const s = t.direction.getPosition(i); const r = t.direction.getPosition(o); const l = Math.abs(r - s); const u = t.options.hierarchical.nodeSpacing; if (l > u) { const c = {}; const p = {}; a(i, c), a(o, p); const f = d(i, o); const m = h(c, f); const v = h(p, f); const g = m[1]; const y = v[0]; const b = v[2]; const _ = Math.abs(g - y); if (_ > u) { let w = g - y + u; w < -b + u && (w = -b + u), w < 0 && (t._shiftBlock(o.id, w), e = !0, !0 === n && t._centerParent(o)); } } }; const c = function (o, s) { for (var r = s.id, d = s.edges, l = t.hierarchical.levels[s.id], u = t.options.hierarchical.levelSeparation * t.options.hierarchical.levelSeparation, c = {}, p = [], f = 0; f < d.length; f++) { const m = d[f]; if (m.toId != m.fromId) { const v = m.toId == r ? m.from : m.to; c[d[f].id] = v, t.hierarchical.levels[v.id] < l && p.push(m); } } const g = function (e, i) { for (var o = 0, n = 0; n < i.length; n++) if (void 0 !== c[i[n].id]) { const s = t.direction.getPosition(c[i[n].id]) - e; o += s / Math.sqrt(s * s + u); } return o; }; const y = function (e, i) { for (var o = 0, n = 0; n < i.length; n++) if (void 0 !== c[i[n].id]) { let s = t.direction.getPosition(c[i[n].id]) - e; o -= u * Math.pow(s * s + u, -1.5); } return o; }; const b = function (e, i) { for (var o = t.direction.getPosition(s), n = {}, r = 0; r < e; r++) { let a = g(o, i); let h = y(o, i); let d = 40; let l = Math.max(-d, Math.min(d, Math.round(a / h))); if (o -= l, void 0 !== n[o]) break; n[o] = r; } return o; }; const _ = function (o) { let n = t.direction.getPosition(s); if (void 0 === i[s.id]) { let r = {}; a(s, r), i[s.id] = r; } let d = h(i[s.id]); let l = d[2]; let u = d[3]; let c = o - n; let p = 0; c > 0 ? p = Math.min(c, u - t.options.hierarchical.nodeSpacing) : c < 0 && (p = -Math.min(-c, l - t.options.hierarchical.nodeSpacing)), p != 0 && (t._shiftBlock(s.id, p), e = !0); }; const w = function (i) { let o = t.direction.getPosition(s); let r = t._getSpaceAroundNode(s); let a = (0, n.default)(r, 2); let h = a[0]; let d = a[1]; let l = i - o; let u = o; l > 0 ? u = Math.min(o + (d - t.options.hierarchical.nodeSpacing), i) : l < 0 && (u = Math.max(o - (h - t.options.hierarchical.nodeSpacing), i)), u !== o && (t.direction.setPosition(s, u), e = !0); }; let x = b(o, p); _(x), x = b(o, d), w(x); }; const p = function (i) { let o = t.hierarchical.getLevels(); o = o.reverse(); for (let n = 0; n < i; n++) { e = !1; for (let s = 0; s < o.length; s++) for (let r = o[s], a = t.hierarchical.distributionOrdering[r], h = 0; h < a.length; h++)c(1e3, a[h]); if (!0 !== e) break; } }; const f = function (i) { let o = t.hierarchical.getLevels(); o = o.reverse(); for (let n = 0; n < i; n++) if (e = !1, l(u, o, !0), !0 !== e) break; }; const m = function () { for (const e in t.body.nodes)t.body.nodes.hasOwnProperty(e) && t._centerParent(t.body.nodes[e]); }; const v = function () { let e = t.hierarchical.getLevels(); e = e.reverse(); for (let i = 0; i < e.length; i++) for (let o = e[i], n = t.hierarchical.distributionOrdering[o], s = 0; s < n.length; s++)t._centerParent(n[s]); }; !0 === this.options.hierarchical.blockShifting && (f(5), m()), !0 === this.options.hierarchical.edgeMinimization && p(20), !0 === this.options.hierarchical.parentCentralization && v(), o(); } }, { key: '_getSpaceAroundNode', value(t, e) { let i = !0; void 0 === e && (i = !1); const o = this.hierarchical.levels[t.id]; if (void 0 !== o) { const n = this.hierarchical.distributionIndex[t.id]; const s = this.direction.getPosition(t); const r = this.hierarchical.distributionOrdering[o]; let a = 1e9; let h = 1e9; if (n !== 0) { const d = r[n - 1]; if (!0 === i && void 0 === e[d.id] || !1 === i) { const l = this.direction.getPosition(d); a = s - l; } } if (n != r.length - 1) { const u = r[n + 1]; if (!0 === i && void 0 === e[u.id] || !1 === i) { const c = this.direction.getPosition(u); h = Math.min(h, c - s); } } return [a, h]; } return [0, 0]; } }, { key: '_centerParent', value(t) { if (this.hierarchical.parentReference[t.id]) for (let e = this.hierarchical.parentReference[t.id], i = 0; i < e.length; i++) { const o = e[i]; const s = this.body.nodes[o]; const r = this.hierarchical.childrenReference[o]; if (void 0 !== r) { const a = this._getCenterPosition(r); const h = this.direction.getPosition(s); const d = this._getSpaceAroundNode(s); const l = (0, n.default)(d, 2); const u = l[0]; const c = l[1]; const p = h - a; (p < 0 && Math.abs(p) < c - this.options.hierarchical.nodeSpacing || p > 0 && Math.abs(p) < u - this.options.hierarchical.nodeSpacing) && this.direction.setPosition(s, a); } } } }, { key: '_placeNodesByHierarchy', value(t) { for (const e in this.positionedNodes = {}, t) if (t.hasOwnProperty(e)) { let i = (0, h.default)(t[e]); i = this._indexArrayToNodes(i), this.direction.sort(i); for (let o = 0, n = 0; n < i.length; n++) { const s = i[n]; if (void 0 === this.positionedNodes[s.id]) { const r = this.options.hierarchical.nodeSpacing; let a = r * o; o > 0 && (a = this.direction.getPosition(i[n - 1]) + r), this.direction.setPosition(s, a, e), this._validatePositionAndContinue(s, e, a), o++; } } } } }, { key: '_placeBranchNodes', value(t, e) { const i = this.hierarchical.childrenReference[t]; if (void 0 !== i) { for (var o = [], n = 0; n < i.length; n++)o.push(this.body.nodes[i[n]]); this.direction.sort(o); for (let s = 0; s < o.length; s++) { const r = o[s]; const a = this.hierarchical.levels[r.id]; if (!(a > e && void 0 === this.positionedNodes[r.id])) return; const h = this.options.hierarchical.nodeSpacing; let d = void 0; d = s === 0 ? this.direction.getPosition(this.body.nodes[t]) : this.direction.getPosition(o[s - 1]) + h, this.direction.setPosition(r, d, a), this._validatePositionAndContinue(r, a, d); } const l = this._getCenterPosition(o); this.direction.setPosition(this.body.nodes[t], l, e); } } }, { key: '_validatePositionAndContinue', value(t, e, i) { if (this.hierarchical.isTree) { if (void 0 !== this.lastNodeOnLevel[e]) { const o = this.direction.getPosition(this.body.nodes[this.lastNodeOnLevel[e]]); if (i - o < this.options.hierarchical.nodeSpacing) { const n = o + this.options.hierarchical.nodeSpacing - i; const s = this._findCommonParent(this.lastNodeOnLevel[e], t.id); this._shiftBlock(s.withChild, n); } } this.lastNodeOnLevel[e] = t.id, this.positionedNodes[t.id] = !0, this._placeBranchNodes(t.id, e); } } }, { key: '_indexArrayToNodes', value(t) { for (var e = [], i = 0; i < t.length; i++)e.push(this.body.nodes[t[i]]); return e; } }, { key: '_getDistribution', value() { const t = {}; let e = void 0; let i = void 0; for (e in this.body.nodes) if (this.body.nodes.hasOwnProperty(e)) { i = this.body.nodes[e]; const o = void 0 === this.hierarchical.levels[e] ? 0 : this.hierarchical.levels[e]; this.direction.fix(i, o), void 0 === t[o] && (t[o] = {}), t[o][e] = i; } return t; } }, { key: '_getActiveEdges', value(t) { const e = this; const i = []; return f.forEach(t.edges, (t) => { e.body.edgeIndices.indexOf(t.id) !== -1 && i.push(t); }), i; } }, { key: '_getHubSizes', value() { const t = this; const e = {}; const i = this.body.nodeIndices; f.forEach(i, (i) => { const o = t.body.nodes[i]; const n = t._getActiveEdges(o).length; e[n] = !0; }); const o = []; return f.forEach(e, (t) => { o.push(Number(t)); }), o.sort((t, e) => e - t), o; } }, { key: '_determineLevelsByHubsize', value() { for (var t = this, e = function (e, i) { t.hierarchical.levelDownstream(e, i); }, i = this._getHubSizes(), o = function (o) { const n = i[o]; if (n === 0) return 'break'; f.forEach(t.body.nodeIndices, (i) => { const o = t.body.nodes[i]; n === t._getActiveEdges(o).length && t._crawlNetwork(e, i); }); }, n = 0; n < i.length; ++n) { const s = o(n); if (s === 'break') break; } } }, { key: '_determineLevelsCustomCallback', value() { const t = this; const e = 1e5; const i = function (t, e, i) {}; const o = function (o, n, s) { let r = t.hierarchical.levels[o.id]; void 0 === r && (r = t.hierarchical.levels[o.id] = e); const a = i(m.cloneOptions(o, 'node'), m.cloneOptions(n, 'node'), m.cloneOptions(s, 'edge')); t.hierarchical.levels[n.id] = r + a; }; this._crawlNetwork(o), this.hierarchical.setMinLevelToZero(this.body.nodes); } }, { key: '_determineLevelsDirected', value() { const t = this; const e = 1e4; const i = function (e) { return f.forEach(t.body.edges, (t) => { if (t.toId === e.fromId && t.fromId === e.toId) return !0; }), !1; }; const o = function (o, n, s) { let r = t.hierarchical.levels[o.id]; const a = t.hierarchical.levels[n.id]; i(s) && void 0 !== r && void 0 !== a || (void 0 === r && (r = t.hierarchical.levels[o.id] = e), s.toId == n.id ? t.hierarchical.levels[n.id] = r + 1 : t.hierarchical.levels[n.id] = r - 1); }; this._crawlNetwork(o), this.hierarchical.setMinLevelToZero(this.body.nodes); } }, { key: '_generateMap', value() { const t = this; const e = function (e, i) { t.hierarchical.levels[i.id] > t.hierarchical.levels[e.id] && t.hierarchical.addRelation(e.id, i.id); }; this._crawlNetwork(e), this.hierarchical.checkIfTree(); } }, { key: '_crawlNetwork', value() { const t = this; const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : function () {}; const i = arguments[1]; const o = {}; const n = function i(n, s) { if (void 0 === o[n.id]) { t.hierarchical.setTreeIndex(n, s), o[n.id] = !0; for (let r = void 0, a = t._getActiveEdges(n), h = 0; h < a.length; h++) { const d = a[h]; !0 === d.connected && (r = d.toId == n.id ? d.from : d.to, n.id != r.id && (e(n, r, d), i(r, s))); } } }; if (void 0 === i) for (let s = 0, r = 0; r < this.body.nodeIndices.length; r++) { const a = this.body.nodeIndices[r]; if (void 0 === o[a]) { const h = this.body.nodes[a]; n(h, s), s += 1; } } else { const d = this.body.nodes[i]; if (void 0 === d) return void console.error('Node not found:', i); n(d); } } }, { key: '_shiftBlock', value(t, e) { const i = this; const o = {}; const n = function t(n) { if (!o[n]) { o[n] = !0, i.direction.shift(n, e); const s = i.hierarchical.childrenReference[n]; if (void 0 !== s) for (let r = 0; r < s.length; r++)t(s[r]); } }; n(t); } }, { key: '_findCommonParent', value(t, e) { const i = this; const o = {}; const n = function t(e, o) { const n = i.hierarchical.parentReference[o]; if (void 0 !== n) for (let s = 0; s < n.length; s++) { const r = n[s]; e[r] = !0, t(e, r); } }; const s = function t(e, o) { const n = i.hierarchical.parentReference[o]; if (void 0 !== n) for (let s = 0; s < n.length; s++) { const r = n[s]; if (void 0 !== e[r]) return { foundParent: r, withChild: o }; const a = t(e, r); if (a.foundParent !== null) return a; } return { foundParent: null, withChild: o }; }; return n(o, t), s(o, e); } }, { key: 'setDirectionStrategy', value() { const t = this.options.hierarchical.direction === 'UD' || this.options.hierarchical.direction === 'DU'; this.direction = t ? new y(this) : new g(this); } }, { key: '_getCenterPosition', value(t) { for (var e = 1e9, i = -1e9, o = 0; o < t.length; o++) { let n = void 0; if (void 0 !== t[o].id)n = t[o]; else { const s = t[o]; n = this.body.nodes[s]; } const r = this.direction.getPosition(n); e = Math.min(e, r), i = Math.max(i, r); } return 0.5 * (e + i); } }]), t;
      }()); e.default = _;
    }, function (t, e, i) { Object.defineProperty(e, '__esModule', { value: !0 }), e.VerticalStrategy = e.HorizontalStrategy = void 0; const o = i(3); const n = p(o); const s = i(4); const r = p(s); const a = i(5); const h = p(a); const d = i(0); const l = p(d); const u = i(1); const c = p(u); function p(t) { return t && t.__esModule ? t : { default: t }; } const f = (function () { function t() { (0, l.default)(this, t); } return (0, c.default)(t, [{ key: 'abstract', value() { throw new Error("Can't instantiate abstract class!"); } }, { key: 'fake_use', value() {} }, { key: 'curveType', value() { return this.abstract(); } }, { key: 'getPosition', value(t) { return this.fake_use(t), this.abstract(); } }, { key: 'setPosition', value(t, e) { const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0; this.fake_use(t, e, i), this.abstract(); } }, { key: 'getTreeSize', value(t) { return this.fake_use(t), this.abstract(); } }, { key: 'sort', value(t) { this.fake_use(t), this.abstract(); } }, { key: 'fix', value(t, e) { this.fake_use(t, e), this.abstract(); } }, { key: 'shift', value(t, e) { this.fake_use(t, e), this.abstract(); } }]), t; }()); const m = (function (t) { function e(t) { (0, l.default)(this, e); const i = (0, r.default)(this, (e.__proto__ || (0, n.default)(e)).call(this)); return i.layout = t, i; } return (0, h.default)(e, t), (0, c.default)(e, [{ key: 'curveType', value() { return 'horizontal'; } }, { key: 'getPosition', value(t) { return t.x; } }, { key: 'setPosition', value(t, e) { const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0; void 0 !== i && this.layout.hierarchical.addToOrdering(t, i), t.x = e; } }, { key: 'getTreeSize', value(t) { const e = this.layout.hierarchical.getTreeSize(this.layout.body.nodes, t); return { min: e.min_x, max: e.max_x }; } }, { key: 'sort', value(t) { t.sort((t, e) => (void 0===t.x||void 0===e.x?0:t.x-e.x)); } }, { key: 'fix', value(t, e) { t.y = this.layout.options.hierarchical.levelSeparation * e, t.options.fixed.y = !0; } }, { key: 'shift', value(t, e) { this.layout.body.nodes[t].x += e; } }]), e; }(f)); const v = (function (t) { function e(t) { (0, l.default)(this, e); const i = (0, r.default)(this, (e.__proto__ || (0, n.default)(e)).call(this)); return i.layout = t, i; } return (0, h.default)(e, t), (0, c.default)(e, [{ key: 'curveType', value() { return 'vertical'; } }, { key: 'getPosition', value(t) { return t.y; } }, { key: 'setPosition', value(t, e) { const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0; void 0 !== i && this.layout.hierarchical.addToOrdering(t, i), t.y = e; } }, { key: 'getTreeSize', value(t) { const e = this.layout.hierarchical.getTreeSize(this.layout.body.nodes, t); return { min: e.min_y, max: e.max_y }; } }, { key: 'sort', value(t) { t.sort((t, e) => (void 0 === t.y || void 0 === e.y ? 0:t.y - e.y)); } }, { key: 'fix', value(t, e) { t.x = this.layout.options.hierarchical.levelSeparation * e, t.options.fixed.x = !0; } }, { key: 'shift', value(t, e) { this.layout.body.nodes[t].y += e; } }]), e; }(f)); e.HorizontalStrategy = v, e.VerticalStrategy = m; }, function (t, e, i) {
      Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(8); const n = p(o); const s = i(19); const r = p(s); const a = i(6); const h = p(a); const d = i(0); const l = p(d); const u = i(1); const c = p(u); function p(t) { return t && t.__esModule ? t : { default: t }; } const f = i(2); const m = i(10); const v = i(37); const g = (function () {
        function t(e, i, o) {
          const n = this; (0, l.default)(this, t), this.body = e, this.canvas = i, this.selectionHandler = o, this.editMode = !1, this.manipulationDiv = void 0, this.editModeDiv = void 0, this.closeDiv = void 0, this.manipulationHammers = [], this.temporaryUIFunctions = {}, this.temporaryEventFunctions = [], this.touchTime = 0, this.temporaryIds = { nodes: [], edges: [] }, this.guiEnabled = !1, this.inMode = !1, this.selectedControlNode = void 0, this.options = {}, this.defaultOptions = {
            enabled: !1,
            initiallyActive: !1,
            addNode: !0,
            addEdge: !0,
            editNode: void 0,
            editEdge: !0,
            deleteNode: !0,
            deleteEdge: !0,
            controlNodeStyle: {
              shape: 'dot', size: 6, color: { background: '#ff0000', border: '#3c3c3c', highlight: { background: '#07f968', border: '#3c3c3c' } }, borderWidth: 2, borderWidthSelected: 2,
            },
          }, f.extend(this.options, this.defaultOptions), this.body.emitter.on('destroy', () => { n._clean(); }), this.body.emitter.on('_dataChanged', this._restore.bind(this)), this.body.emitter.on('_resetData', this._restore.bind(this));
        } return (0, c.default)(t, [{ key: '_restore', value() { !1 !== this.inMode && (!0 === this.options.initiallyActive ? this.enableEditMode() : this.disableEditMode()); } }, { key: 'setOptions', value(t, e, i) { void 0 !== e && (void 0 !== e.locale ? this.options.locale = e.locale : this.options.locale = i.locale, void 0 !== e.locales ? this.options.locales = e.locales : this.options.locales = i.locales), void 0 !== t && (typeof t === 'boolean' ? this.options.enabled = t : (this.options.enabled = !0, f.deepExtend(this.options, t)), !0 === this.options.initiallyActive && (this.editMode = !0), this._setup()); } }, { key: 'toggleEditMode', value() { !0 === this.editMode ? this.disableEditMode() : this.enableEditMode(); } }, { key: 'enableEditMode', value() { this.editMode = !0, this._clean(), !0 === this.guiEnabled && (this.manipulationDiv.style.display = 'block', this.closeDiv.style.display = 'block', this.editModeDiv.style.display = 'none', this.showManipulatorToolbar()); } }, { key: 'disableEditMode', value() { this.editMode = !1, this._clean(), !0 === this.guiEnabled && (this.manipulationDiv.style.display = 'none', this.closeDiv.style.display = 'none', this.editModeDiv.style.display = 'block', this._createEditButton()); } }, { key: 'showManipulatorToolbar', value() { if (this._clean(), this.manipulationDOM = {}, !0 === this.guiEnabled) { this.editMode = !0, this.manipulationDiv.style.display = 'block', this.closeDiv.style.display = 'block'; const t = this.selectionHandler._getSelectedNodeCount(); const e = this.selectionHandler._getSelectedEdgeCount(); const i = t + e; const o = this.options.locales[this.options.locale]; let n = !1; !1 !== this.options.addNode && (this._createAddNodeButton(o), n = !0), !1 !== this.options.addEdge && (!0 === n ? this._createSeperator(1) : n = !0, this._createAddEdgeButton(o)), t === 1 && typeof this.options.editNode === 'function' ? (!0 === n ? this._createSeperator(2) : n = !0, this._createEditNodeButton(o)) : e === 1 && t === 0 && !1 !== this.options.editEdge && (!0 === n ? this._createSeperator(3) : n = !0, this._createEditEdgeButton(o)), i !== 0 && (t > 0 && !1 !== this.options.deleteNode ? (!0 === n && this._createSeperator(4), this._createDeleteButton(o)) : t === 0 && !1 !== this.options.deleteEdge && (!0 === n && this._createSeperator(4), this._createDeleteButton(o))), this._bindHammerToDiv(this.closeDiv, this.toggleEditMode.bind(this)), this._temporaryBindEvent('select', this.showManipulatorToolbar.bind(this)); } this.body.emitter.emit('_redraw'); } }, { key: 'addNodeMode', value() { if (!0 !== this.editMode && this.enableEditMode(), this._clean(), this.inMode = 'addNode', !0 === this.guiEnabled) { const t = this.options.locales[this.options.locale]; this.manipulationDOM = {}, this._createBackButton(t), this._createSeperator(), this._createDescription(t.addDescription || this.options.locales.en.addDescription), this._bindHammerToDiv(this.closeDiv, this.toggleEditMode.bind(this)); } this._temporaryBindEvent('click', this._performAddNode.bind(this)); } }, { key: 'editNode', value() { const t = this; !0 !== this.editMode && this.enableEditMode(), this._clean(); const e = this.selectionHandler._getSelectedNode(); if (void 0 !== e) { if (this.inMode = 'editNode', typeof this.options.editNode !== 'function') throw new Error('No function has been configured to handle the editing of nodes.'); if (!0 !== e.isCluster) { const i = f.deepExtend({}, e.options, !1); if (i.x = e.x, i.y = e.y, this.options.editNode.length !== 2) throw new Error('The function for edit does not support two arguments (data, callback)'); this.options.editNode(i, (e) => { e !== null && void 0 !== e && t.inMode === 'editNode' && t.body.data.nodes.getDataSet().update(e), t.showManipulatorToolbar(); }); } else alert(this.options.locales[this.options.locale].editClusterError || this.options.locales.en.editClusterError); } else this.showManipulatorToolbar(); } }, { key: 'addEdgeMode', value() { if (!0 !== this.editMode && this.enableEditMode(), this._clean(), this.inMode = 'addEdge', !0 === this.guiEnabled) { const t = this.options.locales[this.options.locale]; this.manipulationDOM = {}, this._createBackButton(t), this._createSeperator(), this._createDescription(t.edgeDescription || this.options.locales.en.edgeDescription), this._bindHammerToDiv(this.closeDiv, this.toggleEditMode.bind(this)); } this._temporaryBindUI('onTouch', this._handleConnect.bind(this)), this._temporaryBindUI('onDragEnd', this._finishConnect.bind(this)), this._temporaryBindUI('onDrag', this._dragControlNode.bind(this)), this._temporaryBindUI('onRelease', this._finishConnect.bind(this)), this._temporaryBindUI('onDragStart', this._dragStartEdge.bind(this)), this._temporaryBindUI('onHold', () => {}); } }, { key: 'editEdgeMode', value() { if (!0 !== this.editMode && this.enableEditMode(), this._clean(), this.inMode = 'editEdge', (0, h.default)(this.options.editEdge) !== 'object' || typeof this.options.editEdge.editWithoutDrag !== 'function' || (this.edgeBeingEditedId = this.selectionHandler.getSelectedEdges()[0], void 0 === this.edgeBeingEditedId)) { if (!0 === this.guiEnabled) { const t = this.options.locales[this.options.locale]; this.manipulationDOM = {}, this._createBackButton(t), this._createSeperator(), this._createDescription(t.editEdgeDescription || this.options.locales.en.editEdgeDescription), this._bindHammerToDiv(this.closeDiv, this.toggleEditMode.bind(this)); } if (this.edgeBeingEditedId = this.selectionHandler.getSelectedEdges()[0], void 0 !== this.edgeBeingEditedId) { const e = this.body.edges[this.edgeBeingEditedId]; const i = this._getNewTargetNode(e.from.x, e.from.y); const o = this._getNewTargetNode(e.to.x, e.to.y); this.temporaryIds.nodes.push(i.id), this.temporaryIds.nodes.push(o.id), this.body.nodes[i.id] = i, this.body.nodeIndices.push(i.id), this.body.nodes[o.id] = o, this.body.nodeIndices.push(o.id), this._temporaryBindUI('onTouch', this._controlNodeTouch.bind(this)), this._temporaryBindUI('onTap', () => {}), this._temporaryBindUI('onHold', () => {}), this._temporaryBindUI('onDragStart', this._controlNodeDragStart.bind(this)), this._temporaryBindUI('onDrag', this._controlNodeDrag.bind(this)), this._temporaryBindUI('onDragEnd', this._controlNodeDragEnd.bind(this)), this._temporaryBindUI('onMouseMove', () => {}), this._temporaryBindEvent('beforeDrawing', (t) => { const n = e.edgeType.findBorderPositions(t); !1 === i.selected && (i.x = n.from.x, i.y = n.from.y), !1 === o.selected && (o.x = n.to.x, o.y = n.to.y); }), this.body.emitter.emit('_redraw'); } else this.showManipulatorToolbar(); } else { const n = this.body.edges[this.edgeBeingEditedId]; this._performEditEdge(n.from, n.to); } } }, { key: 'deleteSelected', value() { const t = this; !0 !== this.editMode && this.enableEditMode(), this._clean(), this.inMode = 'delete'; const e = this.selectionHandler.getSelectedNodes(); const i = this.selectionHandler.getSelectedEdges(); let o = void 0; if (e.length > 0) { for (let n = 0; n < e.length; n++) if (!0 === this.body.nodes[e[n]].isCluster) return void alert(this.options.locales[this.options.locale].deleteClusterError || this.options.locales.en.deleteClusterError); typeof this.options.deleteNode === 'function' && (o = this.options.deleteNode); } else i.length > 0 && typeof this.options.deleteEdge === 'function' && (o = this.options.deleteEdge); if (typeof o === 'function') { const s = { nodes: e, edges: i }; if (o.length !== 2) throw new Error('The function for delete does not support two arguments (data, callback)'); o(s, (e) => { e !== null && void 0 !== e && t.inMode === 'delete' ? (t.body.data.edges.getDataSet().remove(e.edges), t.body.data.nodes.getDataSet().remove(e.nodes), t.body.emitter.emit('startSimulation'), t.showManipulatorToolbar()) : (t.body.emitter.emit('startSimulation'), t.showManipulatorToolbar()); }); } else this.body.data.edges.getDataSet().remove(i), this.body.data.nodes.getDataSet().remove(e), this.body.emitter.emit('startSimulation'), this.showManipulatorToolbar(); } }, { key: '_setup', value() { !0 === this.options.enabled ? (this.guiEnabled = !0, this._createWrappers(), !1 === this.editMode ? this._createEditButton() : this.showManipulatorToolbar()) : (this._removeManipulationDOM(), this.guiEnabled = !1); } }, { key: '_createWrappers', value() { void 0 === this.manipulationDiv && (this.manipulationDiv = document.createElement('div'), this.manipulationDiv.className = 'vis-manipulation', !0 === this.editMode ? this.manipulationDiv.style.display = 'block' : this.manipulationDiv.style.display = 'none', this.canvas.frame.appendChild(this.manipulationDiv)), void 0 === this.editModeDiv && (this.editModeDiv = document.createElement('div'), this.editModeDiv.className = 'vis-edit-mode', !0 === this.editMode ? this.editModeDiv.style.display = 'none' : this.editModeDiv.style.display = 'block', this.canvas.frame.appendChild(this.editModeDiv)), void 0 === this.closeDiv && (this.closeDiv = document.createElement('div'), this.closeDiv.className = 'vis-close', this.closeDiv.style.display = this.manipulationDiv.style.display, this.canvas.frame.appendChild(this.closeDiv)); } }, {
          key: '_getNewTargetNode',
          value(t, e) {
            const i = f.deepExtend({}, this.options.controlNodeStyle); i.id = `targetNode${f.randomUUID()}`, i.hidden = !1, i.physics = !1, i.x = t, i.y = e; const o = this.body.functions.createNode(i); return o.shape.boundingBox = {
              left: t, right: t, top: e, bottom: e,
            }, o;
          }, 
        }, { key: '_createEditButton', value() { this._clean(), this.manipulationDOM = {}, f.recursiveDOMDelete(this.editModeDiv); const t = this.options.locales[this.options.locale]; const e = this._createButton('editMode', 'vis-button vis-edit vis-edit-mode', t.edit || this.options.locales.en.edit); this.editModeDiv.appendChild(e), this._bindHammerToDiv(e, this.toggleEditMode.bind(this)); } }, { key: '_clean', value() { this.inMode = !1, !0 === this.guiEnabled && (f.recursiveDOMDelete(this.editModeDiv), f.recursiveDOMDelete(this.manipulationDiv), this._cleanManipulatorHammers()), this._cleanupTemporaryNodesAndEdges(), this._unbindTemporaryUIs(), this._unbindTemporaryEvents(), this.body.emitter.emit('restorePhysics'); } }, { key: '_cleanManipulatorHammers', value() { if (this.manipulationHammers.length != 0) { for (let t = 0; t < this.manipulationHammers.length; t++) this.manipulationHammers[t].destroy(); this.manipulationHammers = []; } } }, { key: '_removeManipulationDOM', value() { this._clean(), f.recursiveDOMDelete(this.manipulationDiv), f.recursiveDOMDelete(this.editModeDiv), f.recursiveDOMDelete(this.closeDiv), this.manipulationDiv && this.canvas.frame.removeChild(this.manipulationDiv), this.editModeDiv && this.canvas.frame.removeChild(this.editModeDiv), this.closeDiv && this.canvas.frame.removeChild(this.closeDiv), this.manipulationDiv = void 0, this.editModeDiv = void 0, this.closeDiv = void 0; } }, { key: '_createSeperator', value() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1; this.manipulationDOM[`seperatorLineDiv${t}`] = document.createElement('div'), this.manipulationDOM[`seperatorLineDiv${t}`].className = 'vis-separator-line', this.manipulationDiv.appendChild(this.manipulationDOM[`seperatorLineDiv${t}`]); } }, { key: '_createAddNodeButton', value(t) { const e = this._createButton('addNode', 'vis-button vis-add', t.addNode || this.options.locales.en.addNode); this.manipulationDiv.appendChild(e), this._bindHammerToDiv(e, this.addNodeMode.bind(this)); } }, { key: '_createAddEdgeButton', value(t) { const e = this._createButton('addEdge', 'vis-button vis-connect', t.addEdge || this.options.locales.en.addEdge); this.manipulationDiv.appendChild(e), this._bindHammerToDiv(e, this.addEdgeMode.bind(this)); } }, { key: '_createEditNodeButton', value(t) { const e = this._createButton('editNode', 'vis-button vis-edit', t.editNode || this.options.locales.en.editNode); this.manipulationDiv.appendChild(e), this._bindHammerToDiv(e, this.editNode.bind(this)); } }, { key: '_createEditEdgeButton', value(t) { const e = this._createButton('editEdge', 'vis-button vis-edit', t.editEdge || this.options.locales.en.editEdge); this.manipulationDiv.appendChild(e), this._bindHammerToDiv(e, this.editEdgeMode.bind(this)); } }, { key: '_createDeleteButton', value(t) { let e; e = this.options.rtl ? 'vis-button vis-delete-rtl' : 'vis-button vis-delete'; const i = this._createButton('delete', e, t.del || this.options.locales.en.del); this.manipulationDiv.appendChild(i), this._bindHammerToDiv(i, this.deleteSelected.bind(this)); } }, { key: '_createBackButton', value(t) { const e = this._createButton('back', 'vis-button vis-back', t.back || this.options.locales.en.back); this.manipulationDiv.appendChild(e), this._bindHammerToDiv(e, this.showManipulatorToolbar.bind(this)); } }, { key: '_createButton', value(t, e, i) { const o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 'vis-label'; return this.manipulationDOM[`${t}Div`] = document.createElement('div'), this.manipulationDOM[`${t}Div`].className = e, this.manipulationDOM[`${t}Label`] = document.createElement('div'), this.manipulationDOM[`${t}Label`].className = o, this.manipulationDOM[`${t}Label`].innerHTML = i, this.manipulationDOM[`${t}Div`].appendChild(this.manipulationDOM[`${t}Label`]), this.manipulationDOM[`${t}Div`]; } }, { key: '_createDescription', value(t) { this.manipulationDiv.appendChild(this._createButton('description', 'vis-button vis-none', t)); } }, { key: '_temporaryBindEvent', value(t, e) { this.temporaryEventFunctions.push({ event: t, boundFunction: e }), this.body.emitter.on(t, e); } }, { key: '_temporaryBindUI', value(t, e) { if (void 0 === this.body.eventListeners[t]) throw new Error(`This UI function does not exist. Typo? You tried: ${t} possible are: ${(0, r.default)((0, n.default)(this.body.eventListeners))}`); this.temporaryUIFunctions[t] = this.body.eventListeners[t], this.body.eventListeners[t] = e; } }, { key: '_unbindTemporaryUIs', value() { for (const t in this.temporaryUIFunctions) this.temporaryUIFunctions.hasOwnProperty(t) && (this.body.eventListeners[t] = this.temporaryUIFunctions[t], delete this.temporaryUIFunctions[t]); this.temporaryUIFunctions = {}; } }, { key: '_unbindTemporaryEvents', value() { for (let t = 0; t < this.temporaryEventFunctions.length; t++) { const e = this.temporaryEventFunctions[t].event; const i = this.temporaryEventFunctions[t].boundFunction; this.body.emitter.off(e, i); } this.temporaryEventFunctions = []; } }, { key: '_bindHammerToDiv', value(t, e) { const i = new m(t, {}); v.onTouch(i, e), this.manipulationHammers.push(i); } }, { key: '_cleanupTemporaryNodesAndEdges', value() { for (let t = 0; t < this.temporaryIds.edges.length; t++) { this.body.edges[this.temporaryIds.edges[t]].disconnect(), delete this.body.edges[this.temporaryIds.edges[t]]; const e = this.body.edgeIndices.indexOf(this.temporaryIds.edges[t]); e !== -1 && this.body.edgeIndices.splice(e, 1); } for (let i = 0; i < this.temporaryIds.nodes.length; i++) { delete this.body.nodes[this.temporaryIds.nodes[i]]; const o = this.body.nodeIndices.indexOf(this.temporaryIds.nodes[i]); o !== -1 && this.body.nodeIndices.splice(o, 1); } this.temporaryIds = { nodes: [], edges: [] }; } }, { key: '_controlNodeTouch', value(t) { this.selectionHandler.unselectAll(), this.lastTouch = this.body.functions.getPointer(t.center), this.lastTouch.translation = f.extend({}, this.body.view.translation); } }, { key: '_controlNodeDragStart', value(t) { const e = this.lastTouch; const i = this.selectionHandler._pointerToPositionObject(e); const o = this.body.nodes[this.temporaryIds.nodes[0]]; const n = this.body.nodes[this.temporaryIds.nodes[1]]; const s = this.body.edges[this.edgeBeingEditedId]; this.selectedControlNode = void 0; const r = o.isOverlappingWith(i); const a = n.isOverlappingWith(i); !0 === r ? (this.selectedControlNode = o, s.edgeType.from = o) : !0 === a && (this.selectedControlNode = n, s.edgeType.to = n), void 0 !== this.selectedControlNode && this.selectionHandler.selectObject(this.selectedControlNode), this.body.emitter.emit('_redraw'); } }, { key: '_controlNodeDrag', value(t) { this.body.emitter.emit('disablePhysics'); const e = this.body.functions.getPointer(t.center); const i = this.canvas.DOMtoCanvas(e); if (void 0 !== this.selectedControlNode) this.selectedControlNode.x = i.x, this.selectedControlNode.y = i.y; else { const o = e.x - this.lastTouch.x; const n = e.y - this.lastTouch.y; this.body.view.translation = { x: this.lastTouch.translation.x + o, y: this.lastTouch.translation.y + n }; } this.body.emitter.emit('_redraw'); } }, { key: '_controlNodeDragEnd', value(t) { const e = this.body.functions.getPointer(t.center); const i = this.selectionHandler._pointerToPositionObject(e); const o = this.body.edges[this.edgeBeingEditedId]; if (void 0 !== this.selectedControlNode) { this.selectionHandler.unselectAll(); for (var n = this.selectionHandler._getAllNodesOverlappingWith(i), s = void 0, r = n.length - 1; r >= 0; r--) if (n[r] !== this.selectedControlNode.id) { s = this.body.nodes[n[r]]; break; } if (void 0 !== s && void 0 !== this.selectedControlNode) if (!0 === s.isCluster)alert(this.options.locales[this.options.locale].createEdgeError || this.options.locales.en.createEdgeError); else { const a = this.body.nodes[this.temporaryIds.nodes[0]]; this.selectedControlNode.id === a.id ? this._performEditEdge(s.id, o.to.id) : this._performEditEdge(o.from.id, s.id); } else o.updateEdgeType(), this.body.emitter.emit('restorePhysics'); this.body.emitter.emit('_redraw'); } } }, {
          key: '_handleConnect',
          value(t) {
            if ((new Date()).valueOf() - this.touchTime > 100) {
              this.lastTouch = this.body.functions.getPointer(t.center), this.lastTouch.translation = f.extend({}, this.body.view.translation); const e = this.lastTouch; const i = this.selectionHandler.getNodeAt(e); if (void 0 !== i) { if (!0 === i.isCluster)alert(this.options.locales[this.options.locale].createEdgeError || this.options.locales.en.createEdgeError); else {
 const o = this._getNewTargetNode(i.x, i.y); this.body.nodes[o.id] = o, this.body.nodeIndices.push(o.id); const n = this.body.functions.createEdge({
                id: `connectionEdge${  f.randomUUID()}`, from: i.id, to: o.id, physics: !1, smooth: { enabled: !0, type: 'continuous', roundness: 0.5 }, 
              }); this.body.edges[n.id] = n, this.body.edgeIndices.push(n.id), this.temporaryIds.nodes.push(o.id), this.temporaryIds.edges.push(n.id); 
} } this.touchTime = (new Date()).valueOf();
            }
          }, 
        }, { key: '_dragControlNode', value(t) { const e = this.body.functions.getPointer(t.center); if (void 0 !== this.temporaryIds.nodes[0]) { const i = this.body.nodes[this.temporaryIds.nodes[0]]; i.x = this.canvas._XconvertDOMtoCanvas(e.x), i.y = this.canvas._YconvertDOMtoCanvas(e.y), this.body.emitter.emit('_redraw'); } else { const o = e.x - this.lastTouch.x; const n = e.y - this.lastTouch.y; this.body.view.translation = { x: this.lastTouch.translation.x + o, y: this.lastTouch.translation.y + n }; } } }, { key: '_finishConnect', value(t) { const e = this.body.functions.getPointer(t.center); const i = this.selectionHandler._pointerToPositionObject(e); let o = void 0; void 0 !== this.temporaryIds.edges[0] && (o = this.body.edges[this.temporaryIds.edges[0]].fromId); for (var n = this.selectionHandler._getAllNodesOverlappingWith(i), s = void 0, r = n.length - 1; r >= 0; r--) if (this.temporaryIds.nodes.indexOf(n[r]) === -1) { s = this.body.nodes[n[r]]; break; } this._cleanupTemporaryNodesAndEdges(), void 0 !== s && (!0 === s.isCluster ? alert(this.options.locales[this.options.locale].createEdgeError || this.options.locales.en.createEdgeError) : void 0 !== this.body.nodes[o] && void 0 !== this.body.nodes[s.id] && this._performAddEdge(o, s.id)), this.body.emitter.emit('_redraw'); } }, { key: '_dragStartEdge', value(t) { const e = this.lastTouch; this.selectionHandler._generateClickEvent('dragStart', t, e, void 0, !0); } }, {
          key: '_performAddNode',
          value(t) {
            const e = this; const i = {
              id: f.randomUUID(), x: t.pointer.canvas.x, y: t.pointer.canvas.y, label: 'new',
            }; if (typeof this.options.addNode === 'function') { if (this.options.addNode.length !== 2) throw this.showManipulatorToolbar(), new Error('The function for add does not support two arguments (data,callback)'); this.options.addNode(i, (t) => { t !== null && void 0 !== t && e.inMode === 'addNode' && (e.body.data.nodes.getDataSet().add(t), e.showManipulatorToolbar()); }); } else this.body.data.nodes.getDataSet().add(i), this.showManipulatorToolbar();
          }, 
        }, { key: '_performAddEdge', value(t, e) { const i = this; const o = { from: t, to: e }; if (typeof this.options.addEdge === 'function') { if (this.options.addEdge.length !== 2) throw new Error('The function for connect does not support two arguments (data,callback)'); this.options.addEdge(o, (t) => { t !== null && void 0 !== t && i.inMode === 'addEdge' && (i.body.data.edges.getDataSet().add(t), i.selectionHandler.unselectAll(), i.showManipulatorToolbar()); }); } else this.body.data.edges.getDataSet().add(o), this.selectionHandler.unselectAll(), this.showManipulatorToolbar(); } }, {
 key: '_performEditEdge',
value(t, e) {
 const i = this; const o = {
          id: this.edgeBeingEditedId, from: t, to: e, label: this.body.data.edges._data[this.edgeBeingEditedId].label, 
        }; let n = this.options.editEdge; if ((typeof n === 'undefined' ? 'undefined' : (0, h.default)(n)) === 'object' && (n = n.editWithoutDrag), typeof n === 'function') { if (n.length !== 2) throw new Error('The function for edit does not support two arguments (data, callback)'); n(o, (t) => { t === null || void 0 === t || i.inMode !== 'editEdge' ? (i.body.edges[o.id].updateEdgeType(), i.body.emitter.emit('_redraw'), i.showManipulatorToolbar()) : (i.body.data.edges.getDataSet().update(t), i.selectionHandler.unselectAll(), i.showManipulatorToolbar()); }); } else this.body.data.edges.getDataSet().update(o), this.selectionHandler.unselectAll(), this.showManipulatorToolbar(); 
} 
}]), t;
      }()); e.default = g;
    }, function (t, e, i) { Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(30); const n = u(o); const s = i(0); const r = u(s); const a = i(1); const h = u(a); const d = i(239); const l = u(d); function u(t) { return t && t.__esModule ? t : { default: t }; } const c = (function () { function t(e, i, o) { (0, r.default)(this, t), this.body = e, this.springLength = i, this.springConstant = o, this.distanceSolver = new l.default(); } return (0, h.default)(t, [{ key: 'setOptions', value(t) { t && (t.springLength && (this.springLength = t.springLength), t.springConstant && (this.springConstant = t.springConstant)); } }, { key: 'solve', value(t, e) { const i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; const o = this.distanceSolver.getDistances(this.body, t, e); this._createL_matrix(o), this._createK_matrix(o), this._createE_matrix(); const s = 0.01; const r = 1; let a = 0; const h = Math.max(1e3, Math.min(10 * this.body.nodeIndices.length, 6e3)); const d = 5; let l = 1e9; let u = 0; let c = 0; let p = 0; let f = 0; let m = 0; while (l > s && a < h) { a += 1; const v = this._getHighestEnergyNode(i); const g = (0, n.default)(v, 4); u = g[0], l = g[1], c = g[2], p = g[3], f = l, m = 0; while (f > r && m < d) { m += 1, this._moveNode(u, c, p); const y = this._getEnergy(u); const b = (0, n.default)(y, 3); f = b[0], c = b[1], p = b[2]; } } } }, { key: '_getHighestEnergyNode', value(t) { for (var e = this.body.nodeIndices, i = this.body.nodes, o = 0, s = e[0], r = 0, a = 0, h = 0; h < e.length; h++) { const d = e[h]; if (!1 === i[d].predefinedPosition || !0 === i[d].isCluster && !0 === t || !0 === i[d].options.fixed.x || !0 === i[d].options.fixed.y) { const l = this._getEnergy(d); const u = (0, n.default)(l, 3); const c = u[0]; const p = u[1]; const f = u[2]; o < c && (o = c, s = d, r = p, a = f); } } return [s, o, r, a]; } }, { key: '_getEnergy', value(t) { const e = (0, n.default)(this.E_sums[t], 2); const i = e[0]; const o = e[1]; const s = Math.sqrt(Math.pow(i, 2) + Math.pow(o, 2)); return [s, i, o]; } }, { key: '_moveNode', value(t, e, i) { for (var o = this.body.nodeIndices, n = this.body.nodes, s = 0, r = 0, a = 0, h = n[t].x, d = n[t].y, l = this.K_matrix[t], u = this.L_matrix[t], c = 0; c < o.length; c++) { const p = o[c]; if (p !== t) { const f = n[p].x; const m = n[p].y; const v = l[p]; const g = u[p]; const y = 1 / Math.pow(Math.pow(h - f, 2) + Math.pow(d - m, 2), 1.5); s += v * (1 - g * Math.pow(d - m, 2) * y), r += v * (g * (h - f) * (d - m) * y), a += v * (1 - g * Math.pow(h - f, 2) * y); } } const b = s; const _ = r; const w = e; const x = a; const k = i; const D = (w / b + k / _) / (_ / b - x / _); const S = -(_ * D + w) / b; n[t].x += S, n[t].y += D, this._updateE_matrix(t); } }, { key: '_createL_matrix', value(t) { const e = this.body.nodeIndices; const i = this.springLength; this.L_matrix = []; for (let o = 0; o < e.length; o++) { this.L_matrix[e[o]] = {}; for (let n = 0; n < e.length; n++) this.L_matrix[e[o]][e[n]] = i * t[e[o]][e[n]]; } } }, { key: '_createK_matrix', value(t) { const e = this.body.nodeIndices; const i = this.springConstant; this.K_matrix = []; for (let o = 0; o < e.length; o++) { this.K_matrix[e[o]] = {}; for (let n = 0; n < e.length; n++) this.K_matrix[e[o]][e[n]] = i * Math.pow(t[e[o]][e[n]], -2); } } }, { key: '_createE_matrix', value() { const t = this.body.nodeIndices; const e = this.body.nodes; this.E_matrix = {}, this.E_sums = {}; for (let i = 0; i < t.length; i++) this.E_matrix[t[i]] = []; for (let o = 0; o < t.length; o++) { for (var n = t[o], s = e[n].x, r = e[n].y, a = 0, h = 0, d = o; d < t.length; d++) { const l = t[d]; if (l !== n) { const u = e[l].x; const c = e[l].y; const p = 1 / Math.sqrt(Math.pow(s - u, 2) + Math.pow(r - c, 2)); this.E_matrix[n][d] = [this.K_matrix[n][l] * (s - u - this.L_matrix[n][l] * (s - u) * p), this.K_matrix[n][l] * (r - c - this.L_matrix[n][l] * (r - c) * p)], this.E_matrix[l][o] = this.E_matrix[n][d], a += this.E_matrix[n][d][0], h += this.E_matrix[n][d][1]; } } this.E_sums[n] = [a, h]; } } }, { key: '_updateE_matrix', value(t) { for (var e = this.body.nodeIndices, i = this.body.nodes, o = this.E_matrix[t], n = this.K_matrix[t], s = this.L_matrix[t], r = i[t].x, a = i[t].y, h = 0, d = 0, l = 0; l < e.length; l++) { const u = e[l]; if (u !== t) { const c = o[l]; const p = c[0]; const f = c[1]; const m = i[u].x; const v = i[u].y; const g = 1 / Math.sqrt(Math.pow(r - m, 2) + Math.pow(a - v, 2)); const y = n[u] * (r - m - s[u] * (r - m) * g); const b = n[u] * (a - v - s[u] * (a - v) * g); o[l] = [y, b], h += y, d += b; const _ = this.E_sums[u]; _[0] += y - p, _[1] += b - f; } } this.E_sums[t] = [h, d]; } }]), t; }()); e.default = c; }, function (t, e, i) { Object.defineProperty(e, '__esModule', { value: !0 }); const o = i(0); const n = a(o); const s = i(1); const r = a(s); function a(t) { return t && t.__esModule ? t : { default: t }; } const h = (function () { function t() { (0, n.default)(this, t); } return (0, r.default)(t, [{ key: 'getDistances', value(t, e, i) { for (var o = {}, n = t.edges, s = 0; s < e.length; s++) { const r = e[s]; const a = {}; o[r] = a; for (let h = 0; h < e.length; h++)a[e[h]] = s == h ? 0 : 1e9; } for (let d = 0; d < i.length; d++) { const l = n[i[d]]; !0 === l.connected && void 0 !== o[l.fromId] && void 0 !== o[l.toId] && (o[l.fromId][l.toId] = 1, o[l.toId][l.fromId] = 1); } for (let u = e.length, c = 0; c < u; c++) for (let p = e[c], f = o[p], m = 0; m < u - 1; m++) for (let v = e[m], g = o[v], y = m + 1; y < u; y++) { const b = e[y]; const _ = o[b]; const w = Math.min(g[b], g[p] + f[b]); g[b] = w, _[v] = w; } return o; } }]), t; }()); e.default = h; }]))));
  },
  cd7b(t, e, i) {},
  dfa9(t, e, i) {
    const o = i('cd7b'); const n = i.n(o); n.a;
  },
}]);
// # sourceMappingURL=recipe.2f455e4c.js.map
